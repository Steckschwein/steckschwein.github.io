<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Steckschwein</title><link>https://www.steckschwein.de/</link><description>Recent content on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 28 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.steckschwein.de/index.xml" rel="self" type="application/rss+xml"/><item><title>It's a Long Way to the Memory Top</title><link>https://www.steckschwein.de/post/its-a-long-way-to-the-memory-top/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/its-a-long-way-to-the-memory-top/</guid><description>In preparation for the build of our new CPU-Board, we purchased two WDC 65c02 in PLCC44 package from some eBay vendor. On arrival, the first interesting thing is the way they were packaged. No anti esd packaging, only a plastic bag, which we found sketchy enough to post on Twitter.
Next, WDC reacted to that tweet, stating that these might be not genuine or be at least very old.
So much for ESD safe packaging pic.</description><content>&lt;p>In preparation for the build of our new CPU-Board, we purchased two WDC 65c02 in PLCC44 package from some eBay vendor.
On arrival, the first interesting thing is the way they were packaged. No anti esd packaging, only a plastic bag, which we found sketchy enough to post on Twitter.&lt;/p>
&lt;p>Next, WDC reacted to that tweet, stating that these might be not genuine or be at least very old.&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="en" dir="ltr">So much for ESD safe packaging &lt;a href="https://t.co/0bxPEAJ7eo">pic.twitter.com/0bxPEAJ7eo&lt;/a>&lt;/p>&amp;mdash; Steckschwein (@steckschwein) &lt;a href="https://twitter.com/steckschwein/status/1532446031127904256?ref_src=twsrc%5Etfw">June 2, 2022&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;p>At least they did arrive in time so we finally could assemble the first new CPU board. This board marks a lot of firsts for us:&lt;/p>
&lt;ol>
&lt;li>our first 4 layer board&lt;/li>
&lt;li>first time using PLCC chips&lt;/li>
&lt;li>first autorouted board&lt;/li>
&lt;li>first time using a CPLD (Xilinx XC9572 (PLCC84))&lt;/li>
&lt;li>first time making a board without having breadboarded everything first&lt;/li>
&lt;li>first time following a lot of people’s advice to put bus transceivers between the CPU board and the rest of the system&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="images/512k_cpu_board.jpg" alt="New CPU Board with 512k RAM" title="New CPU Board with 512k RAM">&lt;/p>
&lt;p>With so many degrees of freedom, we could not be sure what to expect at first power up. We modified the BIOS to only inititalize the on board UART (another first, CPU board with UART..) and output some characters on the serial interface.
Ideally, the BIOS would start up and send something.&lt;/p>
&lt;p>But living in a non ideal world, nothing visible happened.
To detect any signs of life, we had to proceed using oscilloscope and logic analyzer only to find the bus was completely dead. We spent quite a while troubleshooting, and identified the RDY generator inside the CPLD as the first culprit. After disabling the latter, and continuing with a slower clock speed, we at least had activity on the bus, but still nothing on the serial interface.&lt;/p>
&lt;p>Scope and logic analyzer readings still were inconclusive at best. When trying to observe the VPB pin with the scope, we noticed that this pin seemed to be dead. Which is odd, because it shoud have shown some activity at least after the RESET-pulse. Also, when observing the address bus, A0 did seem to be always high.. highly unlikely for an address line, especially for such a low one.&lt;/p>
&lt;p>Back to the sketchy CPUs. Are they 65C02s at all?
Measuring Pin 43(PHI2 OUT) and Pin 4 (PHI1 out) showed us a clock signal there. Also, the SYNC Signal (Pin 8) showed some activity. So the chip did seem to be something 6502ish..
We then compared the PLCC44 pinouts from the WDC datasheet to one from Rockwell.&lt;/p>
&lt;p>&lt;img src="images/plcc44_rockwell.png" alt="" title="PLCC44 Rockwell">
&lt;img src="images/plcc44_wdc.png" alt="" title="PLCC44 WDC">&lt;/p>
&lt;p>Pin 2 (VPB on WDC) on the Rockwell chip is NC.. which explains why we did not measure anything there. Also, on the Rockwell chip, Pin 10 is Vcc, while the same pin on WDC is A0..
So, our WDC is indeed not genuine, and appears to be a relabeled Rockwell 65C02 (or another non-WDC manufacturer, we only had the Rockwell datasheet to compare with). The CPU itself seems to be ok, but the (subtle) pinout differences make it impossible to use it on our board. Time to order some fresh ones from mouser.com&lt;/p>
&lt;p>To be continued…&lt;/p></content></item><item><title>512k Ought to Be Enough for Anybody</title><link>https://www.steckschwein.de/post/512k-ought-to-be-enough-for-anybody/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/512k-ought-to-be-enough-for-anybody/</guid><description>The biggest limitation of any 8 bit CPU such as our beloved 65C02 is the amount of memory that the CPU can address. With 16 address lines, the addressable memory is maxed out at 64k. All ROM and RAM has to be crammed into there. With the 6502 being a memory mapped architecture, IO devices need their addresses there, too.
In order to expand the amount of usable memory, some trickery is necessary.</description><content>&lt;p>The biggest limitation of any 8 bit CPU such as our beloved 65C02 is the amount of memory that the CPU can address. With 16 address lines, the addressable memory is maxed out at 64k. All ROM and RAM has to be crammed into there. With the 6502 being a memory mapped architecture, IO devices need their addresses there, too.&lt;/p>
&lt;p>In order to expand the amount of usable memory, some trickery is necessary. For example, the developers of the C64 came up with a rather clever hack to cram 20k of ROM and full 64k of RAM and IO area into 64k address space by introducing a register that enables the programmer to switch off the ROM, giving access to the underlying RAM. When the ROM is enabled, writes to the addresses go into the RAM below.
We decided to mimic this behaviour in our current implementation of the Steckschwein glue logic.&lt;/p>
&lt;p>But it’s time to move on. More sophisticated 8bit machines such as the C128 or the CPC6128 have a more clever banking logic to give the CPU more than 64k to work with. The C128 even has a MMU. The next logical step for the Steckschwein is to have a MMU, too.
We decided to reimplement our glue logic from scratch using a CPLD and expand our memory space in the process.&lt;/p>
&lt;p>We decided to go for 512k RAM. In order to address that much memory, the first thing we need to add are three more address lines. That’s where the CPLD comes in. In order to cut the 512k ram into smaller banks, so we can easier address them, the CPLD does not only provide the address lines A16 – A18, but also doubles the address lines A14-A15. Address lines A0-A15 from the CPU go to the CPLD to be decoded. RAM and ROM only see A0-A13 from the CPU and A14-A18 from the CPLD.
This way we can split the 512k into 32 banks of 16k each. The 64k address space of the Steckschwein is now organized as four “slots” with 16k each.
Four registers in the CPLD, which are mapped into the IO area contain the values for the extra address lines and are used as selectors for which bank is mapped into which slot. Bit 7 will select ROM instead of RAM, so that ROM banks are being handled just like another memory page. Also, this means a departure from our 8k ROM bank size.
We might upgrade the 32k 28C256 EEPROM to a 512k Flash EEPROM in one of the next iterations, giving us 32 RAM and 32 ROM banks. Also, adding another address line is not a big deal, so upgrading to 1MB will be easy.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Slot&lt;/th>
&lt;th style="text-align:center">Start&lt;/th>
&lt;th style="text-align:center">End&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">$0000&lt;/td>
&lt;td style="text-align:center">$3fff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">$4000&lt;/td>
&lt;td style="text-align:center">$7fff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">2&lt;/td>
&lt;td style="text-align:center">$8000&lt;/td>
&lt;td style="text-align:center">$bfff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">3&lt;/td>
&lt;td style="text-align:center">$c000&lt;/td>
&lt;td style="text-align:center">$ffff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">The 4 Slots within the 64k address space&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;pre tabindex="0">&lt;code>+--------+--------+--------+--------+
|Slot 0 |Slot 1 |Slot 2 |Slot3 |
+--------+--------+--------+--------+
|Bank 81*| | | |
+--------+--------+--------+--------+
|Bank 80*|
+--------+--------+--------+--------+
| .... |Bank 81 |
+--------+--------+--------+--------+
|Bank 4 | ... | | |
+--------+--------+--------+--------+
|Bank 3 |Bank 3 |Bank 81*| |
+--------+--------+--------+--------+
|Bank 1 |Bank 2 |Bank 80*| |
+--------+--------+--------+--------+
|Bank 0 |Bank 1 |Bank 30 |Bank 81*| &amp;lt;- You are here!
+--------+--------+--------+--------+
| |Bank 0 |Bank 29 |Bank 80*|
+--------+--------+--------+--------+
| | |Bank 28 |Bank 30 |
+--------+--------+--------+--------+
| | |Bank 27 |Bank 29 |
+--------+--------+--------+--------+
| | |Bank 26 |Bank 28 |
+--------+--------+--------+--------+
| | |Bank 25 |Bank 27 |
+--------+--------+--------+--------+
| | | .... |Bank 26 |
+--------+--------+--------+--------+
| | |Bank 0 |Bank 25 |
+--------+--------+--------+--------+
| | | | .... |
+--------+--------+--------+--------+
| | | |Bank 0 |
+--------+--------+--------+--------+
*=ROM
&lt;/code>&lt;/pre>&lt;p>The above illustration shows how the Slot selection scheme works. It is also possible to map the same bank into all four slots.&lt;/p>
&lt;p>In order to be able to execute the RESET Vector the CPU requires ROM being present in Slot 3 at system start time. So the default bank assignment looks like this:&lt;/p>
&lt;p>Slot 0 Bank 0
Slot 1 Bank 1
Slot 2 Bank 2
Slot 3 Bank 80
Default bank assignment at boot&lt;/p>
&lt;p>We do not need the ROMOFF mechanism anymore, so the loading of steckOS will follow a different procedure:&lt;/p>
&lt;pre>&lt;code>System bootup with bank $80 (ROM) in slot 3
Bootloader switches slot 2 to bank 3 (or whatever bank the OS shall be in)
Bootloader writes steckOS to slot 2 ($8000)
Bootloader switches slot 3 to bank 3
Bootloader jumps to steckOS init
&lt;/code>&lt;/pre>
&lt;p>This memory banking scheme is rather simple, but provides a lot of flexibility in order to use more than 64k of memory. Also, all kinds of memory (ROM, RAM) are being treated the same way, so it’s much cleaner than the ROMOFF approach. Being able to remap the area containing the zero page and stack will also help implementing some sort of task switching or even multitasking.
On the downside, it’s flexible but pretty dumb as the software has to keep track of what has been put in which bank.
We a really eager to explore this idea, so the VHDL code for the XC9572 CPLD has been written, the board has been designed and waiting to be delivered.&lt;/p></content></item><item><title>Loading ASCII sources in EhBasic</title><link>https://www.steckschwein.de/post/ascii_ehbasic/</link><pubDate>Thu, 23 Sep 2021 15:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/ascii_ehbasic/</guid><description>Since our implementation of FAT32 now supports reading a file byte for byte, a little rework of the file handling in our version of EhBasic is in order.
In the past, we only could read or write a file as a whole, relative to the location in memory where the according pointer pointed to. We used this in EhBasic to save and load BASIC programs by dumping and reloading it’s binary representation from memory.</description><content>&lt;p>Since our implementation of FAT32 now supports reading a file byte for byte, a little rework of the file handling in our version of EhBasic is in order.&lt;/p>
&lt;p>In the past, we only could read or write a file as a whole, relative to the location in memory where the according pointer pointed to. We used this in EhBasic to save and load BASIC programs by dumping and reloading it’s binary representation from memory. While this works well, this approach has the major disadvantage that the saved program will be incompatible with other versions of EhBasic or even with our own when the token list is changed, which happens when adding new commands.&lt;/p>
&lt;p>So clearly, the better approach is to read the BASIC program as source in it’s ASCII representation. This is the way EhBasic’s late creator, Lee Davison, preferred, and suggested how to implement this:&lt;/p>
&lt;pre>&lt;code>To load an ASCII program redirect the character input vector to read
from your filesystem and return to the main interpreter loop.
The input vector should be restored and the file closed when the
file end is reached or an error is encountered.
&lt;/code>&lt;/pre>
&lt;p>Basically the interpreter would read characters and interpret them, just like them being typed in, but instead they will be read from the file. So, our LOAD command is implemented like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>LAB_LOAD:
lda #O_RDONLY
jsr openfile
lda #&amp;lt;fread_wrapper
sta VEC_IN
lda #&amp;gt;fread_wrapper
sta VEC_IN+1
lda #&amp;lt;outvec_dummy
sta VEC_OUT
lda #&amp;gt;outvec_dummy
sta VEC_OUT+1
JMP LAB_1319 ; reset and return
&lt;/code>&lt;/pre>&lt;p>All it does is changing the in and output vectors and then returning back to the interpreter, which then begins to read characters from VEC_IN until the file is read. But then what? The input vector still points to fread_wrapper, how do we get control back?
That’s the reason we did not point the vector directly to fat_fread_byte. Instead, we implemented a wrapper, which will read a byte from the file and pass it to EhBasic, and restore the vectors when EOF is reached:&lt;/p>
&lt;pre tabindex="0">&lt;code>fread_wrapper:
phx
phy
ldx _fd
jsr krn_fread_byte
bcs @eof
cmp #KEY_LF ; replace with &amp;#34;basic end of line&amp;#34;
bne :+
lda #KEY_CR
: ply
plx
cmp #0
rts
@eof:
jsr krn_close
jsr init_iovectors
SMB7 OPXMDM ; set upper bit in flag (print Ready msg)
jmp LAB_1319 ; cleanup and Return to BASIC
init_iovectors:
lda #&amp;lt;krn_chrout
sta VEC_OUT
lda #&amp;gt;krn_chrout
sta VEC_OUT+1
lda #&amp;lt;krn_getkey
sta VEC_IN
lda #&amp;gt;krn_getkey
sta VEC_IN+1
rts
&lt;/code>&lt;/pre>&lt;p>Also, outvec dummy ist just an empty subroutine which we set the output vector VEC_OUT to, in order to suppress output while loading. Otherwise, the input would be echoed by the interpreter loop, resulting in the program being listed during load.&lt;/p>
&lt;pre tabindex="0">&lt;code>outvec_dummy:
rts
&lt;/code>&lt;/pre>&lt;p>Now we’re ready to feed almost any BASIC source to EhBasic, which will make porting existing BASIC software pretty easy.&lt;/p>
&lt;p>&lt;img src="images/basic_load.png" alt="ASCII based LOAD in action" title="ASCII based LOAD in action">&lt;/p>
&lt;p>The next step will be to save BASIC programs in ASCII format by setting VEC_OUT accordingly and triggering a LIST command.&lt;/p></content></item><item><title>Fixing PS/2 Keyboard handling (Part I)</title><link>https://www.steckschwein.de/post/fixing-ps-2-keyboard-handling-part-i/</link><pubDate>Sat, 14 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/fixing-ps-2-keyboard-handling-part-i/</guid><description>The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:
The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI. The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&amp;rsquo;t the states of the keyboard LEDs.</description><content>&lt;p>The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:&lt;/p>
&lt;ul>
&lt;li>The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI.&lt;/li>
&lt;li>The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&amp;rsquo;t the states of the keyboard LEDs.&lt;/li>
&lt;/ul>
&lt;p>Although mid- to long term, we likely might &amp;ldquo;upgrade&amp;rdquo; to USB anyway, but not without having done PS/2 right first. So, I will talk about integrating IRQ handling, and in a follow up post Marko will talk about how he got the PS/2 controller talking to the keyboard.&lt;/p>
&lt;p>Luckily, during the design of the IO-board, we have been clever enough to hook IO-pins PC0 to PC2 to RESET_TRIG, NMI and IRQ, respectively. So on the hardware-side, we are very much ready.&lt;br>
First problem to solve is how to emulate an open collector output on the AVR controller. As it seems, a common way to do that is to disable the internal pullup of the pin, and have it configured as input to be &amp;ldquo;tri state&amp;rdquo;. When active, the pin gets activated as an output, and will pull the IRQ line low.&lt;/p>
&lt;p>&lt;code>// pull IRQ line DDRC |= (1 &amp;lt;&amp;lt; IRQ);&lt;/code>&lt;/p>
&lt;p>&lt;code>// release IRQ line DDRC &amp;amp;= ~(1 &amp;lt;&amp;lt; IRQ);&lt;/code>&lt;/p>
&lt;p>Now that we know how to handle the IRQ-line, we need to figure out, WHEN to pull it. Obviously when a key was hit. And when to release it?&lt;/p>
&lt;p>Finally, we decided to go the most simple way. The PS/2 controller will pull the IRQ line as long as there are more than 0 chars in the buffer. Once the buffer is empty, the IRQ-line will be released. This way, we do not need an interrupt register and hence no time consuming check of the latter, but need to do a little buffering on the steckOS-side.&lt;/p>
&lt;p>This is all the code that&amp;rsquo;s needed on the PS/2 controller side:&lt;/p>
&lt;pre tabindex="0">&lt;code> if (kb_buffcnt &amp;gt; 0)
{
DDRC |= (1 &amp;lt;&amp;lt; IRQ); // pull IRQ line
}
else
{
DDRC &amp;amp;= ~(1 &amp;lt;&amp;lt; IRQ); // release IRQ line
}
&lt;/code>&lt;/pre>&lt;p>Now, we need to add a little handling code to the steckOS IRQ-handler. Since we do not have an interrupt register, we just check the keyboard last, after every &amp;ldquo;known&amp;rdquo; interrupt source has been handled.&lt;br>
To get around having to implement another keyboard buffer, we just use a single memory location, labelled &amp;ldquo;key&amp;rdquo;. The IRQ handler will only fetch a byte from the keyboard when the target location is zero (0), otherwise it will just exit.&lt;br>
The system getkey-routine will load the contents from that location into the A register, and overwrite the location with 0 again to enable fetching the next char from the buffer.&lt;/p>
&lt;p>The SPI check code is the last bit in the IRQ-handler routine:&lt;/p>
&lt;pre tabindex="0">&lt;code>@check_spi:
lda key
bne @exit
jsr fetchkey
bcc @exit
sta key
@exit:
restore
rti
&lt;/code>&lt;/pre>&lt;p>That&amp;rsquo;s basically all that&amp;rsquo;s needed. The former getkey-routine has been renamed to fetchkey, and the new getkey routine only handles the ZP buffer location while retaining the old behaviour including setting the carry flag when a byte has been received. This way, existing programs using the keyboard do not have to be modified.&lt;/p>
&lt;p>Now, we finally have a chance of reacting to keystrokes during program execution without having to explicitly poll the keyboard. This enables us to handle Ctrl-C and such much more elegantly. Also, any REPL-like program (like the shell) does not have to constantly poll the SPI bus.&lt;/p></content></item><item><title>Connecting SNES Controller to the Steckschwein</title><link>https://www.steckschwein.de/post/connecting-snes-controller-to-the-steckschwein/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/connecting-snes-controller-to-the-steckschwein/</guid><description>Recently, Michael Steil published a blog post about connecting NES and SNES Controller to a 6502-based system showing how to use NES and SNES controllers on a C64 without the need for any special hardware, by just connecting them to the C64&amp;rsquo;s user port.
Why not use his approach and adapt it to the Steckschwein? The Steckschwein has a User Port, too, albeit a very different one as the C64. Basically, the Steckschwein-User-Port consists of the complete Port A of the VIA, plus the /RESET and /IRQ lines.</description><content>&lt;p>Recently, Michael Steil published a &lt;a href="https://www.pagetable.com/?p=1365">blog post about connecting NES and SNES Controller to a 6502-based system&lt;/a> showing how to use NES and SNES controllers on a C64 without the need for any special hardware, by just connecting them to the C64&amp;rsquo;s user port.&lt;/p>
&lt;p>Why not use his approach and adapt it to the Steckschwein? The Steckschwein has a User Port, too, albeit a very different one as the C64. Basically, the Steckschwein-User-Port consists of the complete Port A of the VIA, plus the /RESET and /IRQ lines. Also of course, VCC and GND.&lt;/p>
&lt;pre tabindex="0">&lt;code>User Port:
|---------GND
| |-------PA6
| | |-----PA4
| | | |---PA2 (DATA1)
| | | | |-PA0 (CLK)
o o X o o o o o
o o X o o o o o
| | | | |-PA1 (LATCH)
| | | |---PA3 (DATA2)
| | |-----PA5
| | |-----PA7
|---------VCC
SNES Controller:
/---------------------
| 7 6 5 | 4 3 2 1 |
\\---------------------
Pin Description
1 +5V
2 CLK
3 LATCH
4 DATA
5 –
6 –
7 GND
&lt;/code>&lt;/pre>&lt;p>&lt;img src="images/snes.jpg" alt="snes"> Simple adapter to connect one SNES controller&lt;/p>
&lt;p>As for the code, we use Michael&amp;rsquo;s code with only a few modifications respective to the different pinout, and with a handful of optimizations. Having a 65c02 instead of the 6510 in the C64 gives us the STZ instruction, also using PA0 as clock pin takes just an INC instruction followed by STZ to pulse the clock line.&lt;/p>
&lt;pre tabindex="0">&lt;code>nes_data = via1porta
nes_ddr = via1ddra
; zero page
controller1 = $00 ; 3 bytes
controller2 = $03 ; 3 bytes
bit_clk = %00000001 ; PA0 : CLK (both controllers)
bit_latch = %00000010 ; PA1 : LATCH (both controllers)
bit_data1 = %00000100 ; PA2 : DATA (controller #1)
bit_data2 = %00001000 ; PA3 : DATA (controller #2)
query_controllers:
lda #$ff-bit_data1-bit_data2
sta nes_ddr
lda #$00
sta nes_data
; pulse latch
lda #bit_latch
sta nes_data
;lda #0
;sta nes_data
stz nes_data
; read 3x 8 bits
ldx #0
l2: ldy #8
l1: lda nes_data
cmp #bit_data2
rol controller2,x
and #bit_data1
cmp #bit_data1
rol controller1,x
;lda #bit_clk
;sta nes_data
inc nes_data
;lda #0
;sta nes_data
stz nes_data
dey
bne l1
inx
cpx #3
bne l2
rts
&lt;/code>&lt;/pre>&lt;p>Small test program to output a different character for each button:&lt;/p>
&lt;p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/GgCyrkfQ8-o" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
 &lt;/p>
&lt;p>Also, instead of the original Nintendo SNES controller, I use an &lt;a href="https://www.8bitdo.com/">8bitdo SN30&lt;/a> Bluetooth controller with the SNES receiver. One could say this is the first time a Bluetooth device has been connected to the Steckschwein.&lt;/p>
&lt;p>&lt;img src="images/img_5814.jpg" alt="IMG_5814"> Bluetooth SNES receiver from 8bitdo&lt;/p>
&lt;p>Up next: Patching our games!&lt;/p></content></item><item><title>Chuck Peddle, 1937 - 2019</title><link>https://www.steckschwein.de/post/chuck-peddle-1937-2019/</link><pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/chuck-peddle-1937-2019/</guid><description>Chuck Peddle, the main designer of the 6502, has passed away on Dec. 15th, 2019.
Peddle was one of the engineers that developed the 6800 at Motorola. He later went to MOS in order to implement his vision of an 8bit CPU for way less than $300, which was Motorola&amp;rsquo;s price for the 6800.
This idea of a cheap but powerful CPU materialized as the 6501, and finally the 6502. That very chip, which started the microcomputer revolution, and on which both Marko and myself began to write our first code ever at an early age.</description><content>&lt;p>Chuck Peddle, the main designer of the 6502, has passed away on Dec. 15th, 2019.&lt;/p>
&lt;p>Peddle was one of the engineers that developed the 6800 at Motorola. He later went to MOS in order to implement his vision of an 8bit CPU for way less than $300, which was Motorola&amp;rsquo;s price for the 6800.&lt;/p>
&lt;p>This idea of a cheap but powerful CPU materialized as the 6501, and finally the 6502. That very chip, which started the microcomputer revolution, and on which both Marko and myself began to write our first code ever at an early age. BASIC at first, followed by assembly language later.&lt;/p>
&lt;p>Learning to code assembly on this small and elegant CPU provided the both of us with profound knowledge and experience about the inner workings of a computer. Knowledge which is still valuable in our respective careers in IT, and also of course when working on our pet project, the Steckschwein. Things would have gone quite different without Chuck Peddle&amp;rsquo;s elegant little CPU.&lt;/p>
&lt;p>Thanks, Chuck!&lt;/p></content></item><item><title>Steckschwein emulator</title><link>https://www.steckschwein.de/post/steckschwein-emulator/</link><pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/steckschwein-emulator/</guid><description>Back from the VCFB (Vintage Computer Festival Berlin) 2019 where we had good talks, met interesting people and got new ideas. Especially from Michael Steil who just asked the simple question &amp;ldquo;How you can develop software for the Steckschwein without an emulator?&amp;rdquo;
With the answer in my mind I felt a little annoyed and also &amp;ldquo;triggered&amp;rdquo; at the same time&amp;hellip; However, Michael Steil was nice enough to strip down his Commander X16-Emulator into a barebone 65c02 computer emulator, so all we had to do was to implement our memory map (easy) and borrow a V9958 video chip implementation from blueMSX and implement it into the emulator (hard).</description><content>&lt;p>Back from the VCFB (Vintage Computer Festival Berlin) 2019 where we had good talks, met interesting people and got new ideas. Especially from &lt;a href="https://www.pagetable.com/">Michael Steil&lt;/a> who just asked the simple question &lt;strong>&amp;ldquo;How you can develop software for the Steckschwein without an emulator?&amp;rdquo;&lt;/strong>&lt;/p>
&lt;p>With the answer in my mind I felt a little annoyed and also &amp;ldquo;triggered&amp;rdquo; at the same time&amp;hellip; However, Michael Steil was nice enough to strip down his Commander X16-Emulator into a barebone 65c02 computer emulator, so all we had to do was to implement our memory map (easy) and borrow a V9958 video chip implementation from blueMSX and implement it into the emulator (hard).&lt;/p>
&lt;p>We&amp;rsquo;ll guide you through the adaption of the emulator step by step. Let&amp;rsquo;s start with the &amp;ldquo;easy&amp;rdquo; part, the&amp;hellip;&lt;/p>
&lt;h3 id="memory-mapping">Memory Mapping&lt;/h3>
&lt;p>is done in a dedicated file &lt;a href="https://github.com/twoinke/steckschwein-emulator/blob/master/memory.c">memory.c&lt;/a> where we simply do the dispatching to a dedicated hardware emulation upon a given address. Luckily the Steckschwein i/o is located in a dedicated and continuous address range within $0200-$0280.&lt;/p>
&lt;p>So if the CPU accesses these address range e.g. asking for a byte from such an address via&lt;/p>
&lt;p>&lt;code>LDA $0220&lt;/code>&lt;/p>
&lt;p>the emulator dispatches the memory read to the corresponding i/o implementation. this  is done with a simple ordered &amp;ldquo;if-cascade&amp;rdquo; as follows&lt;/p>
&lt;pre tabindex="0">&lt;code>uint8_t
real_read6502(uint16_t address, bool debugOn, uint8_t bank)
{
if (address &amp;lt; 0x0200)
{ // RAM
return RAM[address];
}
else if (address &amp;lt; 0x0280) { // I/O
// TODO I/O map?
if (address &amp;lt; 0x210) // UART at $0200
{
return uart_read(address &amp;amp; 0xf);
}
else if (address &amp;lt; 0x0220) // VIA at $0210
{
return via1_read(address &amp;amp; 0xf);
}
else if (address &amp;lt; 0x0230) // VDP at $0220
{
return ioPortRead(NULL,address);
}
&lt;/code>&lt;/pre>&lt;p>The LDA shown above will end up in the line with&lt;/p>
&lt;p>&lt;code>return ioPortRead(NULL,address);&lt;/code>&lt;/p>
&lt;p>and thus our VDP implementation is asked for a byte to read.&lt;/p>
&lt;p>All other addresses are either RAM or ROM depending on the value within our memory control port $0230. For more details check out the &lt;a href="http://steckschwein.de/hardware/cpuramdecoder/">memory map&lt;/a>.&lt;/p>
&lt;h3 id="via-and-sdcard">VIA and SDCard&lt;/h3>
&lt;p>The X16 and the Steckschwein share a few similar approaches, for example in terms of mass storage and/or peripheral communication. Both use the VIA to implement the SPI bus protocol via &amp;ldquo;bit banging&amp;rdquo; to communicate with various components, such as the SD card or the RTC. This part of the emulator almost completely derived from the X16 emulator, with only small modifications.&lt;/p>
&lt;h3 id="emulating-the-v9958">Emulating the V9958&lt;/h3>
&lt;p>The video part was much more difficult, because Steckschwein uses the &lt;a href="http://steckschwein.de/hardware/v9958-video-board/">V9958&lt;/a>. Emulating that kind of video chip is much much work todo and requires a very good understanding what&amp;rsquo;s really going on within the chip at every µs when the screen is drawn.&lt;/p>
&lt;p>Fortunately the MSX and MSX2 systems are very good documented and there are plenty of emulators with source available. As this sounds good the outcome of our investigation was quite sober. Only the fMSX and the blueMSX emulators gave us an idea how we can use or reuse the code of the VDP implementation.&lt;/p>
&lt;p>Although the &lt;a href="http://www.bluemsx.com/">blueMSX&lt;/a> code is not maintained anymore we decided to give&amp;rsquo;em a try. This is because the blueMSX implementation is build more like a kind of emulator framework which can be used to build emulators for a wide range of hardware and not only for MSX systems.&lt;/p>
&lt;p>For short, the following changes where made to get the emulator with the VDP work&lt;/p>
&lt;ol>
&lt;li>strip out unnecessary code and extract the raw VDP V9558 implementation&lt;/li>
&lt;li>create a blueMSX board implementation for Steckschwein&lt;/li>
&lt;li>adapt the fake6502.c code to the blueMSX API with the appropriate cpu callbacks&lt;/li>
&lt;li>glue code to dispatch the i/o access of addresses $220-$224 to the blueMSX VDP code&lt;/li>
&lt;li>get cyclic exact timings required for video by using the blueMSX timer loop&lt;/li>
&lt;/ol>
&lt;p>And here we are&amp;hellip; the emulator is able to boot our bios, which in turn mounts the sdcard and loads the kernel just like the real Steckschwein does.&lt;/p>
&lt;p>&lt;img src="images/steckschwein_emulator_vdp-1.jpg" alt="steckschwein_emulator_vdp">&lt;/p>
&lt;p>On the screenshot you may have noticed the &amp;ldquo;date&amp;rdquo; tool, which actually gives the correct datetime. Hence the rtc emulation is also done already.&lt;/p>
&lt;p>to be continued&amp;hellip;&lt;/p>
&lt;p>code: &lt;a href="https://github.com/Steckschwein/steckschwein-emulator">https://github.com/Steckschwein/steckschwein-emulator&lt;/a>&lt;/p></content></item><item><title>Markos Pacman Talk at VCFb</title><link>https://www.steckschwein.de/post/markos-pacman-talk-at-vcfb/</link><pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/markos-pacman-talk-at-vcfb/</guid><description>Marko talked about his Pacman port to the Steckschwein at VCFb. Basically it&amp;rsquo;s the same talk he did at VCFe in April, but this time, there&amp;rsquo;s a video. Enjoy!
https://media.ccc.de/v/vcfb19_-_111_-_de_-_201910121615_-_pac-man_auf_dem_steckschwein_-_marko_lauke</description><content>&lt;p>Marko talked about his Pacman port to the Steckschwein at VCFb. Basically it&amp;rsquo;s the same talk he did at VCFe in April, but this time, there&amp;rsquo;s a video. Enjoy!&lt;/p>
&lt;p>&lt;a href="https://media.ccc.de/v/vcfb19_-_111_-_de_-_201910121615_-_pac-man_auf_dem_steckschwein_-_marko_lauke">https://media.ccc.de/v/vcfb19_-_111_-_de_-_201910121615_-_pac-man_auf_dem_steckschwein_-_marko_lauke&lt;/a>&lt;/p></content></item><item><title>Weird bug in SD card code</title><link>https://www.steckschwein.de/post/weird-bug-in-sd-card-code/</link><pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/weird-bug-in-sd-card-code/</guid><description>Frank van den Hoef, who is adapting the Steckschwein SPI &amp;amp; FAT32 code for his tiny65 machine made me aware of a classic mistake for a 6502 assembly coder to make. Namely in our sdcard driver, when waiting for the &amp;ldquo;proper&amp;rdquo; response from the card (which should have bit 7 cleared). The routine handling this looked like this:
1 sd_cmd_response_wait: 2 ldy #sd_cmd_response_retries 3 @l: dey 4 beq sd_block_cmd_timeout ; y already 0?</description><content>&lt;p>Frank van den Hoef, who is adapting the Steckschwein SPI &amp;amp; FAT32 code for his tiny65 machine made me aware of a classic mistake for a 6502 assembly coder to make. Namely in our sdcard driver, when waiting for the &amp;ldquo;proper&amp;rdquo; response from the card (which should have bit 7 cleared). The routine handling this looked like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>1 sd_cmd_response_wait:
2 ldy #sd_cmd_response_retries
3 @l: dey
4 beq sd_block_cmd_timeout ; y already 0? then invalid response or timeout
5 jsr spi_r_byte
6 bit #80 ; bit 7 clear
7 bne @l ; no, next byte
8 cmp #$00 ; got cmd response, check if $00 to set z flag accordingly
9 rts
10 sd_block_cmd_timeout:
11 debug &amp;#34;sd_block_cmd_timeout&amp;#34;
12 lda #$1f ; make up error code distinct from possible sd card responses to mark timeout
13 rts
&lt;/code>&lt;/pre>&lt;p>Classic. Obviously, line 6 should read:&lt;/p>
&lt;pre tabindex="0">&lt;code> bit #$80 ; bit 7 clear
&lt;/code>&lt;/pre>&lt;p>With that fixed, the sd card init routine now fails, which is odd since we fixed something that was obviously broken.&lt;/p>
&lt;p>&lt;img src="images/sd_fail-e1571229478149.jpg" alt="sd_fail.jpg">&lt;/p>
&lt;p>Ok, now what? Enabling Marko&amp;rsquo;s mighty debugging macros, it becomes apparent that the sd card init fails right after sending CMD0 to the card. This command is the first command of the init sequence and is supposed to put the card into &amp;ldquo;idle mode&amp;rdquo;. Which the card confirms with an answer of $01. Which is what the init code is expecting, and not getting. Instead, we get $3F, which does not make a lot of sense.&lt;/p>
&lt;p>But why did it work before the fix? Assuming that the card did not change it&amp;rsquo;s behaviour at the same time I fixed the code, let&amp;rsquo;s check what actually happened. Before the fix, we were ANDing $3F with 80:&lt;/p>
&lt;p>&lt;code> 00111111 $3f&lt;/code>&lt;br>
&lt;code>01010000 80 (no $, decimal)&lt;/code>&lt;/p>
&lt;p>In this case, the BNE after the BIT #80 would take the branch to @l, causing the next byte being read, until finally the card responds with $01:&lt;/p>
&lt;p>&lt;code> 00000001 $01&lt;/code>&lt;br>
&lt;code>01010000 80 (no $, decimal)&lt;/code>&lt;/p>
&lt;p>Now the BNE does not take the branch, and the routine exits.&lt;/p>
&lt;p>Now, with the fixed code,  ANDing $3F with **$**80, to check if bit 7 is clear, which it is:&lt;/p>
&lt;p>&lt;code> 00111111 $3F&lt;/code>&lt;br>
&lt;code>10000000 $80&lt;/code>&lt;/p>
&lt;p>Alright, exit the loop and return $3f as response of the card. Which isn&amp;rsquo;t $01, so init failed.&lt;/p>
&lt;p>At this point, I have no explanation for the card responding $3F. I assume that the card might be not ready to process commands at this point, so I added code to repeat sending CMD0 until we get $01 or we run out of retries.&lt;/p></content></item><item><title>Forth Benchmarks</title><link>https://www.steckschwein.de/post/forth-benchmarks/</link><pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/forth-benchmarks/</guid><description>The main motivation to get Forth up and running on the Steckschwein was to participate at The Ultimate Benchmark, in order to crush all 8bit competition to dust.
So the plan was to benchmark the Steckschwein live at the VCFe. Unfortunately, Carsten could not be there, so no Forth benchmark competition this year. Recently, Carsten presented his benchmark results using TaliForth2, which led us to run the same benchmarks he did and send the results to Carsten, who was kind enough to include them on his site:</description><content>&lt;p>The main motivation to get Forth up and running on the Steckschwein was to participate at &lt;a href="https://theultimatebenchmark.org/">The Ultimate Benchmark&lt;/a>, in order to crush all 8bit competition to dust.&lt;/p>
&lt;p>So the plan was to benchmark the Steckschwein live at the VCFe. Unfortunately, Carsten could not be there, so no Forth benchmark competition this year. Recently, Carsten presented his benchmark results using TaliForth2, which led us to run the same benchmarks he did and send the results to Carsten, who was kind enough to include them on his site:&lt;/p>
&lt;p>&lt;a href="https://theultimatebenchmark.org/#sec-7">https://theultimatebenchmark.org/#sec-7&lt;/a>&lt;/p></content></item><item><title>NVRAM improvements</title><link>https://www.steckschwein.de/post/nvram-improvements/</link><pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/nvram-improvements/</guid><description>As real computer is not a real computer without a real time clock, the Steckschwein is no exception here. As we know, we use the Maxim DS1306 RTC, which is a very common RTC which comes as DIP IC and has an SPI interface. And of course it supports battery backup in various configurations. And this is where things get interesting.
Apart from timekeeping, the DS1306 also has 96 bytes of battery buffered RAM.</description><content>&lt;p>As real computer is not a real computer without a real time clock, the Steckschwein is no exception here. As &lt;a href="http://steckschwein.de/hardware/via-65c22-as-spi-master/spi-devices/">we know&lt;/a>, we use the Maxim DS1306 RTC, which is a very common RTC which comes as DIP IC and has an SPI interface. And of course it supports battery backup in various configurations. And this is where things get interesting.&lt;/p>
&lt;p>Apart from timekeeping, the DS1306 also has 96 bytes of battery buffered RAM. The ideal place to store system configuration parameters. As of now, the RTC NVRAM contains the name of the file to be read from sdcard at startup, the line parameters for the serial interface (baud rate, data bits, parity, stopbits), and also a version number and a crc7 checksum:&lt;/p>
&lt;p>.struct nvram
version .byte
filename .byte 11
uart_baudrate .byte
uart_lsr .byte
crc7 .byte
.endstruct&lt;/p>
&lt;p>version - The version byte will help tracking changes to the NVRAM data structure so we can maintain backwards compatibility. But for now, it&amp;rsquo;s always $00. filename - The name of the file that will be read from sdcard at system bootup. uart_baudrate - lower byte of the 16 bit divisor of the 16550&amp;rsquo;s baud rate generator. The high byte will always be set to 0, since we do not need baud rates &amp;lt; 600 baud. uart_lsr - contents of the 16550&amp;rsquo;s Line Status Register, to setup the number of data bits, parity, and stop bits. crc7 - crc7 checksum of all the bytes except this last one. If at system startup the crc is not correct, an error message is displayed and fallback defaults are used.&lt;/p>
&lt;p>To manipulate the contents of the NVRAM in a user friendly way, steckOS provides a tool written in C.&lt;/p>
&lt;p>&lt;img src="images/nvram-1.jpg" alt=""> nvram tool&lt;/p>
&lt;p> &lt;/p>
&lt;p>As of now, we only use 15 bytes out of 96, so there are still 81 bytes left for whatever we might come up. Default text mode (40cols/80cols) comes to mind, also text/background colors&amp;hellip;&lt;/p></content></item><item><title>VCFe 20.0 - over and out</title><link>https://www.steckschwein.de/post/vcfe-20-0-over-and-out/</link><pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/vcfe-20-0-over-and-out/</guid><description>VCFe 20.0 is over, all of a sudden, and we had lots of fun as always.
Many thanks to everyone stopping by at our table, especially to those who voted for us at the poll. We got the fo(u)rth place.
Special thanks to Michael Steil, Andre Fachat und Marco Baye for hanging and hacking with us.
Very special thanks to Andre Fachat for his inpromptu 6502 talk right before our turn.</description><content>&lt;p>VCFe 20.0 is over, all of a sudden, and we had lots of fun as always.&lt;/p>
&lt;p>Many thanks to everyone stopping by at our table, especially to those who voted for us at the poll. We got the fo(u)rth place.&lt;/p>
&lt;p>Special thanks to Michael Steil, Andre Fachat und Marco Baye for hanging and hacking with us.&lt;/p>
&lt;p>Very special thanks to Andre Fachat for his inpromptu 6502 talk right before our turn. I think we did prepare a real feast for every 6502 afficionado.&lt;/p></content></item><item><title>Vintage Computer Festival Europe</title><link>https://www.steckschwein.de/post/vintage-computer-festival-europe/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/vintage-computer-festival-europe/</guid><description>Das VCFe steht wieder vor der Tür. Am kommenden Wochenende, also vom 27.4. bis 28.4., findet das Vintage Computer Festival Europe in München statt.
Das diesjährige Motto ist &amp;ldquo;Pixelritter - Programmieren am Limit&amp;rdquo;. Und auch auf dem Steckschwein werden wir Pixel zeigen, teilweise am Limit programmiert.
Veranstaltungsort ist das Kulturzentrum Trudering
Wasserburger Landstrasse 32 81825 München</description><content>&lt;p>Das VCFe steht wieder vor der Tür. Am kommenden Wochenende, also vom 27.4. bis 28.4., findet das &lt;a href="http://www.vcfe.org">Vintage Computer Festival Europe&lt;/a> in München statt.&lt;/p>
&lt;p>Das diesjährige Motto ist &amp;ldquo;Pixelritter - Programmieren am Limit&amp;rdquo;. Und auch auf dem Steckschwein werden wir Pixel zeigen, teilweise am Limit programmiert.&lt;/p>
&lt;p>Veranstaltungsort ist das Kulturzentrum Trudering&lt;/p>
&lt;p>Wasserburger Landstrasse 32 81825 München&lt;/p></content></item><item><title>Make Munich 2019 - It's been our pleasure</title><link>https://www.steckschwein.de/post/make-munich-2019-is-been-our-pleasure/</link><pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/make-munich-2019-is-been-our-pleasure/</guid><description>Make Munich 2019 was awesome. Thanks to everyone who helped making this great event possible.
Again, we are stunned by how much positive feedback we got from so many people. Thank you all!!
Also, like in 2016, our booth was partly turned by a lot of kids into the official Make Munich arcade. So we definitely need to write more games. And build more Steckschweins. Let the children play.</description><content>&lt;p>Make Munich 2019 was awesome. Thanks to everyone who helped making this great event possible.&lt;/p>
&lt;p>Again, we are stunned by how much positive feedback we got from so many people. Thank you all!!&lt;/p>
&lt;p>Also, like in 2016, our booth was partly turned by a lot of kids into the official Make Munich arcade. So we definitely need to write more games. And build more Steckschweins. Let the children play.&lt;/p></content></item><item><title>Meet us at Make Munich, 2.3. - 3.3.2019</title><link>https://www.steckschwein.de/post/meet-us-at-make-munich-2-3-3-3-2019/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/meet-us-at-make-munich-2-3-3-3-2019/</guid><description>Check out our homebrew 65c02 8bit goodness including our brand new video/sound-hardware at the Make Munich fair. We&amp;rsquo;ll also have BASIC, Forth, a couple of games and candy. Our booth is in Hall 1, Booth Nr. 49, in the &amp;ldquo;Electronic Innovators&amp;rdquo;-Area. The did get that right, didn&amp;rsquo;t they?</description><content>&lt;p>Check out our homebrew 65c02 8bit goodness including our &lt;a href="http://steckschwein.de/2018/12/07/new-v9958-board-with-integrated-opl2/">brand new video/sound-hardware&lt;/a> at the Make Munich fair. We&amp;rsquo;ll also have BASIC, Forth, a couple of games and candy. Our booth is in Hall 1, Booth Nr. 49, in the &amp;ldquo;Electronic Innovators&amp;rdquo;-Area. The did get that right, didn&amp;rsquo;t they?&lt;/p></content></item><item><title>Fixing the white screen problem on a Tekway DST1062B oscilloscope</title><link>https://www.steckschwein.de/post/fixing-the-white-screen-problem-on-a-tekway-dst1062b-oscilloscope/</link><pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/fixing-the-white-screen-problem-on-a-tekway-dst1062b-oscilloscope/</guid><description>The Tekway DST 1062B (also known unter the Hantek or Voltcraft brand) is an inexpensive 60MHz digital storage oscilloscope, which is very much hackable and has proven to be worth its weight in gold pressed latinum.
More recently, my scope became affected by the infamous white screen problem, which apparently is a problem quite common to this model and its 100MHz or 200MHz siblings.
The Tekway/Hantek white screen of death</description><content>&lt;p>The Tekway DST 1062B (also known unter the Hantek or Voltcraft brand) is an inexpensive 60MHz digital storage oscilloscope, which is very much hackable and has proven to be worth its weight in gold pressed latinum.&lt;/p>
&lt;p>More recently, my scope became affected by the infamous white screen problem, which apparently is a problem quite common to this model and its 100MHz or 200MHz siblings.&lt;/p>
&lt;p>&lt;img src="images/white_screen.jpg" alt=""> The Tekway/Hantek white screen of death&lt;/p>
&lt;p>The screen just goes white, but the scope otherwise responds to pressing buttons, etc. so it appears not to be completely dead. Some research revealed bad connections inside the scope as a possible culprit: &lt;a href="https://hackcorrelation.blogspot.com/2014/01/dso5062b-white-screen-repair-and-hack.html">https://hackcorrelation.blogspot.com/2014/01/dso5062b-white-screen-repair-and-hack.html&lt;/a> But in my case, that did not do anything. More research brought me to a couple of messages within the famous Tekway hacking thread on the EEVBlog-Forum: &lt;a href="https://www.eevblog.com/forum/testgear/hantek-tekway-dso-hack-get-200mhz-bw-for-free/msg87635/#msg87635">https://www.eevblog.com/forum/testgear/hantek-tekway-dso-hack-get-200mhz-bw-for-free/msg87635/#msg87635&lt;/a>&lt;/p>
&lt;p>Forum member &amp;ldquo;bbf&amp;rdquo; told me during a conversation, that he had replaced the 3.3V regulator, but did not remember exactly, which regulator he used. With this information, I went to examine the power supply. The 3.3V rail is powered by a KA78R33 regulator, which is rated for a maximum current of 1A. I removed it in order to power the 3.3V rail directly from my bench supply.&lt;/p>
&lt;p>&lt;img src="images/photo_2019-02-12_17-33-18.jpg" alt=""> That&amp;rsquo;s a lot of load for the stock 3.3V regulator&lt;/p>
&lt;p>And there we have it. The KA78R33 is under a constant load of almost 1.3A. Also using the bench supply I could play around with the exact voltage and I found out, that the scope is very sensitive about the voltage being correct. A voltage drop down to 3.2V will make the screen go white again. To make things worse, the KA78R33 is completely potted in plastic, which I don&amp;rsquo;t imagine to be the best idea in terms of heat dissipation. So we obviously need a beefier 3.3V regulator. I decided to go for a LM1085 which is rated for 3A, so we have plenty of safety margin. Also, it is almost pin compatible with the KA78R33, if inserted &amp;ldquo;the other way around&amp;rdquo;. Also, the LM1085 does not have GND but Vout on it&amp;rsquo;s housing, so one needs to be careful to not have it touch anything it&amp;rsquo;s not supposed to. So with the new regulator, the scope works like a charm again.&lt;/p>
&lt;p>Originally, the scope was sold as fanless, which was a big selling point for me back then. Inside, there happens to be a place to mount an 50mm 12V fan, also the power supply has a 12V rail just to power a fan. To be on the safe side from now on, I installed a fan. I just replaced the 12V regulator with a 9V one in order to keep fan noise down.&lt;/p>
&lt;p>&lt;img src="images/scope_ok_again.jpg" alt="scope_ok_again">&lt;/p></content></item><item><title>V9958+OPL2-Boards are there</title><link>https://www.steckschwein.de/post/v9958opl2-boards-are-there/</link><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/v9958opl2-boards-are-there/</guid><description>The newly made boards made their way from China to Munich. Starting now, the multi board version of the Steckschwein is made up of 3 Boards: CPU/Memory, IO/UART and V9958-OPL2.</description><content>&lt;p>The newly made boards made their way from China to Munich. Starting now, the multi board version of the Steckschwein is made up of 3 Boards: CPU/Memory, IO/UART and V9958-OPL2.&lt;/p>
&lt;p>&lt;img src="images/board.jpg" alt="">
&lt;img src="images/board_done.jpg" alt="">
&lt;img src="images/board_working.jpg" alt="">&lt;/p></content></item><item><title>New V9958-Board with integrated OPL2</title><link>https://www.steckschwein.de/post/new-v9958-board-with-integrated-opl2/</link><pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/new-v9958-board-with-integrated-opl2/</guid><description>It&amp;rsquo;s time for another hardware upgrade. Since we really want to get our single board Steckschwein done, we are going for higher integration of our multiboard prototype. After integrating the UART to the IO-Board, we integrate the OPL2 sound part onto the V9958 video board, so the current Steckschwein multi board incarnations are reduced to three boards. We did postpone our plan to upgrade sound to OPL3 because Daniel Illgen, which we met at VCFb, convinced us with some awesome OPL2 tunes that OPL2 is still cool.</description><content>&lt;p>It&amp;rsquo;s time for another hardware upgrade. Since we really want to get our single board Steckschwein done, we are going for higher integration of our multiboard prototype. After integrating the UART to the IO-Board, we integrate the OPL2 sound part onto the V9958 video board, so the current Steckschwein multi board incarnations are reduced to three boards. We did postpone our plan to upgrade sound to OPL3 because Daniel Illgen, which we met at VCFb, convinced us with some awesome OPL2 tunes that OPL2 is still cool. Also, we save the extra oscillator, since the OPL2 can be clocked using the CPUCLK-Pin from the V9958, which happens to provide 3.58MHz.&lt;/p>
&lt;p>We did upgrade however the video ram. The first prototype had Bank 0 and Bank 1, maxing out vram at 128k. We decided to include the Extended memory bank, too, this time, giving the V9958 extra 64k, which can be accessed using the blitter command functions. Why not?&lt;/p>
&lt;p>&lt;img src="images/v9958-e1544277948324.png" alt=""> KiCad 3D rendering of the new board&lt;/p>
&lt;p>Also, to make the connector side more compact, we decided to not use RCA jacks for RGB anymore, but an 8pin DIN jack, which also carries the audio signal. So hooking up a 1084 Monitor or TV will only require a single cable. We use the same DIN jack and &lt;a href="https://gamesx.com/avpinouts/neoav.htm">pinout as the NeoGeo&lt;/a> uses, so there are even &lt;a href="https://www.retrogamingcables.co.uk/snk-neo-geo-aes-rgb-scart-cable-stereo-sound">ready made cables available&lt;/a>.&lt;/p></content></item><item><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface</title><link>https://www.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</link><pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</guid><description>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</description><content>&lt;p>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.&lt;/p>
&lt;p>as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings&lt;/p>
&lt;ol>
&lt;li>the first 2 bytes send to vdp during a write are always register writes which require a short delay of at least 2µs in between each byte&lt;/li>
&lt;li>the write of the 3rd byte (after the 2nd) requires a delay of 8µs. any further &amp;ldquo;single byte transfer&amp;rdquo; - during a vram write - also requires the 8µs delay. the same is true if we want to initiate a register write direclty after a vram write.&lt;/li>
&lt;li>the 3rd and n-th byte write to port #3 (index register port) during a bulk register write requires only the 2µs between each byte&lt;/li>
&lt;/ol>
&lt;p>With this in mind, we can optimize our library a little bit by using different &amp;ldquo;nop slides&amp;rdquo; for address setup and vram writes.&lt;/p>
&lt;p>We enhance our vdp.inc and built two macros which provide the different delay we need.&lt;/p>
&lt;pre tabindex="0">&lt;code>.macro vdp_wait_s
jsr vdp_nopslide_2m ; 2m for 2µs wait
...
.macro vdp_wait_l
jsr vdp_nopslide_8m ; 8m for 8µs wait
...
&lt;/code>&lt;/pre>&lt;p>steckSchwein is running at 8Mhz, so we also defined some equations and used ca65 macros to build our nop slides.&lt;/p>
&lt;pre tabindex="0">&lt;code>.define CLOCK_SPEED_MHZ 8
; long delay with 6µ+2µs (below)
MAX_NOPS_8M = (6 * 1000 / (1000 / CLOCK_SPEED_MHZ)) / 2
; 8Mhz, 125ns per cycle, wait 6µs = 6000ns
; = 6000ns / 125ns = 48cl / 2 =&amp;gt; 24 NOP
; short delay with 2µs wait
MAX_NOPS_2M = (2 * 1000 / (1000 / CLOCK_SPEED_MHZ) -12) / 2
; -12 =&amp;gt; jsr/rts = 2 * 6cl = 12cl must be subtract
.macro m_vdp_nopslide
vdp_nopslide_8m:
; long delay with 6+2 2µs wait
.repeat MAX_NOPS_8M
nop
.endrepeat
vdp_nopslide_2m:
.repeat MAX_NOPS_2M
nop
.endrepeat
rts
.endmacro
&lt;/code>&lt;/pre>&lt;p>Another interesting thing would be, &amp;ldquo;how does the /WAIT&amp;rdquo; behave in this situation? the assumption here is, that the /WAIT will behave in the way as specified. so /WAIT will be go low at least after 130ns from CSW. so to handover the /RDY handling to the vdp via the /WAIT pin, we have to apply only 1 wait state from our WS-Gen. after one wait state, we can release the /RDY low from our WS so that the vdp /WAIT can drive /RDY as needed.&lt;/p>
&lt;p>Back home, Thomas did the test and changed the waitstate generator firmware for the GAL16V8.&lt;/p>
&lt;p>The equation was&lt;/p>
&lt;pre tabindex="0">&lt;code>W2 = ROM \* UART \* SND \* /VDP
W1 = W2
+ /ROM \* UART \* VDP
&lt;/code>&lt;/pre>&lt;p>and was changed to&lt;/p>
&lt;pre tabindex="0">&lt;code>W2 = /SND
W1 = W2
+ /ROM ; /ROM wait state if ROM is cs
+ /VDP ; /VDP wait state if VDP is cs
&lt;/code>&lt;/pre>&lt;p>So finally, we only need one wait state from the waitstate generator to access the VDP. If the VDP requires more time - surely - during a video memory access it will drive /WAIT to low as long as needed. So after the explcit 1WS from our wait state generator we now hand over the /RDY control to the VDP. How our /RDY and /WAIT really work together is subject to one of our next sessions where we&amp;rsquo;re going to measure the things with a logic analyzer and oscilloscope. Nevertheless, it works in this way and it works exaclty as specified within the datasheet.&lt;/p></content></item><item><title>VCFB 2018 It was great...</title><link>https://www.steckschwein.de/post/vcfb-2018-its-great/</link><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/vcfb-2018-its-great/</guid><description>VCF 2018 in Berlin was great! We&amp;rsquo;ve met interesting people there. Got a handshake with Scot W. Stevenson who for(th)ced us to use his TaliForth2 ;)
Later on Saturday Daniel Illgen - maintainer of the Adlib Tracker II for Linux - had decided to honor us with his OPL2 knowledge while on the way out. He advised us to keep the OPL2 sound chip on the Steckschwein, because the OPL2 chip is still not outbid.</description><content>&lt;p>VCF 2018 in Berlin was great! We&amp;rsquo;ve met interesting people there. Got a handshake with Scot W. Stevenson who for(th)ced us to use his &lt;a href="https://github.com/scotws/TaliForth2">TaliForth2&lt;/a> ;)&lt;/p>
&lt;p>Later on Saturday &lt;a href="http://www.adlibtracker.net/downloads.php">Daniel Illgen&lt;/a> - maintainer of the Adlib Tracker II for Linux - had decided to honor us with his OPL2 knowledge while on the way out. He advised us to keep the OPL2 sound chip on the Steckschwein, because the OPL2 chip is still not outbid. We hat doubts at first, but then we could listen to OPL2 with so called &amp;ldquo;software low frequency oscillation&amp;rdquo; (soft lfo) and the drums and bass sounds great!&lt;/p>
&lt;p>Beside the VCF there where talks about demos and the history of the demoscene then and now. There where two interesting and awesome talks given by &amp;ldquo;&lt;a href="http://svolli.de/">SvOlli&lt;/a>&amp;rdquo; about the demoscene and demo coding on the Atari VCS (Stella).&lt;/p>
&lt;p>Here are the slides of out talks and Links to the livestream from Saturday 13.10.2018.&lt;/p>
&lt;ul>
&lt;li>Steckschwein - &lt;a href="https://steckschwein.files.wordpress.com/2018/10/the-history.pdf">The history and why it&amp;rsquo;s called &amp;ldquo;Steckschwin&amp;rdquo;&lt;/a>&lt;/li>
&lt;li>Steckschwein - &lt;a href="https://steckschwein.files.wordpress.com/2018/10/asm_tests_ci.pdf">6502 Test Driven Development and Continuous Integration&lt;/a>&lt;/li>
&lt;li>Livestream: &lt;a href="https://media.ccc.de/c/vcfb18">https://vcfb.de/2018/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Many thanks to &lt;a href="http://www.stefan-hoeltgen.de/">Dr. Stefan Höltgen&lt;/a> and his team arround the VCFB which made it possible that we could take a part on that cool event!&lt;/p></content></item><item><title>Save the date: VCFb - 13.10.-14.10.</title><link>https://www.steckschwein.de/post/save-the-date-vcfb-13-10-14-10/</link><pubDate>Mon, 01 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/save-the-date-vcfb-13-10-14-10/</guid><description>We are very excited that we will be exhibiting the Steckschwein at the Vintage Computing Festival Berlin . Also, we will be holding a talk about everything Steckschwein on Saturday, the 13.10. at 10:30.
The Vintage Computing Festival Berlin will again be taking place at the &amp;ldquo;Deutsches Technikmuseum Berlin&amp;rdquo;, the German technical museum, which is a very interesting place to go by itself.
This is going to be good.</description><content>&lt;p>We are very excited that we will be exhibiting the Steckschwein at the &lt;a href="http://vcfb.de/2018/">Vintage Computing Festival Berlin&lt;/a> . Also, we will be holding a talk about everything Steckschwein on Saturday, the 13.10. at 10:30.&lt;/p>
&lt;p>The Vintage Computing Festival Berlin will again be taking place at the &amp;ldquo;Deutsches Technikmuseum Berlin&amp;rdquo;, the German technical museum, which is a very interesting place to go by itself.&lt;/p>
&lt;p>This is going to be good.&lt;/p></content></item><item><title>WOZMON - a memory monitor in 256 bytes</title><link>https://www.steckschwein.de/post/wozmon-a-memory-monitor-in-256-bytes/</link><pubDate>Sun, 22 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/wozmon-a-memory-monitor-in-256-bytes/</guid><description>The woz monitor, also known as WOZMON, is a pretty simple memory monitor and was the system software located in the 256 byte PROM on the Apple I. Wozmon is used to inspect and modify memory contents or to execute programs already located in memory. Steve Wozniak managed to squeeze all that functionality into 256 bytes. That&amp;rsquo;s right, bytes. Not megabytes, not kilobytes. Bytes.
We already had attempted to get wozmon ported to our Steckschwein, but we did not succeed so far.</description><content>&lt;p>The &lt;a href="https://www.sbprojects.net/projects/apple1/wozmon.php">woz monitor, also known as WOZMON&lt;/a>, is a pretty simple memory monitor and was the system software located in the 256 byte PROM on the Apple I. Wozmon is used to inspect and modify memory contents or to execute programs already located in memory. Steve Wozniak managed to squeeze all that functionality into 256 bytes. That&amp;rsquo;s right, bytes. Not megabytes, not kilobytes. Bytes.&lt;/p>
&lt;p>We already had attempted to get wozmon ported to our Steckschwein, but we did not succeed so far. That might have been because the wozmon-code is a little bit hard to read and makes use of some Apple I specific things, which we did not know they were, since we do not have any expertise about the Apple I.&lt;/p>
&lt;p>Fortunately, we got asked by &lt;a href="http://neil.franklin.ch">Neil Franklin&lt;/a> to proof-read his in-depth &lt;a href="http://neil.franklin.ch/Info_Texts/Apple_1_Hardware_und_Software.html">article about the Apple I and wozmon&lt;/a>, which provided us with the missing background knowledge. So, as a proof of correctness and helpfulness of his article, it was time for a new porting attempt. As it turned out, there had to be 2 bigger changes, one while a char is input, and one while a char is output, and a few smaller but important considerations.&lt;/p>
&lt;p>We started off using &lt;a href="https://github.com/jefftranter/6502/tree/master/asm/wozmon">Jeff Tranter&amp;rsquo;s Version&lt;/a>, because Jeff saved us some grunt work by having adapted the code to ca65 syntax.&lt;/p>
&lt;p>So here is our Version of wozmon adapted to run on top of SteckOS in all it&amp;rsquo;s glory:&lt;/p>
&lt;pre tabindex="0">&lt;code>; The WOZ Monitor for the Apple 1
; Written by Steve Wozniak in 1976
Credit where credit is due!
.include &amp;#34;common.inc&amp;#34;
.include &amp;#34;../kernel/kernel.inc&amp;#34;
.include &amp;#34;../kernel/kernel\_jumptable.inc&amp;#34;
.include &amp;#34;appstart.inc&amp;#34;
appstart $1000
&lt;/code>&lt;/pre>&lt;p>Our Standard SteckOS includes. The appstart macro takes care of creating a commodore style file &amp;ldquo;header&amp;rdquo; with the load address in the first 2 bytes of the file.&lt;/p>
&lt;pre tabindex="0">&lt;code>; Page 0 Variables
XAML = $24 ; Last &amp;#34;opened&amp;#34; location Low
XAMH = $25 ; Last &amp;#34;opened&amp;#34; location High
STL = $26 ; Store address Low
STH = $27 ; Store address High
L = $28 ; Hex value parsing Low
H = $29 ; Hex value parsing High
YSAV = $2A ; Used to see if hex value is given
MODE = $2B ; $00=XAM, $7F=STOR, $AE=BLOCK XAM
&lt;/code>&lt;/pre>&lt;p>Nothing changed here.&lt;/p>
&lt;pre tabindex="0">&lt;code>; Other Variables
IN = $0300 ; Input buffer to $027F
; KBD = $D010 ; PIA.A keyboard input
; KBDCR = $D011 ; PIA.A keyboard control register
; DSP = $D012 ; PIA.B display output register
; DSPCR = $D013 ; PIA.B display control register
; .org $FF00
; .export RESET
&lt;/code>&lt;/pre>&lt;p>We need to put the input buffer from $027F to somewhere else, because $027F collides with our I/O area. $0300 should be fine. We do not use a PIA for i/o, so we can get rid of those labels. Also, the start address is already defined above, and we won&amp;rsquo;t need to export the RESET label.&lt;/p>
&lt;pre tabindex="0">&lt;code>RESET: CLD ; Clear decimal arithmetic mode.
CLI
LDY #$7F ; Mask for DSP data direction register.
; STY DSP ; Set it up.
LDA #$A7 ; KBD and DSP control register mask.
; STA KBDCR ; Enable interrupts, set CA1, CB1, for
; STA DSPCR ; positive edge sense/output mode.
&lt;/code>&lt;/pre>&lt;p>No need to initialize the PIA chip which we don&amp;rsquo;t have, but we still need to initialize the A and Y registers.&lt;/p>
&lt;pre tabindex="0">&lt;code>NOTCR: ; CMP #&amp;#39;_&amp;#39; ; &amp;#34;_&amp;#34;?
CMP #$08 + $80
BEQ BACKSPACE ; Yes.
&lt;/code>&lt;/pre>&lt;p>Backspace is $08 on the Steckschwein, not &amp;ldquo;_&amp;rdquo;.&lt;/p>
&lt;pre tabindex="0">&lt;code> CMP #$9B ; ESC?
BEQ ESCAPE ; Yes.
INY ; Advance text index.
BPL NEXTCHAR ; Auto ESC if &amp;gt; 127.
ESCAPE: LDA #&amp;#39;\&amp;#39; + $80 ; &amp;#34;\&amp;#34;.
JSR ECHO ; Output it.
GETLINE: LDA #$8A ; CR.
JSR ECHO ; Output it.
LDY #$01 ; Initialize text index.
BACKSPACE: DEY ; Back up text index.
BMI GETLINE ; Beyond start of line, reinitialize.
NEXTCHAR:
; LDA KBDCR ; Key ready?
; BPL NEXTCHAR ; Loop until ready.
; LDA KBD ; Load character. B7 should be ‘1’.
keyin
toupper
ORA #$80
&lt;/code>&lt;/pre>&lt;p>Here is our first major code change. Keyboard input is handled using SteckOS means. Then we convert the received character to uppercase, since the Apple I uses uppercase only, hence wozmon does not handle lowercase. Also, and most important, the Apple I keyboard generated ASCII with bit 7 set to &amp;ldquo;1&amp;rdquo;. We need to emulate that. With these modifications, the bulk of the code can remain as is.&lt;/p>
&lt;pre tabindex="0">&lt;code> STA IN,Y ; Add to text buffer.
JSR ECHO ; Display character.
CMP #$8D ; CR?
BNE NOTCR ; No.
LDY #$FF ; Reset text index.
LDA #$00 ; For XAM mode.
TAX ; 0-&amp;gt;X.
SETSTOR: ASL ; Leaves $7B if setting STOR mode.
SETMODE: STA MODE ; $00=XAM $7B=STOR $AE=BLOK XAM
BLSKIP: INY ; Advance text index.
NEXTITEM: LDA IN,Y ; Get character.
CMP #$8D ; CR?
BEQ GETLINE ; Yes, done this line.
CMP #&amp;#39;.&amp;#39; + $80 ; &amp;#34;.&amp;#34;?
BCC BLSKIP ; Skip delimiter.
BEQ SETMODE ; Yes. Set STOR mode.
CMP #&amp;#39;:&amp;#39; + $80 ; &amp;#34;:&amp;#34;?
BEQ SETSTOR ; Yes. Set STOR mode.
CMP #&amp;#39;R&amp;#39; + $80 ; &amp;#34;R&amp;#34;?
BEQ RUN ; Yes. Run user program.
STX L ; $00-&amp;gt; L.
STX H ; and H.
STY YSAV ; Save Y for comparison.
NEXTHEX: LDA IN,Y ; Get character for hex test.
EOR #$B0 ; Map digits to $0-9.
CMP #$0A ; Digit?
BCC DIG ; Yes.
ADC #$88 ; Map letter &amp;#34;A&amp;#34;-&amp;#34;F&amp;#34; to $FA-FF.
CMP #$FA ; Hex letter?
BCC NOTHEX ; No, character not hex.
DIG: ASL
ASL ; Hex digit to MSD of A.
ASL
ASL
LDX #$04 ; Shift count.
HEXSHIFT: ASL ; Hex digit left, MSB to carry.
ROL L ; Rotate into LSD.
ROL H ; Rotate into MSD’s.
DEX ; Done 4 shifts?
BNE HEXSHIFT ; No, loop.
INY ; Advance text index.
BNE NEXTHEX ; Always taken. Check next char for hex.
NOTHEX: CPY YSAV ; Check if L, H empty (no hex digits).
BEQ ESCAPE ; Yes, generate ESC sequence.
BIT MODE ; Test MODE byte.
BVC NOTSTOR ; B6=0 STOR 1 for XAM &amp;amp; BLOCK XAM
LDA L ; LSD’s of hex data.
STA (STL,X) ; Store at current ‘store index’.
INC STL ; Increment store index.
BNE NEXTITEM ; Get next item. (no carry).
INC STH ; Add carry to ‘store index’ high order.
TONEXTITEM: JMP NEXTITEM ; Get next command item.
RUN: JMP (XAML) ; Run at current XAM index.
NOTSTOR: BMI XAMNEXT ; B7=0 for XAM, 1 for BLOCK XAM.
LDX #$02 ; Byte count.
SETADR: LDA L-1,X ; Copy hex data to
STA STL-1,X ; ‘store index’.
STA XAML-1,X ; And to ‘XAM index’.
DEX ; Next of 2 bytes.
BNE SETADR ; Loop unless X=0.
NXTPRNT: BNE PRDATA ; NE means no address to print.
LDA #$8A ; CR.
JSR ECHO ; Output it.
LDA XAMH ; ‘Examine index’ high-order byte.
JSR PRBYTE ; Output it in hex format.
LDA XAML ; Low-order ‘examine index’ byte.
JSR PRBYTE ; Output it in hex format.
LDA #&amp;#39;:&amp;#39; + $80 ; &amp;#34;:&amp;#34;.
JSR ECHO ; Output it.
PRDATA: LDA #$A0 ; Blank.
JSR ECHO ; Output it.
LDA (XAML,X) ; Get data byte at ‘examine index’.
JSR PRBYTE ; Output it in hex format.
XAMNEXT: STX MODE ; 0-&amp;gt;MODE (XAM mode).
LDA XAML
CMP L ; Compare ‘examine index’ to hex data.
LDA XAMH
SBC H
BCS TONEXTITEM ; Not less, so no more data to output.
INC XAML
BNE MOD8CHK ; Increment ‘examine index’.
INC XAMH
MOD8CHK: LDA XAML ; Check low-order ‘examine index’ byte
AND #$07 ; For MOD 8=0
BPL NXTPRNT ; Always taken.
PRBYTE: PHA ; Save A for LSD.
LSR
LSR
LSR ; MSD to LSD position.
LSR
JSR PRHEX ; Output hex digit.
PLA ; Restore A.
PRHEX: AND #$0F ; Mask LSD for hex print.
ORA #&amp;#39;0&amp;#39; + $80 ; Add &amp;#34;0&amp;#34;.
CMP #$BA ; Digit?
BCC ECHO ; Yes, output it.
ADC #$06 ; Add offset for letter.
ECHO:
; BIT DSP ; bit (B7) cleared yet?
; BMI ECHO ; No, wait for display.
; STA DSP ; Output character. Sets DA.
pha
and #$7F
jsr krn\_chrout
pla
RTS ; Return.
&lt;/code>&lt;/pre>&lt;p>Second important change. We got rid of the Apple I specific routine to output characters and use the chrout-routine of the SteckOS-kernel. But in order not to output garbage, we need to unset bit 7. Since all comparisons afterwards still rely on bit 7 being set, we save the A register to the stack and restore it afterwards. A faster way would be to just set bit 7 again by doing a ORA #$80 before the RTS, but what the heck.&lt;/p>
&lt;pre tabindex="0">&lt;code>; BRK ; unused
; BRK ; unused
&lt;/code>&lt;/pre>&lt;p>We don&amp;rsquo;t need those.&lt;/p>
&lt;pre tabindex="0">&lt;code>; Interrupt Vectors
; .WORD $0F00 ; NMI
; .WORD RESET ; RESET
; .WORD $0000 ; BRK/IRQ
&lt;/code>&lt;/pre>&lt;p>We don&amp;rsquo;t need those either since we are not using wozmon as system software. Interrupt handling is still done by the SteckOS kernel.&lt;/p>
&lt;p> &lt;/p>
&lt;p>&lt;img src="images/wozmon.jpg" alt="wozmon"> Tada!&lt;/p></content></item><item><title>VCFe diesmal ohne Steckschwein</title><link>https://www.steckschwein.de/post/vcfe-diesmal-ohne-steckschwein/</link><pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/vcfe-diesmal-ohne-steckschwein/</guid><description>Zum ersten Mal in der Geschichte des Steckschweins sind wir dieses Jahr nicht als Aussteller auf dem VCFe dabei.
Das Kommen lohnt sich aber trotzdem - diesmal findet das VCFe nämlich im Leibniz-Rechenzentrum der Bayerischen Akademie der Wissenschaften in Garching statt.</description><content>&lt;p>Zum ersten Mal in der Geschichte des Steckschweins sind wir dieses Jahr nicht als Aussteller auf dem &lt;a href="http://vcfe.org/D/">VCFe&lt;/a> dabei.&lt;/p>
&lt;p>Das Kommen lohnt sich aber trotzdem - diesmal findet das VCFe nämlich im &lt;a href="https://www.lrz.de/">Leibniz-Rechenzentrum&lt;/a> der Bayerischen Akademie der Wissenschaften in Garching statt.&lt;/p></content></item><item><title>Switching to english</title><link>https://www.steckschwein.de/post/switching-to-english/</link><pubDate>Tue, 20 Mar 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/switching-to-english/</guid><description>There seems to be quite some interest in our little project from outside of germany. Thanks to all who are following what we are doing.
To save you the effort of putting our blatherings through Google Translate or even having to learn german, we decided switch to writing our blog articles in english.
The rest of the site will be translated as we go. The hardware page has already been translated.</description><content>&lt;p>There seems to be quite some interest in our little project from outside of germany. Thanks to all who are following what we are doing.&lt;/p>
&lt;p>To save you the effort of putting our blatherings through Google Translate or even having to learn german, we decided switch to writing our blog articles in english.&lt;/p>
&lt;p>The rest of the site will be translated as we go. &lt;a href="http://steckschwein.de/hardware/">The hardware page&lt;/a> has already been translated.&lt;/p></content></item><item><title>V9958 - Es ist vollbracht</title><link>https://www.steckschwein.de/post/v9958-es-ist-vollbracht/</link><pubDate>Sat, 17 Mar 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/v9958-es-ist-vollbracht/</guid><description>Da ist sie nun, die neuen Videoplatine. Nach einigen Umwegen hat der Packen Boards uns erreicht (die erste Lieferung ist versehentlich in Spanien gelandet, während wir die Platinen des spanischen Bastlers erhalten haben. Inzwischen hat jeder Ersatz erhalten).
Wir haben ja bekanntlich unsere Vorgehensweise geändert, indem wir schneller Platinen anfertigen lassen. Aber zu unserer großen Freude funktionierte die erste Platine nach Bestückung auf Anhieb. Selbstverständlich haben sich aber auch ein paar Patzer eingeschlichen.</description><content>&lt;p>Da ist sie nun, die neuen Videoplatine. Nach einigen Umwegen hat der Packen Boards uns erreicht (die erste Lieferung ist versehentlich in Spanien gelandet, während wir die Platinen des spanischen Bastlers erhalten haben. Inzwischen hat jeder Ersatz erhalten).&lt;/p>
&lt;p>Wir haben ja bekanntlich &lt;a href="http://steckschwein.de/2018/03/01/v9958-vom-steckbrett-zum-prototypen/">unsere Vorgehensweise geändert&lt;/a>, indem wir schneller Platinen anfertigen lassen. Aber zu unserer großen Freude funktionierte die erste Platine nach Bestückung auf Anhieb. Selbstverständlich haben sich aber auch ein paar Patzer eingeschlichen.&lt;/p>
&lt;p>&lt;img src="images/finished_board.jpg" alt="finished_board.jpg"> Die bis auf die Chinch-Buchsen fertig aufgebaute Platine&lt;/p>
&lt;p>Zunächst gabs wohl eine Verwechslung bei den Footprints für die Chinch-Buchsen. Unsere vorhandenen Buchsen passen also nicht, nirgends lassen sich passende Buchsen auftreiben. Wieso hat KiCad Footprints, die zu keinen Komponenten passen? Was nicht passt, wird passend gemacht, also müssen die Buchsen wohl etwas bearbeitet werden.&lt;/p>
&lt;p>&lt;img src="images/cinch_fix-e1520965306532.jpg" alt="cinch_fix.jpg"> Passend gemachte Buchse. Der vordere Pin wurde abgeknipst, und der mittlere Pin etwas nach vorne gebogen.&lt;/p>
&lt;p>Nach erfolgreichem Test hat sich dann ein weiteres Problem offenbart.&lt;/p>
&lt;p>&lt;img src="images/photo_2018-03-17_13-58-35.jpg" alt="photo_2018-03-17_13-58-35"> Irgendwie wirken die Farben vertauscht&lt;/p>
&lt;p>Dadurch, dass der V9958 seine Video-Ausgabepins für die Farbkanäle nicht in der Reihenfolge RGB, sondern GRB angeordnet hat, sind im Schaltplan Rot und Blau verwechselt worden. Glücklicherweise gehen die Farbsignale über Koppelkondensatoren an den CXA2075M, sodass der Fix erstmal darin besteht, C9 und C12 über Kreuz einzulöten.&lt;/p>
&lt;p>&lt;img src="images/fixed_board.jpg" alt="fixed_board"> Das Board mit Cinch-Buchsen und Farb-Fix. Fehlt noch die S-Video-Buchse&lt;/p>
&lt;p>Oh, und es soll nicht unerwähnt bleiben, dass wir uns erstmals getraut haben, mit dem CXA2075M einen SMD-Chip zu verbauen.&lt;/p></content></item><item><title>V9958 - Vom Steckbrett zum Prototypen</title><link>https://www.steckschwein.de/post/v9958-vom-steckbrett-zum-prototypen/</link><pubDate>Thu, 01 Mar 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/v9958-vom-steckbrett-zum-prototypen/</guid><description>Es ist soweit, der erste Prototyp auf Platine von unserem neuen V9958-Videoboard ist fertig layoutet, und die Platinen warten beim Fertiger auf ihren Versand.
Der Steckbrettaufbau vom letzten Post wurde auf 128k erweitert. Dazu ist einfach eine 2. Bank von 2 Stück 64k x 4 DRAMS dazugebaut worden. Damit entspricht der Aufbau unserem Schaltplan, und dieser ist damit getestet.
Unsere Timing-Probleme führen wir auf zu kurze Delays bei Registerzugriffen, ein Softwareproblem also, zurück.</description><content>&lt;p>Es ist soweit, der erste Prototyp auf Platine von unserem neuen V9958-Videoboard ist fertig layoutet, und die Platinen warten beim Fertiger auf ihren Versand.&lt;/p>
&lt;p>Der Steckbrettaufbau vom &lt;a href="http://steckschwein.de/2017/12/09/es-wird-wieder-gesteckt/">letzten Post&lt;/a> wurde auf 128k erweitert. Dazu ist einfach eine 2. Bank von 2 Stück 64k x 4 DRAMS dazugebaut worden. Damit entspricht der Aufbau unserem Schaltplan, und dieser ist damit getestet.&lt;/p>
&lt;p>Unsere Timing-Probleme führen wir auf zu kurze Delays bei Registerzugriffen, ein Softwareproblem also, zurück. Das Businterface als solches ist durchaus sauber, und wir haben es genauso gelassen wie beim TMS9929. Einziger Unterschied ist, dass /CSW und /CSR nicht mehr mit einem 7400 erzeugt werden, sondern mit einem 74139. Damit sparen wir uns später einen IC, wenn wir aus dem Videoboard ein kombiniertes Video- und Soundboard machen, indem wir den OPL2-Chip noch dazupacken. Aber wir greifen vor.&lt;/p>
&lt;p>Das neue V9958-Board markiert auch eine Veränderung in unserer Vorgehensweise. Bislang haben wir Neuerungen immer komplett ausdesigned auf dem Steckbrett aufgebaut, und erst ganz am Schluss Platinen fertigen lassen, haben wir hier bewusst erst nur die Basisversion layoutet und direkt als Platinen fertigen lassen. Die günstigen Preise der diversen Platinenfertiger machens möglich, und wir verbringen weniger Zeit mit nervtötenden, wackligen Steckbrettaufbauten, und können uns auch langwierige und fehlerträchtige Aufbauten auf Lochrasterplatine sparen. Als angenehmen Nebeneffekt haben wir zwingend einen Schaltplan für jeden Schritt erstellt und haben somit alles lückenlos dokumentiert. Wir rechnen mit noch mindestens 2 Revisionen des Boards. Nämlich eine Reduktion der DRAM-Bestückung auf einen einzigen 16bit-Baustein, und zum Schluss Hinzufügen des Soundchips, sodass das Steckschwein in Zukunft nur noch aus 3 Platinen besteht. Jedenfalls bis wir uns dann an den Einplatiner wagen.&lt;/p>
&lt;p>&lt;img src="images/img_3308.jpg" alt="IMG_3308"> Der Steckbrettaufbau mit 128k. Für das Bild im Hintergrund werden trotzdem nur 16k verwendet.&lt;/p>
&lt;p>&lt;img src="images/photo_2018-03-01_18-53-11.jpg" alt="photo_2018-03-01_18-53-11"> 3D-Rendering der neuen Platine&lt;/p></content></item><item><title>Meltdown / Spectre</title><link>https://www.steckschwein.de/post/meltdown-spectre/</link><pubDate>Fri, 05 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/meltdown-spectre/</guid><description>Aufgrund der verwendeten überlegenen Prozessortechnologie ist das Steckschwein nicht von den aktuellen Prozessor-Sicherheitslücken Meltdown bzw. Spectre betroffen.</description><content>&lt;p>Aufgrund der verwendeten überlegenen Prozessortechnologie ist das Steckschwein nicht von den aktuellen Prozessor-Sicherheitslücken Meltdown bzw. Spectre betroffen.&lt;/p></content></item><item><title>Es wird wieder gesteckt</title><link>https://www.steckschwein.de/post/es-wird-wieder-gesteckt/</link><pubDate>Sat, 09 Dec 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/es-wird-wieder-gesteckt/</guid><description>Wir haben uns schon länger ein Upgrade des Videochips des Steckschweins vorgenommen. Der TMS9929 ist ein netter Chip, aber an einem 8MHz-65c02, der dazu noch so coole Hardware-Features hat, fühlt er sich ein bisschen wie die Achillesferse an.
Zum Glück war beim TMS9929 nicht Schluss, denn dieser hat im Laufe der Zeit diverse Nachfolger bekommen, welche von Yamaha hergestellt wurden und in diversen Weiterentwicklungen des MSX-Standards Verwendung fanden.
Der direkte Nachfolger der TMS99xx-Reihe ist der V9938.</description><content>&lt;p>Wir haben uns schon länger ein Upgrade des Videochips des Steckschweins vorgenommen. Der TMS9929 ist ein netter Chip, aber an einem 8MHz-65c02, der dazu noch so coole Hardware-Features hat, fühlt er sich ein bisschen wie die Achillesferse an.&lt;/p>
&lt;p>Zum Glück war beim TMS9929 nicht Schluss, denn dieser hat im Laufe der Zeit diverse Nachfolger bekommen, welche von Yamaha hergestellt wurden und in diversen Weiterentwicklungen des MSX-Standards Verwendung fanden.&lt;/p>
&lt;p>Der direkte Nachfolger der TMS99xx-Reihe ist der &lt;a href="https://en.wikipedia.org/wiki/Yamaha_V9938">V9938&lt;/a>. Dieser kam 1984 raus, also ganze 7 Jahre nachdem der TMS9918/9929 erschienen ist, und hat dementsprechend auch einiges mehr drauf, z.B.:&lt;/p>
&lt;ul>
&lt;li>ein 80x24 Zeichen-Textmodus&lt;/li>
&lt;li>maximale Auflösung von 512 × 212 (16 Farben von 512)&lt;/li>
&lt;li>32 Sprites, davon max. 8 auf einer Rasterzeile&lt;/li>
&lt;li>Hardwarebeschleunigtes Füllen, Linien ziehen, etc.&lt;/li>
&lt;li>Vertikales Scrollregister&lt;/li>
&lt;/ul>
&lt;p>Der Nachfolger des V9938 wiederum ist der &lt;a href="https://en.wikipedia.org/wiki/Yamaha_V9958">V9958&lt;/a> von 1988. Dieser hat gegenüber dem Vorgänger nur einige kleine Verbesserungen erhalten, und zwar unter anderem:&lt;/p>
&lt;ul>
&lt;li>Horizontales Scrollregister&lt;/li>
&lt;li>Hardwarebeschleunigtes Füllen, Linien ziehen, etc. auch in nicht-bitmap-Modi&lt;/li>
&lt;/ul>
&lt;p>Beide Chips können bis zu 192k DRAM adressieren, und zwar max. 128k Video-RAM + 64k Extended RAM. Es werden DRAMs in den Formaten 16Kx1b, 16Kx4b, 64Kx1b und 64Kx4b unterstützt.&lt;/p>
&lt;p>&lt;img src="images/img_3129-e1512817894665.jpg" alt="img_3129.jpg">&lt;/p>
&lt;p>Unser Testaufbau &amp;ldquo;begnügt&amp;rdquo; sich mit 2x 64Kx4b und damit insgesamt 64Kb Video RAM (der TMS9929 kann nur max. 16K). Verglichen mit dem TMS9929 funktioniert das DRAM-Interface des V9958 selbst auf dem Steckbrett so stabil, dass wir auf irgendwelche SRAM-basierten Lösungen verzichten können. Auch der weitere Aufbau ist eher übersichtlich. Da der V9958 direkt RGB liefert, ist keine aufwendige Aufbereitung des Videosignals nötig. Als Ausgangsstufe wird ein Sony CXA2075M eingesetzt, der nebenher auch S-Video und Composite erzeugt. Damit dürfte sich künftig die Zahl der Steckschwein-geeigneten Fernseher/Monitore drastisch erhöhen.&lt;/p>
&lt;p>Jetzt bleiben noch einige Detailfragen des Businterface zu klären. Wie &lt;a href="http://lc64.blogspot.de/2015/04/v9938-with-rgb-output.html">MrFossi1&lt;/a> schon festgestellt hat, lassen sich Datentransfers ins Videoram nicht mehr in hoher Geschwindigkeit durchführen, während der Videochip im Blank ist oder das Display deaktiviert. Beim TMS9929 war das möglich.&lt;/p>
&lt;p>Der V9958 hingegen verfügt allerdings über einen ominösen /WAIT-Pin, dessen Funktion allerdings erst per Software aktiviert werden muss. Das Datenblatt erwähnt die Wait-Funktion nur kurz als Möglichkeit, Zugriffe aufs VRAM zu beschleunigen, schweigt sich dann aber aus. Hier gilt es zu forschen.&lt;/p></content></item><item><title>Neue Hardware - die Platinen sind da</title><link>https://www.steckschwein.de/post/neue-hardware-die-platinen-sind-da/</link><pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/neue-hardware-die-platinen-sind-da/</guid><description>Die neuen IO-Platinen mit integriertem UART sind fertig und haben ihren Weg von China nach München gefunden.
Mit dem neuen Layout hat es nicht nur der UART mit aufs IO-Board geschafft, es sind auch etliche kleinere und größere Verbesserungen eingeflossen:
Die Joystickports wurden komplett neu designed. Die Optokoppler sparen wir uns, stattdessen wählen wir über einen VIA Pin verschiedene Treiber an, die den gewünschten Joystickport mit VIA Port A verbindet. Die Ports lassen sich auch per Software komplett abschalten, damit der User-Port frei verfügbar ist.</description><content>&lt;p>Die neuen IO-Platinen mit integriertem UART sind fertig und haben ihren Weg von China nach München gefunden.&lt;/p>
&lt;p>Mit dem neuen Layout hat es nicht nur der UART mit aufs IO-Board geschafft, es sind auch etliche kleinere und größere Verbesserungen eingeflossen:&lt;/p>
&lt;ul>
&lt;li>Die Joystickports wurden komplett neu designed. Die Optokoppler sparen wir uns, stattdessen wählen wir über einen VIA Pin verschiedene Treiber an, die den gewünschten Joystickport mit VIA Port A verbindet. Die Ports lassen sich auch per Software komplett abschalten, damit der User-Port frei verfügbar ist. Als Schutz für die VIA werden Serienwiderstände verwendet.&lt;/li>
&lt;li>Der SD-Karten-Footprint und der verwendente Slot passen genau zusammen. Das war beim alten Board nicht der Fall. Jetzt sind die Karten- und die Schreibschutzerkennung endlich nutzbar.&lt;/li>
&lt;li>Die Datenpins für die PS/2 Schnittstelle am ATmega8 sind gewandert und liegen jetzt an PD6 und 7. Dadurch sind die RX und TX Pins des USART verfügbar geworden und können nun z.B. für das Debugging des Tastaturcontrollers verwendet werden.&lt;/li>
&lt;li>Zweckmäßigere Plazierung vom SPI-Anschluss des ATmega8 und des freien SPI Ports am Platinenrand. Updates der Tastaturcontrollerfirmware sind nun kein Krampf mehr.&lt;/li>
&lt;li>Der User-Port hat ein besseres Pinout.&lt;/li>
&lt;li>Die neue Platine sieht einfach besser aus.
&lt;img src="images/img_3091.jpg" alt="IMG_3091"> Frisch ausgepackte Platine&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="images/img_3092.jpg" alt="IMG_3092"> Fertig bestückte Platine
&lt;img src="images/img_3093.jpg" alt="IMG_3093"> Die nun obsolet gewordenen Platinen.&lt;/p></content></item><item><title>Mal wieder neue Hardware</title><link>https://www.steckschwein.de/post/mal-wieder-neue-hardware/</link><pubDate>Wed, 22 Nov 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/mal-wieder-neue-hardware/</guid><description>Die Zeit ist reif für ein Hardware-Update, und zwar für die IO-Platine 2.0. Vorgesehen war ja schon länger, den UART dort zu integrieren. Ausserdem war das Joystick&amp;ndash;Interface noch unausgegoren, sodass auch hier etwas Neues entwickelt wurde.
Zum Schutz der VIA-Pins dienen nun keine Optokoppler, sondern simple Serienwiderstände sollen die Ports zumindest vor dem Fall schützen, dass man doch mal die Datenrichtung der Joystick-Pins auf Ausgang schaltet und dann die VIA grillt indem man den Joystick betätigt.</description><content>&lt;p>Die Zeit ist reif für ein Hardware-Update, und zwar für die IO-Platine 2.0. Vorgesehen war ja schon länger, den UART dort zu integrieren. Ausserdem war das Joystick&amp;ndash;Interface noch unausgegoren, sodass auch hier etwas Neues entwickelt wurde.&lt;/p>
&lt;p>Zum Schutz der VIA-Pins dienen nun keine Optokoppler, sondern simple Serienwiderstände sollen die Ports zumindest vor dem Fall schützen, dass man doch mal die Datenrichtung der Joystick-Pins auf Ausgang schaltet und dann die VIA grillt indem man den Joystick betätigt. Die Widerstände begrenzen den Strom auf 1mA. Das muss die VIA abkönnen. Zudem war im vorigen Design der Userport nicht wirklich nutzbar, weil immer noch die Joysticks daran hingen. Jetzt ist es so, dass jeder Joystick über Tri State Buffer an VIA Port A verbunden wird, und zwar grundsätzlich wahlweise. Ausserdem besteht die Möglichkeit, die Joyports komplett abzuschalten. Dies wird mit dem OUT1-Pin des UART bewerkstelligt. Somit läßt sich per Software konfigurieren, ob man Userport oder Joystick benutzen möchte.&lt;/p>
&lt;p>Der User-Port hat ein neues, von &lt;a href="http://neil.franklin.ch/">Neil Franklin&lt;/a> vorgeschlagenes Pinout, in dem nun auch die /RESET und /IRQ-Leitungen vorhanden sind. Auch am Tastaturcontroller hat sich eine Kleinigkeit geändert, die Datenpins für den PS/2 Port sind nach PD6 bzw. PD7 gewandert. Somit sind die RX/TX-Pins des AVR USART wieder frei und bereit für neue Schandtaten. Deswegen haben sie auch eine kleine Pinleiste spendiert bekommen.&lt;/p>
&lt;p>&lt;img src="images/io2_0.png" alt=""> 3D Rendering der neuen IO-Platine&lt;/p></content></item><item><title>Musik</title><link>https://www.steckschwein.de/post/musik/</link><pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/musik/</guid><description>Das Programmieren von Soundchips ist nicht trivial. Das habe ich damals auf dem C64 schon nicht kapiert. Mit dem Yamaha YM3812 oder auch OPL2 hat das Steckschwein einen weit komplexeren Chip als den SID, denn OPL2 kennt gleich ganze 9 Stimmen statt drei, und jede ist über eine Unzahl Parameter konfigurierbar.
Wie funktioniert der YM3812? Wie kriegt man also einen Ton aus diesem Monstrum? Die beste Quelle zum Thema OPL2 ist wohl &amp;ldquo;Programming the AdLib/Sound Blaster FM Music Chips&amp;rdquo; von Jeffrey S.</description><content>&lt;p>Das Programmieren von Soundchips ist nicht trivial. Das habe ich damals auf dem C64 schon nicht kapiert. Mit dem Yamaha YM3812 oder auch OPL2 hat das Steckschwein einen weit komplexeren Chip als den SID, denn OPL2 kennt gleich ganze 9 Stimmen statt drei, und jede ist über eine Unzahl Parameter konfigurierbar.&lt;/p>
&lt;h2 id="wie-funktioniert-der-ym3812">Wie funktioniert der YM3812?&lt;/h2>
&lt;p>Wie kriegt man also einen Ton aus diesem Monstrum? Die beste Quelle zum Thema OPL2 ist wohl &amp;ldquo;&lt;a href="http://www.shipbrook.net/jeff/sb.html">Programming the AdLib/Sound Blaster FM Music Chips&lt;/a>&amp;rdquo; von Jeffrey S. Lee. Zumindest wird einem hier schnell klar, was auf einen zukommt, will man auch nur einen einfachen Ton ausgeben. So hat der OPL2-Chip insgesamt 244 Register, die neben den Stimmen auch die integrierten Timer konfigurieren, und belegt 2 Portadressen. Konkret bedeutet das, dass man in Adresse 1 die Nummer des gewünschen Registers schreibt. Nach 3.3µs liegt an Adresse 2 das gewählte Register zum Beschreiben an. Lesen läßt sich nur das Statusregister. Hat man also das gewählte Register beschrieben, ist der Chip dann 23µs nicht ansprechbar.&lt;/p>
&lt;p>Zunächst müssen wir also dafür sorgen, dass der Soundchip seine Daten mit dem richtigen Timing bekommt. Der Einfachheit halber machen wir das nicht über Timer, sondern mit NOPs. Die Länge der Nopslides zu berechnen, überlassen wir dem Assembler. Um Platz zu sparen, nutzen wir eine Nopslide mit zwei Einsprüngen.&lt;/p>
&lt;p>opl2_data_delay_time = 25000
opl2_reg_delay_time = 5000&lt;/p>
&lt;p>opl2_data_delay = ((opl2_data_delay_time - opl2_reg_delay_time) / (1000/clockspeed)) / 2 -12
opl2_reg_delay = (opl2_reg_delay_time / (1000/clockspeed)) / 2 -12&lt;/p>
&lt;p>Und die entsprechenden Subroutinen. Die je 6 Zyklen für JSR und RTS sind ja oben schon abgezogen:&lt;/p>
&lt;p>opl2_delay_data: ; 23000ns / 0
.repeat opl2_data_delay
nop
.endrepeat&lt;/p>
&lt;p>opl2_delay_register: ; 3300 ns
.repeat opl2_reg_delay
nop
.endrepeat
rts&lt;/p>
&lt;p>Das wäre also geklärt.&lt;/p>
&lt;h2 id="futter-für-den-soundchip">Futter für den Soundchip&lt;/h2>
&lt;p>Nachdem also schonmal klar ist, auf welch umständliche Weise der Chip mit Daten betankt werden will, bleibt nur noch die Frage: Betanken womit? FM-Synthese ist ein zu weites Feld, als dass wir dort jetzt tief einsteigen wollen. Viel naheliegender wäre ein Player für eingängige Musikfiles. Erste &lt;a href="http://steckschwein.de/2015/01/04/das-schwein-kann-singen/">Experimente von Marko mit den von DosBox erzeugten DRO Files&lt;/a> waren schon recht vielversprechend. Leider ist es etwas umständlich, mit DosBox neue Musikstücke zu konvertieren, und auch die Trefferquote für lauffähige Stücke ist nicht besonders hoch. Zudem ist der von uns verwendete Player ein ziemlicher Hack mit per NOP grob hingefummelten Timings. Dieser war ursprünglich mal für ein OPL2-Modul für den C64 geschrieben worden. Was es nicht alles gibt. MIDI-Files wollen wir uns auch noch nicht antun, weil wir hier eine Umsetzung der verwendeten MIDI-Instrumente in OPL2-Parameter hätten bauen müssen. Ideal wäre ein Dateiformat, das die OPL2-Registerwerte bereits enthält.&lt;/p>
&lt;p>Zum Glück hat sich damals id-Software zu Zeiten der Commander Keen-Spiele etwas entsprechendes ausgedacht: Das &lt;a href="http://www.shikadi.net/moddingwiki/IMF_Format">IMF-Format&lt;/a>. Dieses Format wurde für eine Reihe früher id-Software-Spiele und deren Ableger verwendet, von Commander Keen 4-6 über Duke Nukem II bis hin zu Wolfenstein 3D. Dementsprechend groß ist die Anzahl der verfügbaren Musikstücke.&lt;/p>
&lt;p>IMF-Dateien sind äußerst simpel aufgebaut, jede Datei ist im Prinzip eine Abfolge von 4byte-Paketen, die Registernummer, Registerwert und die Dauer der Pause bis zum nächsten Wert enthalten:&lt;/p>
&lt;p>Register (8bit) | Wert (8bit) | Pause (16bit)&lt;/p>
&lt;p>Die &amp;ldquo;Pause&amp;rdquo; ist in &amp;ldquo;Ticks&amp;rdquo; angegeben, welche sich auf die Abspielfrequenz des jeweiligen Stückes bezieht. Diese ist meist entweder 560Hz oder 700Hz. Hier kommt dann ein Timer-Interrupt zum Einsatz, der 560 oder 700mal in der Sekunde ausgeführt wird. Hierzu verwenden wir Timer 1 des 6522 VIA. Der OPL2 Chip hat zwar auch Timer, aber diese basieren auf festen Intervallen von 80µs bzw 320µs, was in unserem Fall nicht so richtig aufgeht.&lt;/p>
&lt;p>Der Plan ist folgender: Das IMF-File wird komplett in den Speicher geladen. Dann positionieren wir einen Zeiger auf den Anfang der im Speicher befindlichen Daten.&lt;/p>
&lt;p>In der Zeropage benutzen wir 2 Bytes als unseren Delay-Zähler. Diesen setzen wir inital auf 0. In der Interrupt-Routine prüfen wir als erstes, ob der Delay-Zähler 0 ist. Wenn nicht, dekrementieren wir ihn und verlassen die Routine wieder. Ist der Zähler 0, setzen wir das Datenbyte aus unseren IMF-Daten in das vorgesehene Register. Dann rücken wir den Datenzeiger um 4 Bytes weiter, setzen den Delay-Zähler neu, und verlassen den Interrupt.&lt;/p>
&lt;p>player_isr:
pha
phy&lt;/p>
&lt;p>bit via1ifr ; Interrupt from VIA?
bpl @isr_end&lt;/p>
&lt;p>bit via1t1cl ; Acknowledge timer interrupt by reading channel low&lt;/p>
&lt;p>; delay counter zero?
lda delayh
clc
adc delayl
beq @l1&lt;/p>
&lt;p>; if no, 16bit decrement and exit routine
dec16 delayh&lt;/p>
&lt;p>bra @isr_end
@l1:&lt;/p>
&lt;p>ldy #$00
lda (imf_ptr),y
sta opl_stat&lt;/p>
&lt;p>iny
lda (imf_ptr),y&lt;/p>
&lt;p>jsr opl2_delay_register&lt;/p>
&lt;p>sta opl_data&lt;/p>
&lt;p>iny
lda (imf_ptr),y
sta delayh&lt;/p>
&lt;p>iny
lda (imf_ptr),y
sta delayl&lt;/p>
&lt;p>; song data end reached? then set state to 80 so loop will terminate
lda imf_ptr_h
cmp imf_end+1
bne @l3
lda imf_ptr
cmp imf_end+0
bne @l3&lt;/p>
&lt;p>lda #$80
sta state&lt;/p>
&lt;p>bra @isr_end
@l3:&lt;/p>
&lt;p>;advance pointer by 4 bytes
clc
lda #$04
adc imf_ptr
sta imf_ptr
bcc @isr_end
inc imf_ptr_h
@isr_end:
; jump to kernel isr
ply
pla
jmp (old_isr)&lt;/p>
&lt;p>&lt;a href="https://bitbucket.org/steckschwein/steckschwein-code/src/074d9f378daeedeb45166a346cafd39907be22c9/imfplayer/?at=default">Der vollständige Player&lt;/a> ist in unserem &lt;a href="https://bitbucket.org/steckschwein/steckschwein-code">Bitbucket-Repository&lt;/a> zu finden. Wir gehen jetzt den Wolfenstein 3D-Soundtrack hören.&lt;/p></content></item><item><title>Logikanalyse II [UPDATE]</title><link>https://www.steckschwein.de/post/logikanalyse-ii/</link><pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/logikanalyse-ii/</guid><description>Inzwischen sind die 74F00 eingetroffen und der 74HCT00 durch einen ebensolchen ersetzt. Das Oszilloskopbild sieht gleich deutlich besser aus:
gelb: /WE, blau: A9
Der Schreibvorgang wird also jetzt zumindest abgeschlossen, bevor sich die Adresse auf dem Adressbus ändert. Das ist schonmal viel sauberer.
Nur leider hat es das Problem nicht gelöst, das Steckschwein läuft mit den &amp;ldquo;richtigen&amp;rdquo; RAMs immer noch instabil, was sich insbesondere bei BASIC-Programmen bemerkbar macht:
Wäre auch zu einfach gewesen.</description><content>&lt;p>Inzwischen sind die 74F00 eingetroffen und der 74HCT00 durch einen ebensolchen ersetzt. Das Oszilloskopbild sieht gleich deutlich besser aus:&lt;/p>
&lt;p>&lt;img src="images/tekway449_3.gif" alt=""> gelb: /WE, blau: A9&lt;/p>
&lt;p>Der Schreibvorgang wird also jetzt zumindest abgeschlossen, bevor sich die Adresse auf dem Adressbus ändert. Das ist schonmal viel sauberer.&lt;/p>
&lt;p>Nur leider hat es das Problem nicht gelöst, das Steckschwein läuft mit den &amp;ldquo;richtigen&amp;rdquo; RAMs immer noch instabil, was sich insbesondere bei BASIC-Programmen bemerkbar macht:&lt;/p>
&lt;p>&lt;img src="images/photo_2017-05-04_19-56-29.jpg" alt="photo_2017-05-04_19-56-29">&lt;/p>
&lt;p>Wäre auch zu einfach gewesen.&lt;/p>
&lt;p>&lt;strong>[UPDATE]&lt;/strong> Ein weiterer Test mit anderen 55ns-SRAMs, nämlich Bausteinen von BSI im TSOP28-Gehäuse auf DIP28-Adaptern, lief problemlos durch. Das BASIC-Programm, mit dem wir testen, lief 2 Tage problemlos durch. Dies ist insofern bemerkenswert, als dass das Steckschwein mit diesen Bausteinen vorher überhaupt nicht lief. Also doch ein Erfolg. Warum die 55ns-Chips von Alliance Memory Probleme machen, müssen wir noch untersuchen.&lt;/p>
&lt;p>&lt;img src="images/photo_2017-05-06_19-57-10.jpg" alt=""> TSOP28-SRAMs auf DIP28 Adapter&lt;/p></content></item><item><title>VCFe 18.0 - ein Resümee</title><link>https://www.steckschwein.de/post/vcfe-18-0-ein-resuemee/</link><pubDate>Tue, 02 May 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/vcfe-18-0-ein-resuemee/</guid><description>Kein VCFe ohne einen resümmierenden Post-VCFe-Post von uns.
Vorweg: Der neue Veranstaltungsort im Kulturzentrum Trudering ist hervorragend. Eine moderne Veranstaltungshalle, mehr Platz als in der alten ESV-Turnhalle, großzügiger Foyerbereich und ein deutlich größerer Vortragsraum. Die Nahrungsversorgung bestreitet im Kulturzentrum Trudering das integrierte indische Restaurant &amp;ldquo;Taj&amp;rdquo;, welches ebenso überzeugen konnte. Alles in allem ein großer Gewinn und allen Anzeichen nach wird das nächste VCFe auch wieder dort stattfinden.
Das Steckschwein auf dem VCFe 18.</description><content>&lt;p>Kein VCFe ohne einen resümmierenden Post-VCFe-Post von uns.&lt;/p>
&lt;p>Vorweg: Der neue Veranstaltungsort im Kulturzentrum Trudering ist hervorragend. Eine moderne Veranstaltungshalle, mehr Platz als in der alten ESV-Turnhalle, großzügiger Foyerbereich und ein deutlich größerer Vortragsraum. Die Nahrungsversorgung bestreitet im Kulturzentrum Trudering das integrierte indische Restaurant &amp;ldquo;Taj&amp;rdquo;, welches ebenso überzeugen konnte. Alles in allem ein großer Gewinn und allen Anzeichen nach wird das nächste VCFe auch wieder dort stattfinden.&lt;/p>
&lt;p>&lt;img src="images/223033882_14372495918269115578.jpg" alt=""> Das Steckschwein auf dem VCFe 18.0&lt;/p>
&lt;p>Auch das Interesse am Steckschwein erstaunt und erfreut immer wieder. Dieses Jahr ging es in erster Linie darum, mit EhBasic ein lauffähiges BASIC auf dem Steckschwein nebst einiger Beispielprogramme aus  &amp;ldquo;101 BASIC Computer Games&amp;rdquo; zu zeigen. Weiterhin haben wir mit Unterstützung von Carsten Strotmann versucht, VolksForth auf dem Steckschwein zum Laufen zu kriegen, um endlich mal am Ultimate Benchmark teilnehmen zu können. Leider hat sich das Steckschwein hier auch als stark Forth-resistent erwiesen, wie das auch schon bei unseren Versuchen mit FIG-Forth der Fall war. Aber wir bleiben dran.&lt;/p>
&lt;p>Die Herren mit den Arcade-Automaten indessen haben merklich gefehlt. Für jüngeres Publikum gab es so nur wenig Daddelmöglichkeiten, weswegen das Steckschwein zeitweilig als Zockmaschine aushelfen durfte.&lt;/p>
&lt;p>Alles in allem ist eine tolle Veranstaltung in einer neuen tollen Halle noch toller geworden und wir freuen uns aufs VCFe 19.0.&lt;/p></content></item><item><title>Logikanalyse</title><link>https://www.steckschwein.de/post/logikanalyse/</link><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/logikanalyse/</guid><description>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.
Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.
Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2.</description><content>&lt;p>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.&lt;/p>
&lt;p>&lt;img src="images/logic_analyzer.jpg" alt=""> Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.&lt;/p>
&lt;p>Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2. Takthälfte für Buszugriffe nutzt. Diese ist nur 62,5ns lang. Von dieser Zeit geht ausserdem noch die Durchlaufzeit der Adressdekodierung und weiterer Glue-Logik ab. Eigens angeschaffte neue SRAMs von Alliance Memory mit 55ns Zugriffszeit sollten also ganz knapp schnell genug sein. Trotzdem treten mit diesen immer wieder merkwürdig zufällige Abstürze auf, die 100ns-Chips laufen dagegen problemlos.&lt;/p>
&lt;p>Also ran an die Maschine. Hierbei zeigte sich auch schon schnell etwas Merkwürdiges:&lt;/p>
&lt;p>&lt;img src="images/we_addr.png" alt=""> Analyse von Adress- und Datenbus sowie Steuersignale&lt;/p>
&lt;p>Es fiel etwas unangenehm auf, dass die steigende Flanke von /WE (Ende des Schreibzugriffs) direkt mit der Änderung des Adressbus zusammenfällt. Idealerweise sollte der Schreibzugriff beendet sein, bevor am Adressbus eine andere Adresse anliegt. Das Datenblatt nennt die Zeitspanne zwischen der steigenden Flanke von /WE und einer Änderung auf dem Adressbus tWR (Write Recovery Time):&lt;/p>
&lt;p>&lt;img src="images/sram_timing.png" alt="sram_timing">&lt;/p>
&lt;p>Laut Diagramm soll also /WE high werden, &lt;strong>bevor&lt;/strong> sich der Adressbus ändert. Im Datenblatt selbst ist die Write Recovery Time mit 0ns angegeben, und zwar bei beiden SRAMs, die 100ns-Typen sowie bei den 55ns-Bausteinen. Das würde bedeutet, dass die steigende Flanke von /WE mit einer Änderung der Adresse zeitlich zusammenfallen darf. Der verwendete Logicanalyzer hat eine Auflösung von 10ns, sodass man eigentlich nur sagen kann, dass sich /WE und der Adressbus im selben Zeitraum von 10ns ändern. Also schauen wir uns /WE und eine zufällige Adressleitung nochmal unterm Oszilloskop an.&lt;/p>
&lt;p>&lt;img src="images/oszi.jpg" alt=""> /WE und A9 unterm Oszilloskop. Gelb: /WE, Blau: A9&lt;/p>
&lt;p>Offenbar ändert sich der Adressbus, &lt;strong>bevor&lt;/strong> mit der steigenden Flanke von /WE der Schreibzugriff endet! Einen ausreichend schnellen Chip vorausgesetzt, könnte der anliegende Schreibzugriff womöglich in die neue Adresse hereingeschleppt werden. Wie dem auch sei, auf jeden Fall etwas, das so nicht sein darf! Wir halten die 0ns Write Recovery Time nicht ein, indem wir sie um ca. 4ns unterschreiten.&lt;/p>
&lt;p>/OE und /WE für die RAMs wird bei uns durch 3 NAND-Gatter in einem 74HCT00 aus der r/W-Leitung und dem Systemtakt erzeugt. Ein 74HCT00 hat eine Durchlaufzeit von ca. 9ns. Als nächstes werden wir also stattdessen einen 74F00 verwenden, der uns mit 3.7ns Durchlaufzeit wieder in den Bereich tWR &amp;gt; 0ns bringen sollte. Sollte es das nicht bringen, werden wir uns etwas grundsätzlichere Gedanken machen müssen.&lt;/p></content></item><item><title>Das VCFe 18.0 steht vor der Tür</title><link>https://www.steckschwein.de/post/das-vcfe-18-0-steht-vor-der-tuer/</link><pubDate>Wed, 19 Apr 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/das-vcfe-18-0-steht-vor-der-tuer/</guid><description>Am 29.04.2017 ist es wieder so weit, das Vintage Computer Festival Europe vereint in München wieder für 3 Tage Freunde historischer Computer.
Was sich geändert hat, ist der Veranstaltungsort, denn die altehrwürdige Turnhalle des E.S.V. München-Ost ist vergangenes Jahr abgerissen worden:
Kulturzentrum Trudering Wasserburger Landstraße 32 81825 München
Was sich nicht geändert hat, ist, dass das Steckschwein wieder mit dabei sein wird. Diesmal mit lauffähigem EhBASIC und einigen klassischen Beispielen.</description><content>&lt;p>&lt;img src="images/vcflogo.gif" alt="vcflogo">&lt;/p>
&lt;p>Am 29.04.2017 ist es wieder so weit, das &lt;a href="http://vcfe.org/">Vintage Computer Festival Europe&lt;/a> vereint in München wieder für 3 Tage Freunde historischer Computer.&lt;/p>
&lt;p>Was sich geändert hat, ist der Veranstaltungsort, denn die altehrwürdige Turnhalle des E.S.V. München-Ost ist vergangenes Jahr abgerissen worden:&lt;/p>
&lt;p>&lt;strong>Kulturzentrum Trudering Wasserburger Landstraße 32 81825 München&lt;/strong>&lt;/p>
&lt;p>Was sich nicht geändert hat, ist, dass das Steckschwein wieder mit dabei sein wird. Diesmal mit lauffähigem EhBASIC und einigen klassischen Beispielen.&lt;/p>
&lt;p>Wir freuen uns.&lt;/p></content></item><item><title>LOAD / SAVE in EhBasic</title><link>https://www.steckschwein.de/post/load-save-in-ehbasic/</link><pubDate>Tue, 28 Feb 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/load-save-in-ehbasic/</guid><description>Nachdem EhBasic brauchbar auf unserem SteckOS-Kernel läuft, fehlen noch 2 Kleinigkeiten für das vollkommene Glück. Denn noch lassen sich die geschriebenen BASIC-Kunstwerke nicht speichern. Dies stellt uns gleich vor 2 Herausforderungen:
Unsere FAT32-Implementierung beherrscht noch gar keinen Schreibzugriff. Genauer gesagt ist es noch nicht möglich, freie Cluster zu finden und Verzeichniseinträge zu erzeugen. LOAD und SAVE existieren in EhBasic nur als Vektoren, an die bei Aufruf gesprungen wird. Was dort passieren soll, muss für die jeweilige Hardware selbst implementiert werden.</description><content>&lt;p>Nachdem EhBasic brauchbar auf unserem SteckOS-Kernel läuft, fehlen noch 2 Kleinigkeiten für das vollkommene Glück. Denn noch lassen sich die geschriebenen BASIC-Kunstwerke nicht speichern. Dies stellt uns gleich vor 2 Herausforderungen:&lt;/p>
&lt;ol>
&lt;li>Unsere FAT32-Implementierung beherrscht noch gar keinen Schreibzugriff. Genauer gesagt ist es noch nicht möglich, freie Cluster zu finden und Verzeichniseinträge zu erzeugen.&lt;/li>
&lt;li>LOAD und SAVE existieren in EhBasic nur als Vektoren, an die bei Aufruf gesprungen wird. Was dort passieren soll, muss für die jeweilige Hardware selbst implementiert werden.&lt;/li>
&lt;/ol>
&lt;p>Fangen wir also ganz vorne an. Neue Dateien anlegen können wir noch nicht, da wir noch keine Operationen auf der FAT unterstützen, also auch keine freien Cluster finden können. Der Kunstgriff hier ist, diese Aufgaben von einem System erledigen zu lassen, das das schon kann. Dementsprechend werden einfach auf einem PC der Wahl auf der Karte Dateien FILE0000.DAT bis FILE0009.DAT angelegt. Diese sollen dann als unsere &amp;ldquo;Schreib-Slots&amp;rdquo; dienen. Vorhandene Dateien zu überschreiben und die Dateigröße im Directory mit der neuen Größe zu überschreiben, ist kein großes Problem.&lt;/p>
&lt;p>Um nun LOAD und SAVE in EhBasic implementieren zu können, brauchen wir zunächst Antworten auf folgende Fragen:&lt;/p>
&lt;ol>
&lt;li>In welchem Speicherbereich liegt mein Programm, das ich speichern will?&lt;/li>
&lt;li>Wie teile ich EhBasic mit, wo mein geladenes Programm im Speicher endet?&lt;/li>
&lt;li>Wie gebe ich LOAD und SAVE einen Dateinamen als Parameter mit?&lt;/li>
&lt;/ol>
&lt;p>Der Reihe nach. Die ersten beiden Fragen sind relativ klar im EhBasic-Forum auf 6502.org beantwortet. Der xxxx leider verstorbene EhBasic-Autor Lee Davison hat im &lt;a href="http://forum.6502.org/viewtopic.php?f=5&amp;amp;t=2198">entsprechenden Thread&lt;/a> die Antworten auf die Fragen 1 und 2 2012 gegeben:&lt;/p>
&lt;p>&amp;ldquo;If you want to save the program as binary you should save (Smeml) to (Svarl)-1.&amp;rdquo;&lt;/p>
&lt;p>Smeml/h ist ein Vektor, der auf die Startadresse für Basicprogramme zeigt. Direkt nach dem Basic-Programm folgt demnach der Variablenbereich, auf den Svarl/h zeigt. Dann ist ja alles ganz einfach. Wir setzen unseren write_block-Pointer auf dasselbe Ziel wie Smeml/h. Die Dateigröße errechnen sich aus Svarl-1 - Smeml.&lt;/p>
&lt;pre>&lt;code> lda Smemh
sta write\_blkptr + 1
lda Smeml
sta write\_blkptr + 0
sec
lda Svarl
sbc Smeml
sta fd\_area + F32\_fd::FileSize + 0,x
lda Svarh
sbc Smemh
sta fd\_area + F32\_fd::FileSize + 1,x
lda #$00
sta fd\_area + F32\_fd::FileSize + 2,x
sta fd\_area + F32\_fd::FileSize + 3,x
&lt;/code>&lt;/pre>
&lt;p>Das Laden gestaltet sich analog:&lt;/p>
&lt;p>&amp;ldquo;To load a binary program start loading it at (Smeml) and set (Svarl) to the last address + 1 then call LAB_1477 to clear the variables and reset the execution pointer. An easy way to do the first part is by copying (Smeml) to (Svarl) and using (Svarl) as a post incremented save pointer. If there is a chance that the program has been relocated it&amp;rsquo;s probably a good idea to rebuild the line pointer chain. &amp;quot;&lt;/p>
&lt;p>Wir setzen unseren read_block-Pointer also auf Smeml/h, laden die Datei, addieren die Dateigröße aus dem Filedeskriptor und setzen Svarl/h entsprechend.&lt;/p>
&lt;pre>&lt;code> lda Smemh
sta read\_blkptr + 1
lda Smeml
sta read\_blkptr + 0
jsr krn\_read
bne io\_error
clc
lda Smeml
adc fd\_area + F32\_fd::FileSize + 0,x
sta Svarl
lda Smemh
adc fd\_area + F32\_fd::FileSize + 1,x
sta Svarh
jsr krn\_close
bne io\_error
jsr krn\_primm
.byte &amp;quot;Ok&amp;quot;, $0a, $00
JMP LAB\_1319
&lt;/code>&lt;/pre>
&lt;p>Statt LAB_1477 springen wir nach LAB_1319. Hier wird implizit auch nach LAB_1477 gesprungen, aber noch wie oben erwähnt die line-pointer-chain neu aufgebaut. Damit sind wir flexibel, denn so können wir bereits gespeicherte Programme auch dann wieder laden und ausführen, falls sich unsere Basic-Start-Adresse einmal ändern sollte.&lt;/p>
&lt;p>Erste Versuche mit hart codiertem Dateinamen verlaufen vielversprechend. Jetzt möchten wir uns noch aussuchen können, welche Datei geladen oder in welche gespeichert werden soll. Wir müssen EhBasic beibiegen, nach LOAD noch ein Stringargument auszuwerten: LOAD &amp;ldquo;filename&amp;rdquo;&lt;/p>
&lt;p>To be continued&amp;hellip;&lt;/p></content></item><item><title>EhBASIC nochmal</title><link>https://www.steckschwein.de/post/ehbasic-nochmal/</link><pubDate>Sun, 22 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/ehbasic-nochmal/</guid><description>Vor geraumer Zeit hatten wir ja bereits EhBASIC auf dem Steckschwein zum Laufen gebracht. Diese Version war im Wesentlichen eine Machbarkeitsstudie. Diese setzte auch noch nicht auf unseren SteckOS-Kernel auf, sondern auf BIOS-Routinen. Hier lag also noch ein wenig Arbeit vor uns.
Die EhBASIC-Dokumentation setzt bei einem potentiellen Portierungsziel nicht sehr viel voraus, und dies sind schon die &amp;ldquo;Preferred requirements&amp;rdquo;:
6502 or better processor (65c02, CCU3000, M38xx). 10k ROM or RAM for the interpreter code.</description><content>&lt;p>&lt;img src="images/img_2287.jpg" alt="img_2287">&lt;/p>
&lt;p>Vor geraumer Zeit hatten wir ja bereits EhBASIC auf dem Steckschwein zum Laufen gebracht. Diese Version war im Wesentlichen eine Machbarkeitsstudie. Diese setzte auch noch nicht auf unseren SteckOS-Kernel auf, sondern auf BIOS-Routinen. Hier lag also noch ein wenig Arbeit vor uns.&lt;/p>
&lt;p>Die EhBASIC-Dokumentation setzt bei einem potentiellen Portierungsziel nicht sehr viel voraus, und dies sind schon die &amp;ldquo;Preferred requirements&amp;rdquo;:&lt;/p>
&lt;ol>
&lt;li>6502 or better processor (65c02, CCU3000, M38xx).&lt;/li>
&lt;li>10k ROM or RAM for the interpreter code.&lt;/li>
&lt;li>RAM from $0000 to $BFFF (more with changes).&lt;/li>
&lt;li>Any character based I/O (e.g. RS232, LCD/keyboard etc).&lt;/li>
&lt;/ol>
&lt;p>Punkte 1 und 2 sind schnell abgehakt. Einen 65c02 hat das Steckschwein ja. 10k ROM haben wir nicht am Stück, jedoch wollen wir das Basic ja als Programm im RAM ausführen, und davon haben wir 64k. Alles klar.&lt;/p>
&lt;p>Die Punkte 3 und 4 erfordern jedoch ein paar kleine Anpassungen. RAM von $0000 bis $BFFF gibt es im Steckschwein nicht durchgehend, denn von $0200 bis $027F liegt ja der IO-Bereich. Hier gilt es also zunächst zu prüfen, ob EhBASIC zufällig in diesem Bereich irgendetwas tut. Im EhBASIC-eigenen Monitor min_mon wird zwar ein IO-Bereich angegeben, dieser wird jedoch in unserer Version nicht angesprochen, da wir zur Ein- und Ausgabe unserer SteckOS-Kernel-Routinen verwenden wollen.&lt;/p>
&lt;p>Jetzt müssen wir sicherstellen, dass sich der Basic-Start, also die Adresse, an der die eigentlichen Basic-Programme im Speicher liegen, mit nichts überschneidet. EhBASIC wird ja offenbar eher ROM-basiert  verwendet und liegt damit meist im oberen Adressbereich. Im Quellcode gibt es die Konstanten Ram_base und Ram_top. Hier gab es schon das erste Problem, dass Ram_top nicht größer sein konnte als die Startadresse des eigentlichen EhBASIC-Codes. Mit Hilfe der äußerst hilfreichen Community im Forum auf 6502.org konnten wir &amp;ldquo;unser&amp;rdquo; Basic aber patchen: &lt;a href="http://forum.6502.org/viewtopic.php?p=48368#p48368">http://forum.6502.org/viewtopic.php?p=48368#p48368&lt;/a>&lt;/p>
&lt;p>EhBASIC benötigt außerdem eine Routine zur Zeicheneingabe. Laut Dokumentation:&lt;/p>
&lt;blockquote>
&lt;p>This is a non halting scan of the input device. If a character is ready it should be placed in A and the carry flag set, if there is no character then A, and the carry flag, should be cleared.&lt;/p>
&lt;/blockquote>
&lt;p>Einen non-halting Scan der Tastatur haben wir schon, die Routine &amp;ldquo;krn_getkey&amp;rdquo;. Die geforderte Mimik mit dem Carry Flag haben wir dort noch eingebaut und nutzen diese auch selbst in krn_keyin. So kann krn_getkey direkt in EhBasic verwendet werden.&lt;/p>
&lt;p>Auch unsere krn_chrout-Routine können wir direkt in EhBasic nutzen.&lt;/p>
&lt;p>Damit haben wir endlich ein lauffähiges Basic auf unserem Steckschwein!&lt;/p>
&lt;p>Relativ schnell fiel allerdings etwas störend ins Gewicht, dass der Tokenizer von EhBasic die Eingabe von BASIC-Schlüsselwörtern in Großbuchstaben erwartet, was auf Dauer etwas anstrengend ist. Das Steckschwein, unterstützt bekanntlich Groß- und Kleinschreibung mit Kleinschreibung als Default.&lt;/p>
&lt;p>Es wäre doch nett, wenn der Tokenizer beides akzeptieren würde. Dies würde ja nichtmal die Ausführungsgeschwindigkeit negativ beeinträchtigen, da nur für das Parsen ein weiterer Schritt nötig wäre.&lt;/p>
&lt;p>Ganz so trivial wie angenommen war der Patch dann doch nicht. Der EhBASIC tokenizer sucht zunächst nach dem ersten Zeichen des Dictionary-Eintrags. Das zu suchende Zeichen liegt hierbei im Akku. Das Dictionary liegt schon in Großschreibung vor, sodass es an dieser Stelle reicht, den Akkuinhalt zu prüfen, ob es sich um einen Buchstaben handelt, und diesen dann in den entsprechenden Großbuchstaben zu verwandeln. Unser toupper-Makro tut genau das!&lt;/p>
&lt;p>Jetzt funktioniert der Tokenizer zumindest schon einmal für das erste Zeichen case-insensitiv. Für den Rest des Schlüsselworts galt es, ein wenig zu knobeln, denn das zu vergleichende Zeichen liegt hier nicht im Akku. Der Hack besteht nun darin, nach einem Nichttreffer den Akkuinhalt in einen Kleinbuchstaben zu verwandeln und einfach nochmal zu vergleichen: &lt;a href="https://bitbucket.org/steckschwein/steckschwein-code/commits/7729b971379f4ec022e9c98a3154ff6b0a20653f">https://bitbucket.org/steckschwein/steckschwein-code/commits/7729b971379f4ec022e9c98a3154ff6b0a20653f&lt;/a>&lt;/p>
&lt;p>Das macht den Tokenizer für in Kleinbuchstaben geringfügig langsamer, was aber auf die Ausführungsgeschwindigkeit keinen Einfluss. Als Extra-Bonus können Variablennamen jetzt groß oder klein geschrieben sein, also i ist nicht gleich I.&lt;/p>
&lt;p>Zuletzt wurde noch eine weitere Anregung aus dem 6502.org-Forum umgesetzt, denn zwar ist der Tokenizer jetzt case-insensitive, aber Buchstaben, die nicht im Dictionary stehen, werden weiterhin immer als Großbuchstaben dargestellt. Auch hier gibt es einen kleinen Patch: &lt;a href="http://forum.6502.org/viewtopic.php?p=50271#p50271">http://forum.6502.org/viewtopic.php?p=50271#p50271&lt;/a>&lt;/p>
&lt;p>Jetzt fehlen nur noch Implementationen für LOAD und SAVE, damit wir unsere BASIC-Kunstwerke auch im Filesystem speichern können und evtl. das ein oder andere BASIC-Spiel vom C64 portieren können.&lt;/p></content></item><item><title>Es wird geschraubt</title><link>https://www.steckschwein.de/post/es-wird-geschraubt/</link><pubDate>Mon, 25 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/es-wird-geschraubt/</guid><description>Es ist mal wieder recht still ums Schwein. Und mal wieder ist das kein Indiz dafür, dass nicht gewerkelt wird. In den letzten Wochen wurden BIOS und der SteckOS-Kernel auf Basis des Assemblers ca65 neu gebaut. Dessen nachgelagerter Linker erlaubt eine übersichtlichere Strukturierung der Codebasis.
In den FAT32-Code wird aktuell ebenfalls einiges an Hirnschmalz investiert, um endlich Cluster Chain lookups und Schreib-Support bauen zu können.
Darüberhinaus kam letzte Woche der Geistesblitz, die Kommunikation des Tastaturcontrollers ATmega8 mit der Tastatur über dessen eingebauten USART zu machen, anstatt &amp;ldquo;Zu Fuß&amp;rdquo; in Software.</description><content>&lt;p>Es ist mal wieder recht still ums Schwein. Und mal wieder ist das kein Indiz dafür, dass nicht gewerkelt wird. In den letzten Wochen wurden BIOS und der SteckOS-Kernel auf Basis des Assemblers ca65 neu gebaut. Dessen nachgelagerter Linker erlaubt eine übersichtlichere Strukturierung der Codebasis.&lt;/p>
&lt;p>In den FAT32-Code wird aktuell ebenfalls einiges an Hirnschmalz investiert, um endlich Cluster Chain lookups und Schreib-Support bauen zu können.&lt;/p>
&lt;p>Darüberhinaus kam letzte Woche der Geistesblitz, die Kommunikation des Tastaturcontrollers ATmega8 mit der Tastatur über dessen eingebauten USART zu machen, anstatt &amp;ldquo;Zu Fuß&amp;rdquo; in Software. Hier wird aktuell also auch geforscht. Wenn das klappt, dann wird dies auf jeden Fall in das Redesign des IO-Boards einfließen.&lt;/p>
&lt;p>&lt;img src="images/f5daf605-fa8e-4a54-bee9-9d807671d973.jpg" alt="f5daf605-fa8e-4a54-bee9-9d807671d973">&lt;/p></content></item><item><title>Wir sind umgezogen II</title><link>https://www.steckschwein.de/post/wir-sind-umgezogen-ii/</link><pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/wir-sind-umgezogen-ii/</guid><description>Nach dem Umzug der Website ist jetzt unser Code-Repository dran. Dies ist jetzt auf bitbucket.org zu finden:
https://bitbucket.org/steckschwein/steckschwein-code</description><content>&lt;p>Nach dem Umzug der Website ist jetzt unser Code-Repository dran. Dies ist jetzt auf &lt;a href="https://bitbucket.org">bitbucket.org&lt;/a> zu finden:&lt;/p>
&lt;p>&lt;a href="https://bitbucket.org/steckschwein/steckschwein-code">https://bitbucket.org/steckschwein/steckschwein-code&lt;/a>&lt;/p></content></item><item><title>Wir sind umgezogen</title><link>https://www.steckschwein.de/post/wir-sind-umgezogen/</link><pubDate>Thu, 23 Jun 2016 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/wir-sind-umgezogen/</guid><description>www.steckschwein.de wird nun direkt bei Wordpress.com gehostet. Somit müssen wir uns um keinen root-Server mehr kümmern und haben mehr Zeit fürs Steckschwein. :-)</description><content>&lt;p>&lt;a href="https://www.steckschwein.de">www.steckschwein.de&lt;/a> wird nun direkt bei Wordpress.com gehostet. Somit müssen wir uns um keinen root-Server mehr kümmern und haben mehr Zeit fürs Steckschwein. :-)&lt;/p></content></item><item><title>Die Spannung sinkt... alles auf 5 Volt</title><link>https://www.steckschwein.de/post/die-spannung-sinkt-alles-auf-5-volt/</link><pubDate>Wed, 11 May 2016 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/die-spannung-sinkt-alles-auf-5-volt/</guid><description>Endlich, wir haben uns mal bemüht und pünktlich zum 17. VCF das Steckschwein auf 5V umgerüstet. Genauer gesagt war ja nur noch das Video-Board und der YPbPr auf RGB-Encoder das Problem. Der kam zwar mit 5V auch klar, jedoch war dann der Kontrast und die Farbsättigung &amp;ldquo;unterirdisch&amp;rdquo;.
Was haben wir geändert? Vorab muss man sagen, dass uns in den - mittlerweile - letzten Jahren zahlreiche Emails von Interessenten, Retro-Freaks und Bastlern ereilten.</description><content>&lt;h3 id="endlich">Endlich,&lt;/h3>
&lt;p>wir haben uns mal bemüht und pünktlich zum 17. VCF das Steckschwein auf 5V umgerüstet. Genauer gesagt war ja nur noch das Video-Board und der YPbPr auf RGB-Encoder das Problem. Der kam zwar mit 5V auch klar, jedoch war dann der Kontrast und die Farbsättigung &amp;ldquo;unterirdisch&amp;rdquo;.&lt;/p>
&lt;h3 id="was-haben-wir-geändert">Was haben wir geändert?&lt;/h3>
&lt;p>Vorab muss man sagen, dass uns in den - mittlerweile - letzten Jahren zahlreiche Emails von Interessenten, Retro-Freaks und Bastlern ereilten. Vielen Dank an dieser Stelle für Anregungen, Hinweise und das Interesse!&lt;/p>
&lt;p>Für die 5Volt &amp;ldquo;Abrüstung&amp;rdquo; des Video-Boards gab es wichtige Hinweise von C. Forstreuter, er ist hier bereits vor über einem Jahr vorausgeeilt und hat den RGB-Encoder auf 5Volt umgestellt. Dabei sind lediglich die Emitter-Widerstände &lt;strong>R4, R5, R6&lt;/strong> und &lt;strong>R15, R16, R20&lt;/strong> durch &lt;strong>470Ohm Widerstände&lt;/strong> zu ersetzen, damit der Pegel bei 5V entsprechend wieder passt. Siehe dazu &lt;a href="http://www.steckschwein.de/index.php/hardware/tms9929-video-display-processor/">Schaltplan des Video-Boards&lt;/a>.&lt;/p>
&lt;p>An dem Stecker für die 5V/12V auf dem Video-Board wird jetzt lediglich eine Drahtbücke angebracht, die die 5V Versorgung mit der ehemaligen 12V Versorgung der RGB-Stufe verbindet. Das Video-Board kann seine Spannung jetzt komplett über das Backplane-Kabel vom CPU-Board beziehen.&lt;/p>
&lt;p>&lt;strong>Jetzt,&lt;/strong>&lt;/p>
&lt;p>können wir das Schwein bequem über die &lt;strong>USB-Buchse&lt;/strong> betreiben, die von Thomas an dem neuen CPU-Board vorgesehen wurde. Das klappt wunderbar, nur noch etwas die Pegel am RGB-Encoder einstellen und alles läuft zufriedenstellend.&lt;/p>
&lt;p>&lt;strong>Nicht ganz,&lt;/strong>&lt;/p>
&lt;p>so schön sieht das Video-Signal aus wenn man das Schwein mit einer schlechten 5V Spannungsversorgung/Netzteil betreibt. Beispielsweise an meinem Notebook direkt über USB-Anschluß, da gibt es dann ein übles &amp;ldquo;Kriseln&amp;rdquo; auf dem Video-Bild. Aber klar, das Schwein zieht fast 500mA und die Notebook-USB-Buchse ist sicherlich alles andere als eine stabile 5V-Quelle. Zumal die USB 1.0-Spezifikation sogar erlaubt, dass die Versorgungsspannung bis zu 4.25V &amp;ldquo;einbrechen&amp;rdquo; kann. Derartige Schwankunngen wirken sich hier natürlich unmittelbar auf das Videosignal aus, da ja analog. Erstaunlich ist jedoch, dass das Steckschwein damit dennoch problemlos funktioniert und das bei 8Mhz!&lt;/p></content></item><item><title>VCFe 17.0 - wir waren dabei</title><link>https://www.steckschwein.de/post/vcfe-17-0-wir-waren-dabei/</link><pubDate>Sun, 01 May 2016 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/vcfe-17-0-wir-waren-dabei/</guid><description>Das VCFe 17.0 ist schon wieder vorbei und wir blicken ein wenig wehmütig zurück. Wehmütig vor allem deswegen, weil dieses Mal wohl definitiv das letzte Mal in der altbekannten Halle des ESV München Ost war. Von Anfang an war diese alte Turnhalle die Heimstatt des VCFe, jetzt muss sie dem Neubau einer Exklusiv-Loft-Wohnumgebung weichen. Genau das, was Berg am Laim unbedingt braucht.
Wie immer gab es viele tolle Dinge zu sehen und zu erfahren.</description><content>&lt;p>Das &lt;a href="http://vcfe.org/D/">VCFe 17.0&lt;/a> ist schon wieder vorbei und wir blicken ein wenig wehmütig zurück. Wehmütig vor allem deswegen, weil dieses Mal wohl definitiv das letzte Mal in der altbekannten Halle des ESV München Ost war. Von Anfang an war diese alte Turnhalle die Heimstatt des VCFe, jetzt muss sie dem Neubau einer Exklusiv-Loft-Wohnumgebung weichen. Genau das, was Berg am Laim unbedingt braucht.&lt;/p>
&lt;p>Wie immer gab es viele tolle Dinge zu sehen und zu erfahren. Den Vogel abgeschossen haben die Urgesteine um Alberto Rubinelli, die eine komplette &lt;a href="https://en.wikipedia.org/wiki/TI-990">Texas Instrument TI990&lt;/a>-Anlage aus Italien hergekarrt haben.&lt;/p>
&lt;p>Wir konnten unsere neue CPU-Platine zeigen, und haben während des Treffens noch die Video-Boards umgelötet, damit wir auf die 12V als zweite Betriebsspannung verzichten können. Damit reicht ab sofort ein USB-Netzteil/Handy-Ladegerät als Stromversorgung für das Steckschwein aus.&lt;/p>
&lt;p>Über FAT32 haben wir auch ein bisschen was erzählt. Hier gibts die &lt;a href="http://steckschwein.files.wordpress.com/2016/05/fat32.pdf">Folien dazu&lt;/a>. Es wurde auch ein Audiomitschnitt angefertigt.&lt;/p>
&lt;p>Einen großen Teil des Sonntags  haben wir mit Neil Franklin über einem möglichen Design für einen CPLD-basierten Grafikcontroller mit VGA-Ausgabe für das Steckschwein gebrütet. Könnte interessant werden.&lt;/p></content></item><item><title>Das Steckschwein auf dem VCFe 17</title><link>https://www.steckschwein.de/post/das-steckschwein-auf-dem-vcfe-17/</link><pubDate>Fri, 22 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/das-steckschwein-auf-dem-vcfe-17/</guid><description>Am Wochenende vom 30. April und 1. Mai 2016 findet zum 17. Mal das Vintage Computer Festival Europe (VCFe) in München statt.
Das Steckschwein ist natürlich wieder dabei. Unter anderem wird es unsere neue CPU-Platine mit integriertem Waitstate-Generator und dadurch möglichen 8MHz Takt gezeigt.
Ausserdem wird es getreu des diesjährigen VCFe-Mottos &amp;ldquo;Irgendwas mit Medien&amp;rdquo; einen Vortrag zum Speichermedium des Steckschweins geben, speziell über dessen FAT32-Unterstützung.</description><content>&lt;p>&lt;img src="images/vcflogo.gif" alt="VCFe 17 Logo">&lt;/p>
&lt;p>Am Wochenende vom 30. April und 1. Mai 2016 findet zum 17. Mal das &lt;a href="http://www.vcfe.org/D/">Vintage Computer Festival Europe (VCFe)&lt;/a> in München statt.&lt;/p>
&lt;p>Das Steckschwein ist natürlich wieder dabei. Unter anderem wird es unsere neue CPU-Platine mit integriertem Waitstate-Generator und dadurch möglichen 8MHz Takt gezeigt.&lt;/p>
&lt;p>Ausserdem wird es getreu des diesjährigen VCFe-Mottos &amp;ldquo;Irgendwas mit Medien&amp;rdquo; einen Vortrag zum Speichermedium des Steckschweins geben, speziell über dessen FAT32-Unterstützung.&lt;/p></content></item><item><title>Die neuen CPU-Boards sind fertig</title><link>https://www.steckschwein.de/post/neue-cpu-platine/</link><pubDate>Thu, 21 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/neue-cpu-platine/</guid><description>Wir arbeiten an neuen Revision unserer Prototyp-Platinen.
Den Anfang macht das CPU-Board. Zum einen sind ein paar Layoutfehler korrigiert worden, zum anderen ist der kürzlich vorgestellte Wait-State-Generator in das Board integriert worden.
Mit den neuen Boards wollen wir auch denen entgegenkommen, die sich selbst ein Steckschwein bauen wollen. Das sind nämlich mehr, als wir dachten. Dementsprechend lassen wir jeweils ein paar mehr Boards herstellen. Um die Inbetriebnahme des Steckschweins zukünftig zu vereinfachen, sind eine Hohlbuchse und eine USB-Buchse dazugekommen, um das Steckschwein später mit 5V aus einem handelsüblichen Netzteil oder per USB zu versorgen.</description><content>&lt;p>Wir arbeiten an neuen Revision unserer Prototyp-Platinen.&lt;/p>
&lt;p>Den Anfang macht das CPU-Board. Zum einen sind ein paar Layoutfehler korrigiert worden, zum anderen ist der &lt;a href="https://www.steckschwein.de/index.php/2016/01/30/chiptuning/">kürzlich vorgestellte&lt;/a> Wait-State-Generator in das Board integriert worden.&lt;/p>
&lt;p>Mit den neuen Boards wollen wir auch denen entgegenkommen, die sich selbst ein Steckschwein bauen wollen. Das sind nämlich mehr, als wir dachten. Dementsprechend lassen wir jeweils ein paar mehr Boards herstellen. Um die Inbetriebnahme des Steckschweins zukünftig zu vereinfachen, sind eine Hohlbuchse und eine USB-Buchse dazugekommen, um das Steckschwein später mit 5V aus einem handelsüblichen Netzteil oder per USB zu versorgen. Die 12V für das Video-Board werden nämlich in einer späteren Revision wegfallen.&lt;/p>
&lt;p>&lt;img src="images/2016-04-20-1.jpg" alt="2016-04-20 (1)">&lt;/p></content></item><item><title>Neue CPU-Boards</title><link>https://www.steckschwein.de/post/neue-cpu-boards/</link><pubDate>Tue, 08 Mar 2016 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/neue-cpu-boards/</guid><description>Wir haben vor, eine neue Revision der Steckschwein-Prototyp-Platinen herzustellen. Den Anfang macht ein neues CPU-Board mit einigen Bugfixes und den in Chiptuning beschriebenen zusätzlichen GAL als Waitstate-Generator, sowie einem geändertem Stromanschluss: In Zukunft wird es möglich sein, das Steckschwein mit nur 5V per USB, über einen Rundstecker oder wie gehabt über einen Pin-Header zu versorgen. Die Layouts sind schon fertig:
Bestückungsseite
Lötseite</description><content>&lt;p>Wir haben vor, eine neue Revision der Steckschwein-Prototyp-Platinen herzustellen. Den Anfang macht ein neues CPU-Board mit einigen Bugfixes und den in &lt;a href="http://www.steckschwein.de/index.php/2016/01/30/chiptuning/">Chiptuning&lt;/a> beschriebenen zusätzlichen GAL als Waitstate-Generator, sowie einem geändertem Stromanschluss: In Zukunft wird es möglich sein, das Steckschwein mit nur 5V per USB, über einen Rundstecker oder wie gehabt über einen Pin-Header zu versorgen. Die Layouts sind schon fertig:&lt;/p>
&lt;p>&lt;img src="images/top.png" alt=""> Bestückungsseite&lt;/p>
&lt;p>&lt;img src="images/bottom.png" alt=""> Lötseite&lt;/p></content></item><item><title>Chiptuning</title><link>https://www.steckschwein.de/post/chiptuning/</link><pubDate>Sat, 30 Jan 2016 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/chiptuning/</guid><description>An den Heimcomputern von &amp;ldquo;damals&amp;rdquo; gemessen ist das Steckschwein mit 4 MHz durchaus einer der schnelleren 6502-Rechner. Damals waren zumeist Taktraten von 1 MHz üblich. Einige wenige hatten deutlich mehr, wie z.B. der Apple IIgs (65816) mit 2.8 MHz. Einen 4 MHz-65(C)02-Heimcomputer hat es damals nach unserem Informationsstand nicht gegeben.
Nun ist es aber so, dass aktuell erhältliche 65c02-CPUs von WDC offiziell mit bis zu 14MHz getaktet werden können, inoffiziell wurden schon problemlos Taktraten von 20 MHz erreicht.</description><content>&lt;p>An den Heimcomputern von &amp;ldquo;damals&amp;rdquo; gemessen ist das Steckschwein mit 4 MHz durchaus einer der schnelleren 6502-Rechner. Damals waren zumeist Taktraten von 1 MHz üblich. Einige wenige hatten deutlich mehr, wie z.B. der Apple IIgs (65816) mit 2.8 MHz. Einen 4 MHz-65(C)02-Heimcomputer hat es damals nach unserem Informationsstand nicht gegeben.&lt;/p>
&lt;p>Nun ist es aber so, dass aktuell erhältliche 65c02-CPUs von WDC offiziell mit bis zu 14MHz getaktet werden können, inoffiziell wurden schon problemlos Taktraten von 20 MHz erreicht. Da ist also noch Raum für eine Prise Größenwahn. Den Takt des Steckschweins pauschal zu erhöhen funktioniert nicht. Zu viele Bausteine kommen dann nicht mehr mit. Das verwendete Atmel 28c256 EEPROM hat eine Zugriffszeit von 150ns. Im WDC-Datenblatt ist tACC des Prozessors bei 4MHz mit 145ns angegeben. Also ist das stand jetzt schon etwas eng. Schneller takten geht also schon allein deswegen auf keinen Fall. Für den Videochip TMS9929 und den Soundchip gilt ähnliches. Das SRAM hingegen läßt sich problemlos gegen Bausteine von Alliance Memory mit 55ns Zugriffzeit austauschen. Damit sollten Taktraten von um die 10 MHz möglich sein.&lt;/p>
&lt;p>Was wir also brauchen ist eine Möglichkeit, auf RAM und VIA (sofern auch WDC und damit gleich schnell)  mit voller Geschwindigkeit zuzugreifen, währen wir den Prozessor bei Zugriffen auf ROM, Video- und Soundchip für 1-2 Zyklen stoppen. Schließlich ist man geschätzt zu 99% im RAM unterwegs.&lt;/p>
&lt;p>Erste Überlegungen gingen in die Richtung, die Taktfrequenz umschaltbar zu machen, je nachdem, welcher Baustein auf dem Bus von der CPU angesprochen wird. Dieses Prinzip birgt zwei entscheidende Nachteile:&lt;/p>
&lt;ol>
&lt;li>Man darf den Takt nicht einfach so umschalten. Erwischt man einen ungünstigen Moment, kann dies die CPU zum Absturz bringen. Näheres kann in einem &lt;a href="http://www.6502.org/mini-projects/clock-switching/clock-switching.html">entsprechenden Artikel auf 6502.org&lt;/a> nachgelesen werden.&lt;/li>
&lt;li>Die VIA-Timer sind direkt abhängig von der Taktfrequenz. Software, die diese benutzt, könnte sich nicht mehr auf diese verlassen, wenn sich die Taktfrequenz ständig ändert.&lt;/li>
&lt;/ol>
&lt;p>Zum Glück bietet der 6502 auch hier genau das, was wir brauchen: Den RDY-Pin. Wird dieser auf LOW gezogen, &amp;ldquo;friert&amp;rdquo; der 6502 ein. Kehrt RDY wieder auf HIGH zurück, macht die CPU dort weiter, wo sie unterbrochen wurde. Durch geschicktes Ansteuern dieser Leitung können wir den Prozessor also veranlassen, auf langsamere Bausteine zu warten. Dieses Konzept nennt sich Wait States (eben Wartezyklen) und ist bei aktuellen Computern gang und gäbe.&lt;/p>
&lt;p>Im Grunde genommen brauchen wir also einen Zähler, der die Taktfrequenz des Systems herunterteilt, und eine Selektionslogik, über die sich wählen läßt, welcher Ausgang des Zählers die Grundlage für das RDY-Signal bilden soll, und damit die Anzahl der Wait States bestimmt. Dieses Signal bildet invertiert das RDY-Signal.&lt;/p>
&lt;p>&lt;img src="images/tekway331_2.gif" alt=""> Gelb: RDY, Blau: PHI2 (Systemtakt) - 2 Wait States für den Videochip&lt;/p>
&lt;p>Zur folgender Logik haben wir uns vom &lt;a href="http://sbc.rictor.org/parts/wsgen.html">Waitstate-Generator von Daryl Rictor&lt;/a>  stark inspirieren lassen. Im Wesentlichen haben wir die Adressdekoderlogik zugunsten der bereits ausdekodierten /CS_&amp;hellip; Leitungen entfernt, sowie die Syntax von CUPL nach GALasm überführt.&lt;/p>
&lt;p>&lt;img src="images/img_20160130_144611.jpg" alt=""> Waitstate-Generator-Prototyp auf dem Steckbrett&lt;/p>
&lt;p>Folgende Schaltung erzeugt entsprechend 1 oder 2 Waitstates, und versetzt den Ausgangspin in den Tri-State-Zustand, damit auch andere Bausteine Wait-States anfordern können. Sollten einmal mehr Waitstates nötig werden, lassen sich noch 1 oder 2 Zählerstufen hinzufügen, um 4 oder 8 Waitstates zu erzeugen.&lt;/p>
&lt;pre tabindex="0">&lt;code>GAL16V8
RDYGEN
Clock ROM VIA UART VDP SND NC NC Clear GND
/OE RDY W1 W2 NC NC NC Q1 Q0 VCC
W2 = ROM \* VIA \* UART \* SND \* /VDP
+ ROM \* VIA \* UART \* /SND \* VDP
W1 = W2
+ /ROM \* VIA \* UART \* VDP
Q0.R = W1 \* /Q0 \* /Q1 \* Clear
+ W2 \* /Q0 \* /Q1 \* Clear
Q1.R = W2 \* /Q1 \* Q0 \* Clear
RDY.T = /Q0 \* /Q1
RDY.E = W1
&lt;/code>&lt;/pre>&lt;p>DESCRIPTION:
Generation of /RDY line modeled after &lt;a href="http://sbc.rictor.org/parts/wsgen.html">http://sbc.rictor.org/parts/wsgen.html&lt;/a>
and adapted to galasm syntax&lt;/p>
&lt;p>Wir freuen uns jetzt über ein 8MHz-Steckschwein. Das Tolle ist, dass die VIA ebenfalls mit 8 MHz und ohne Waitstates betrieben werden kann, sodass sich die erhöhte Geschwindigkeit 1:1 auf den SPI-Bus auswirkt. Zugriffe auf die SD-Karte sind damit gleich doppelt so schnell.&lt;/p></content></item><item><title>Make Munich 2016 - das wars schon wieder</title><link>https://www.steckschwein.de/post/make-munich-2016-das-wars-schon-wieder/</link><pubDate>Mon, 18 Jan 2016 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/make-munich-2016-das-wars-schon-wieder/</guid><description>Die Make Munich 2016 ist schon wieder vorbei, und wir freuen uns, dass wir dabei sein durften. Vielen Dank an alle, die unseren Stand besucht und sich von uns vollschwallen lassen haben.
Besonderer Dank gilt Michael Steil, der sich vor Ort mit uns hingesetzt hat, um MS-Basic aufs Steckschwein zu portieren.
Als stärkste Erkenntnis nehmen wir mit, dass es tatsächlich Interesse am Nachbau des Steckschweins gibt. Das wundert uns zwar ein wenig, freut uns aber auch.</description><content>&lt;p>Die Make Munich 2016 ist schon wieder vorbei, und wir freuen uns, dass wir dabei sein durften. Vielen Dank an alle, die unseren Stand besucht und sich von uns vollschwallen lassen haben.&lt;/p>
&lt;p>Besonderer Dank gilt &lt;a href="http://www.pagetable.com/">Michael Steil&lt;/a>, der sich vor Ort mit uns hingesetzt hat, um &lt;a href="http://www.pagetable.com/?p=774">MS-Basic&lt;/a> aufs Steckschwein zu portieren.&lt;/p>
&lt;p>Als stärkste Erkenntnis nehmen wir mit, dass es tatsächlich Interesse am Nachbau des Steckschweins gibt. Das wundert uns zwar ein wenig, freut uns aber auch. Warum nicht? Was uns Spaß macht, macht bestimmt auch anderen Spaß.&lt;/p>
&lt;p>Dem wollen wir zukünftig Rechnung tragen. Mit der nächsten Hardware-Revision werden wir ein paar Platinen mehr herstellen lassen, und es wird eine Bauanleitung samt Stückliste und Bezugsquellen geben.&lt;/p></content></item><item><title>Make Munich 2016, Tag 1</title><link>https://www.steckschwein.de/post/make-munich-2016-tag-1/</link><pubDate>Sat, 16 Jan 2016 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/make-munich-2016-tag-1/</guid><description>Der erste Tag auf der Make Munich 2016 ist vorbei und wir freuen uns über viel positive Resonanz aus unterschiedlichsten Richtungen. Schön zu beobachten waren auch die vielen jungen Betatester unseres Saurier-Spiels. Es ist einiges an Feedback zur Verbesserung des Gameplays zusammengekommen. Morgen ist auch das Bonbonglas wieder gefüllt.</description><content>&lt;p>Der erste Tag auf der Make Munich 2016 ist vorbei und wir freuen uns über viel positive Resonanz aus unterschiedlichsten Richtungen. Schön zu beobachten waren auch die vielen jungen Betatester unseres Saurier-Spiels. Es ist einiges an Feedback zur Verbesserung des Gameplays zusammengekommen. &lt;img src="images/713231431_7458848305999519557-e1452971879108.jpg" alt="Wir an unserem Stand auf der Make Munch 2016"> Morgen ist auch das Bonbonglas wieder gefüllt.&lt;/p></content></item><item><title>Das Steckschwein auf der Make Munich 2016</title><link>https://www.steckschwein.de/post/das-steckschwein-auf-der-make-munich-2016/</link><pubDate>Mon, 30 Nov 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/das-steckschwein-auf-der-make-munich-2016/</guid><description>Wir sind dabei!
Wir dürfen unser kleines Projekt auf der Make Munich 2016 vorstellen! Ehrlich gesagt haben damit nicht wirklich gerechnet, denn die Maker-Szene ist ja eher visionär unterwegs, während wir etwas bauen, was vor 20 Jahren schon alt war. Umso mehr freut es uns, dass wir dabei sein dürfen. Wir denken uns auch etwas Schönes aus, um die Brücke zur Gegenwart zu schlagen.
Also, notieren: Steckschwein kucken auf der Make Munich 2016, 16.</description><content>&lt;p>&lt;img src="images/makemunich_facebook_wir-sind-dabei2_1200x4442-e1448877266673.jpg" alt="MakeMunich_Formatvorlagen-RGB-web_neueFarben"> Wir sind dabei!&lt;/p>
&lt;p>Wir dürfen unser kleines Projekt auf der &lt;a href="http://make-munich.de/">Make Munich 2016&lt;/a> vorstellen! Ehrlich gesagt haben damit nicht wirklich gerechnet, denn die Maker-Szene ist ja eher visionär unterwegs, während wir etwas bauen, was vor 20 Jahren schon alt war. Umso mehr freut es uns, dass wir dabei sein dürfen. Wir denken uns auch etwas Schönes aus, um die Brücke zur Gegenwart zu schlagen.&lt;/p>
&lt;p>Also, notieren: Steckschwein kucken auf der &lt;a href="http://make-munich.de/">Make Munich 2016&lt;/a>, 16. und 17. Januar 2016&lt;/p></content></item><item><title>Umständliche Portierung von EhBasic</title><link>https://www.steckschwein.de/post/umstaendliche-portierung-von-ehbasic/</link><pubDate>Fri, 16 Oct 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/umstaendliche-portierung-von-ehbasic/</guid><description>Es ist manchmal schon sehr mühselig bereits kleinere Probleme mit Assembler lösen zu müssen. Was uns für das Steckschwein fehlt ist eine einfache Sprache mit der man kleine Dinge erledigen und zeigen kann.
Also, warum nicht ein einfaches Basic für das Steckschwein portieren? Die Auswahl an guten Basic-Implementierungen ist überschaubar und unsere Wahl fiel in dem Fall auf EhBasic von LeeDavison. Warum? Nun, es hat sich gezeigt, dass EhBasic von vielen Homebrew-Projekten verwendet wird, die eine 6502-CPU-Basis benutzen.</description><content>&lt;p>Es ist manchmal schon sehr mühselig bereits kleinere Probleme mit Assembler lösen zu müssen. Was uns für das Steckschwein fehlt ist eine einfache Sprache mit der man kleine Dinge erledigen und zeigen kann.&lt;/p>
&lt;p>Also, warum nicht ein einfaches Basic für das Steckschwein portieren? Die Auswahl an guten Basic-Implementierungen ist überschaubar und unsere Wahl fiel in dem Fall auf EhBasic von LeeDavison. Warum? Nun, es hat sich gezeigt, dass EhBasic von vielen Homebrew-Projekten verwendet wird, die eine 6502-CPU-Basis benutzen. Darüber hinaus scheint EhBasic sogar eine sehr gute Implementierung zu sein, weil die Performance und Erweiterbarkeit gegenüber anderen Basics für diese Zielplattform herausragend ist.&lt;/p>
&lt;p>Dann sollte das doch für uns und das Steckschwein auch kein Problem sein, oder?&lt;/p>
&lt;p>Nun, schaut man sich an was zu tun ist, so sind im wesentlichen folgende Dinge zu tun&lt;/p>
&lt;ul>
&lt;li>EhBasic Assembler-Sourcen nach Acme-Assembler übersetzen&lt;/li>
&lt;li>VEC_IN - Pointer und Code für eine Tastatur-Eingabe Routine bereitstellen&lt;/li>
&lt;li>VEC_OUT - Pointer und Code für eine Ausgabe-Routine (Display) bereitstellen&lt;/li>
&lt;li>VEC_LD - Pointer und Code für eine Basic-Datei Lade-Routine bereitstellen&lt;/li>
&lt;li>VEC_SV - Pointer auf und Code für eine Basic-Datei Speicher-Routine bereitstellen&lt;/li>
&lt;li>Adressen anpassen und konfigurieren&lt;/li>
&lt;li>Spass haben mit EhBasic&lt;/li>
&lt;/ul>
&lt;p>Nach aktuellem Stand der Entwicklung haben wir bereits die Möglichkeit VEC_IN und VEC_OUT problemlos bereitzustellen. Für LOAD und SAVE wird das schon etwas kniffeliger, aber wir können ja erstmal ohne Laden und Speichern auskommen.&lt;/p>
&lt;p>Wir nehmen also die Sourcen des min_mon.a portieren auch die nach Acme-Assembler und setzen in der Sprungtabelle einfach unsere Routinen für Input/Output ein.&lt;/p>
&lt;p>LAB_vec
   !word .getkey ; byte in
   !word .chrout ; byte out
   !word LOAD ; load vector for EhBASIC
   !word SAVE ; save vector for EhBASIC&lt;/p>
&lt;p>Wir benötigen noch eine .getkey und .chrout Implementierung, da derartige Routinen mittlerweile in den Steckschwein-Kernel verlagert wurden. Wir setzen mit EhBasic also direkt auf das Steckschwein-Bios auf und müssen daher die Ein- und Ausgabe nochmal selber stricken.&lt;/p>
&lt;p>Die Zeichenausgabe ist einfach, lediglich X-Register und Akku retten, da die Bios-Methode dies nicht tut.&lt;/p>
&lt;p>.chrout
pha
phx
jsr chrout
plx
pla
rts&lt;/p>
&lt;p>Die Zeicheneingabe ist ein Aufruf an die Tastatur per SPI über die VIA. Die Basis-Methoden liegen im Bios vor.&lt;/p>
&lt;p>.getkey
phx
lda #%01111010
sta via1portb
jsr spi_r_byte
ldx #%11111110
stx via1portb
plx
cmp #$00; restore zero flag
rts&lt;/p>
&lt;p>Aufpassen muss man hier, dass das Zero-Flag entsprechend gelöscht/gesetzt ist. Dies wird von EhBasic so erwaret. Nach dem plx ist dies aber &amp;ldquo;zerstärt&amp;rdquo; und wir machen daher den Vergleich auf 0-Byte - keine Taste gedrückt - explizit bevor wir die Funktion verlassen.&lt;/p>
&lt;p>Das ist auch schon alles, wir Laden das Basic und siehe da&amp;hellip; es erscheint die Einschaltmeldung des EhBasic.&lt;/p>
&lt;p>&lt;img src="images/img_12281-1024x768.jpg" alt="img_12281-1024x768">&lt;/p>
&lt;p>&lt;strong>Aber, weiter geht es leider nicht&lt;/strong>, irgendwas passt noch nicht. Aber was?!? Ok, wir schauen uns das Basic nun genauer an. Wir stellen schnell fest das die gesamte Zeropage (ZP) durch das Basic benötigt wird und gleichzeitig im Konflikt mit der ZP-Belegung vom Steckschwein-Bios steht. Das geht so natürlich nicht! Hier liegen beispielsweise die Pointer für die Ein-/Ausgabe Sprungvektoren oder die Speicheradressen für die Cursor-Position. Genau da, wo sich das EhBasic sich austobt.&lt;/p>
&lt;p>Mit dieser Erkenntnis und der Tatsache das bereits das Steckschwein-Bios große Bereiche der Zeropage beansprucht lehnen wir uns zurück und überlegen wie wir das Schweine-Bios schlanker machen können. Puh&amp;hellip;. jetzt artet das ja doch in Arbeitet aus :/&lt;/p>
&lt;p>Ich berate mich also mit Thomas und wir können einige Vektoren aus der ZP entfernen, da für Sprungvektoren - via JMP ($xxyy) - ja nicht zwangsweise die ZP verschwendet werden muss.&lt;/p>
&lt;p>Wir überlegen wo wir diese Sprung-Vektoren ablegen, bestenfalls speichermäßig in die Nähe der ZP. Nach der ZP kommt der Stack danach der I/O-Bereich. Also bleibt nur Bereich ab $0300. Aber warum denn erst dort?&lt;/p>
&lt;p>Irgendwie sind wir wohl bei unserem Adress-Decoder im GAL auf halben Wege abgestorben. Warum haben wir hier eine ganze Page für I/O vorgesehen? Wir wissen es nicht mehr und beschließen den Decoder nochmal auf &amp;ldquo;links&amp;rdquo; zu drehen. Wir &amp;ldquo;defragmentieren&amp;rdquo; den I/O-Bereich, so dass wir einen zusammenhängenden I/O-Bereich von $0200 - $027f erhalten. Ab $0280 bis $02ff wird frei adressierbarer RAM frei, also insgesamt 128 Byte. Genug, um unsere Vektoren hier abzulegen. Der Bereich ist quasi eine &amp;ldquo;Extended Zeropage&amp;rdquo; und wir sind glücklich damit. Sieht jetzt so aus&amp;hellip;&lt;/p>
&lt;p>&lt;img src="images/steckschwein_lowram.png" alt="steckschwein_lowram">&lt;/p>
&lt;p>Mit dieser neuen Speicheraufteilung können wir die Konflikte zwischen EhBasic und Steckschwein-Bios in der ZP problemlos lösen. Ab $0300 liegen einige Vektoren für das Basic selbst gefolgt vom Eingabepuffer. Wir passen die Start- und Endadresse für den Basic Programm-Speicher auf $0400 bis $b700 an und erhalten somit $b300 Bytes freien Basic-Speicher. Das EhBasic selbst wird nach b700 geladen, also direkt vor das ROM.&lt;/p>
&lt;p>Wir laden das Basic erneut, es erscheint die Cold-Start Meldung. Wir drücken &amp;lsquo;c&amp;rsquo; und geben den verfügbaren Speicher mit $b300 an. Das Basic initialisiert und wir können endlich loslegen&amp;hellip;&lt;/p>
&lt;p>&lt;img src="images/foto.jpg" alt="foto">&lt;/p>
&lt;p>Bei dem hier gezeigten Bild manipulieren wir die Rahmenfarbe des Video-Chips mittels einer einfachen Schleife und Basic-POKE. Das funktioniert sogar, obwohl der VDP ja diese eigenartige Adressierung der Register und der Daten hat. In dem Fall geht das gerade, weil Zwischendurch keine Zeichenausgabe erfolgt. Glück gehabt&amp;hellip;&lt;/p></content></item><item><title>FanTASTische Reise II</title><link>https://www.steckschwein.de/post/fantastische-reise-ii/</link><pubDate>Tue, 22 Sep 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/fantastische-reise-ii/</guid><description>Vor einer Weile haben wir im Beitrag /index.php/2014/12/15/eine-fantastische-reise/ den Weg zu unserem aktuellen Tastaturcontroller beschrieben.
Wer nicht nochmal nachlesen möchte: Ein ATmega8 dient als SPI Slave als Interface zwischen PS/2-Protokoll, Tastaturmapping und Puffer. Als Basis dient eine angepasste Version des Codes aus AVR Application Note 313, die als Ausgabeschnittstelle den USART des ATmega8 vorsieht. Dies haben wir durch das SPI-Interface des AVR ersetzt.
Steckschwein-Seitig haben wir die Tastaturabfrage immer im Blank-Interrupt des Videochips vorgenommen, genauer gesagt, jeden zweiten Blank.</description><content>&lt;p>Vor einer Weile haben wir im Beitrag &lt;a href="https://www.steckschwein.de/index.php/2014/12/15/eine-fantastische-reise/">/index.php/2014/12/15/eine-fantastische-reise/&lt;/a> den Weg zu unserem aktuellen Tastaturcontroller beschrieben.&lt;/p>
&lt;p>Wer nicht nochmal nachlesen möchte: Ein ATmega8 dient als SPI Slave als Interface zwischen PS/2-Protokoll, Tastaturmapping und Puffer. Als Basis dient eine angepasste Version des Codes aus AVR Application Note 313, die als Ausgabeschnittstelle den USART des ATmega8 vorsieht. Dies haben wir durch das SPI-Interface des AVR ersetzt.&lt;/p>
&lt;p>Steckschwein-Seitig haben wir die Tastaturabfrage immer im Blank-Interrupt des Videochips vorgenommen, genauer gesagt, jeden zweiten Blank. Damit wurde der AVR auf SPI-Seite relativ wenig gestresst.&lt;/p>
&lt;p>Eigentlich aber wollen wir nur eine Tastaturabfrage durchführen, wenn wir auch tatsächlich etwas vom User erwarten. Also raus mit der Abfrage aus der IRQ-Routine und das SPI-Interface des AVR gepollt, bis es etwas anderes als $00 liefert. Hierbei trat ein altes Problem wieder zutage, nämlich das sporadisch Tastendrücke &amp;ldquo;verlorengehen&amp;rdquo;. Die ATmega8-Firmware bedarf also noch weiterer Betrachtung.&lt;/p>
&lt;p>Der Code aus Appnote 313 funktioniert grob so, dass die CLK-Leitung des PS/2-Interfaces einen Interrupt triggert. Hat diese 11 Bit(Startbit, 8 Datenbits, Paritätsbit, Stopbit) empfangen, wird noch in der ISR-Routine die Decodierung der Scancodes zu einem ASCII-Wert aufgerufen und dieser im Puffer abgelegt. Dieser ASCII-Wert wird gepuffert und über den USART per rs232 ausgegeben. Unser Ansatz war, den USART-Teil durch einen SPI-Slave zu ersetzen. Dies haben wir 1:1 getan, sodass der SPI-Slave immer nur an einer bestimmten Stelle innerhalb der main()-Schleife bedient wurde.&lt;/p>
&lt;p>Erschwerend kommt hinzu, dass der INT0-Interrupt nach erfolgreicher Übertragung eines kompletten Bytes direkt die Dekodierung vorgenommen hat. Diese beinhaltet einen relativ teuren Lookup des Scancodes aus einer Tabelle im NVRAM.&lt;/p>
&lt;p>Zunächst also haben wir dies entkoppelt, indem wir einen weiteren Puffer für die Scancodes implementiert haben. Der INT0-Interrupt nimmt also nur noch die Scancodes der Tastatur entgegen und stopft sie in einen Puffer. Das Dekodieren der Scancodes haben wir in die Hauptschleife verlegt, denn dieser Vorgang ist nicht zeitkritisch und kann problemlos durch Interrupts unterbrochen werden. Das Ergebnis der Dekodierung landet wie gehabt im Tastaturpuffer.&lt;/p>
&lt;p>Nun ist es so, das ein SPI-Slave nicht wissen kann, wann der Master einen Transfer initiiert. Ergo muss der Slave jederzeit übertragungsbereit sein. Durch ein Bedienen des SPI-Datenregisters SPDR und Warten (polling) auf einen Zustandswechsel des SPI-Interrupt-Flags kann diese Anforderung nicht erfüllt werden. Also müssen wie die SPI-Schnittstelle auch über Interrupt bedienen. Die SPI-ISR-Routine holt also jetzt jedesmal das aktuelle Zeichen oder eben &amp;ldquo;0&amp;rdquo; aus dem Puffer und legt den Wert ins SPI-Datenegister.&lt;/p>
&lt;p>Jetzt gehen auch beim direkten Polling keine Tastendrücke mehr verloren. Nach einigen Optimierungen im Code konnte auch die Taktfrequenz des AVR-Controllers von 8MHz auf 4MHz heruntergesetzt werden.&lt;/p>
&lt;p>Als nächstes wollen wir dem Tastaturcontroller beibringen, wie man Daten zu Tastatur sendet, um etwa die Wiederholrate zu konfigurieren oder die LEDs anzusteuern (Num Lock, Caps Lock, etc.).&lt;/p></content></item><item><title>CPU-Board</title><link>https://www.steckschwein.de/cpuramdecoder/</link><pubDate>Tue, 15 Sep 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/cpuramdecoder/</guid><description>The CPU boards carries the main CPU 65c02, 64k RAM organized in two 32k * 8 SRAM chips (62256). We decided to use SRAM just because it&amp;rsquo;s much simpler to use than DRAM as we do not need a DRAM conroller. Also, small SRAM chips are also pretty easy to come by and also rather cheap. The ROM is a 28c256 EEPROM, which is banked in at $e000 in 8k steps.</description><content>&lt;p>The CPU boards carries the main CPU 65c02, 64k RAM organized in two 32k * 8 SRAM chips (62256). We decided to use SRAM just because it&amp;rsquo;s much simpler to use than DRAM as we do not need a DRAM conroller. Also, small SRAM chips are also pretty easy to come by and also rather cheap. The ROM is a 28c256 EEPROM, which is banked in at $e000 in 8k steps. Also, clock generation and reset circuit also reside on the CPU board. The latter one could of course be much simpler since a simple RC circuit would have sufficed. But we decided to replicate the NE555 based reset circuit used by commodore in the PET series as a little hommage.&lt;/p>
&lt;p>&lt;img src="images/cpu_mem_rdy.png" alt="CPU Memory Board"> CPU/memory board&lt;/p>
&lt;p>&lt;img src="images/decoder.png" alt="address decoder"> address decoder and /RDY generator&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="address-decoding">Address decoding&lt;/h2>
&lt;p>The adress decoder logic is the glue that holds everything together as it takes care of mapping all components into their respective areas within the 65c02&amp;rsquo;s address space by decoding the upper 12bit of the adress bus. The decoding logic itself is accommodated in a GAL22V10&lt;/p>
&lt;pre tabindex="0">&lt;code>GAL22V10
-------\___/-------
A15 | 1 24 | VCC
| |
A14 | 2 23 | CSIO - /ENABLE for a 74HCT139 providing additional 4 io-enable pins at $0240-$0270
| |
A13 | 3 22 | MEMCTL - /CS &amp;#34;Memory Mapping Control-Latch&amp;#34; at $0230
| |
A12 | 4 21 | CSVDP - /CS VDP V9958 at $0220
| |
A11 | 5 20 | CSVIA - /CS VIA 65c22 at $0210
| |
A10 | 6 19 | CSUART - /CS UART 16550 at $0200
| |
A9 | 7 18 | CSHIRAM - /CS upper SRAM 62256 at $8000-$DFFF($FFFF)
| |
A8 | 8 17 | CSLORAM - /CS lower SRAM 62256 at $0000-$7FFF
| |
A7 | 9 16 | CSROM - /CS ROM at $E000-$FFFF
| |
A6 | 10 15 | ROMOFF - If H, ROM at $E000-$FFFF is banked out to make the underlying RAM accessible
| | Is controlled via bit 0 of the &amp;#34;Memory Mapping Control-Latch&amp;#34;
A5 | 11 14 | RW
| |
GND | 12 13 | A4
-------------------
&lt;/code>&lt;/pre>&lt;p>This way, we can assign memory areas as small as 16 byte, which comes in handy for IO devices. Additionally, the r/W pin and a custom pin &amp;ldquo;ROMOFF&amp;rdquo; are being decoded to provide some runtime controll over the memory mapping. Write accesses to the ROM-area $E000-$FFFF will always go to the unterlying RAM. Is ROMOFF high, the ROM will be banked out, and the underlying RAM will be readable. ROMOFF is connected to bit 0 of the &amp;ldquo;Memory Mapping Control Latch&amp;rdquo;, so writing a 1 into $0230 will bank out the ROM, writing a 0 will bank it back in.&lt;/p>
&lt;p>The memory mapping looks like this:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$0000-$00ff&lt;/td>
&lt;td>Zeropage&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0100-$01ff&lt;/td>
&lt;td>Stack&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0200-$02ff&lt;/td>
&lt;td>IO-Area&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0300-$7fff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$8000-$dfff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$e000-$ffff&lt;/td>
&lt;td>ROM/RAM&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The 28C256 EEPROM is 32k * 8, and we only bank in 8k. To make the whole EEPROM accessible, A13 and A14 of the EEPROM are connected to bits 1 and 2 of the latch. This way, the 32k ROM is divided into 4 banks of 8k each, which are selectable during runtime.&lt;/p>
&lt;h2 id="waitstate-generation">Waitstate generation&lt;/h2>
&lt;p>The Steckschwein runs at 8MHz, and probably more in the future, as the WDC 65c02 is actually rated for 14MHz. Not all components are capable of that bus speed though, so we need to take care about them. The 65c02 has us covered by providing a pin called &amp;ldquo;RDY&amp;rdquo;, which can be used to stop and freeze the CPU at whatever it is doing right now. While accessing slower devices such as the video chip, sound chip and ROM, the Steckschwein halts the CPU for 1 cycle, giving those devices the time they need.&lt;/p>
&lt;p>&lt;img src="images/steckschwein_hw.png" alt="printed board with parts description"> printed board with parts description&lt;/p>
&lt;p>&lt;a href="https://www.steckschwein.de/steckschwein.pdf">PDF&lt;/a>&lt;/p></content></item><item><title>Ein Spiel entsteht...</title><link>https://www.steckschwein.de/post/ein-spiel-entsteht/</link><pubDate>Fri, 11 Sep 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/ein-spiel-entsteht/</guid><description>Im Chrome Browser gibt es einen netten Zeitvertreib in Form des Games &amp;ldquo;Dinosaur&amp;rdquo;. Das Spiel wird immer dann eingeblendet, wenn keine Internet-Verbindung verfügbar ist. Das Spiel ist sehr einfach aufgebaut, kann aber leicht süchtig machen und ist ein netter Zeitvertreib bis die Verbindung wieder verfügbar ist. Genau diese Einfachheit der Grafik und des Gameplays brachte mich auf die Idee das Spiel für das Steckschwein umzusetzen. Wie ich dabei vorgegangen bin, möchte ich Euch hier schildern.</description><content>&lt;p>Im Chrome Browser gibt es einen netten Zeitvertreib in Form des Games &amp;ldquo;Dinosaur&amp;rdquo;. Das Spiel wird immer dann eingeblendet, wenn keine Internet-Verbindung verfügbar ist. Das Spiel ist sehr einfach aufgebaut, kann aber leicht süchtig machen und ist ein netter Zeitvertreib bis die Verbindung wieder verfügbar ist. Genau diese Einfachheit der Grafik und des Gameplays brachte mich auf die Idee das Spiel für das Steckschwein umzusetzen. Wie ich dabei vorgegangen bin, möchte ich Euch hier schildern.&lt;/p>
&lt;p> 
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/0BUbUgMIjIY" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;/p>
&lt;h3 id="vorbereitung">Vorbereitung&lt;/h3>
&lt;p>Zunächst habe ich einige Zeit mit &amp;ldquo;zocken&amp;rdquo; verbracht, um das Gameplay genau zu studieren.&lt;/p>
&lt;h3 id="grafik">Grafik&lt;/h3>
&lt;p>Die Grafik habe ich direkt aus dem Spiel genommen. Was heißt das? Nichts besonderes, ich habe Screenshots gemacht, die Grafik vergrößert, den Farbraum reduziert und die Feinheiten mit einem IconMaker-Tool bearbeitet. Wichtig war mir, dass ich die Assets im Bild-Format XPM speichern konnte.&lt;/p>
&lt;p>So habe ich nach und nach, den Dino, die Kakteen, den Hintergrund und die Wolken in XPM gegossen. Vielleicht etwas umständlich, da die Sprites auch direkt auf &lt;a href="https://chromium.googlesource.com/chromium/src.git/">https://chromium.googlesource.com/chromium/src.git/&lt;/a> verfügbar sind.&lt;/p>
&lt;p>Nimmt man die Sprites in Originalgröße wird der Dino auf dem TMS9918/29 riesig sein, denn wir haben ja nut 192 Pixel vertikal zur Verfügung. Ich habe die Grafik daher entsprechend skaliert, damit diese für das Steckschwein eine sinnvolle Größe hat.&lt;/p>
&lt;p>Mit dem Icon-Tool ging das wunderbar und ich habe so entsprechende xpm-Dateien für die Grafik erstellt. Diese konnte ich dann leicht mittels ein paar einfacher Shell-Befehle in eine Acme-Assembler Source-Datei konvertieren. Die Grafik steht also zur Verfügung.&lt;/p>
&lt;p>Für den Dino werden Sprites verwendet, es kommen dabei 2x2 Sprites mit 16x16px zum Einsatz.&lt;/p>
&lt;p>Die vorbeiziehenden Wolken werden ebenfalls mit Sprites realisiert, wobei jede Wolke aus 2 Sprites nebeneinander liegenden Sprites besteht. Die Wolken werden mit 1px/frame bewegt.&lt;/p>
&lt;p>Jetzt fehlt noch der Hintergrund, also die Wüste, Berge und natürlich die Hindernisse in Form der Kakteen.&lt;/p>
&lt;p>Mit Sprites kann man den Hintergrund auch nicht realisieren, da man mit 4 Sprites keinen ganzen Bildschirm voll bekommt. Es sind ja nur 4 Sprites pro Scanline erlaubt.&lt;/p>
&lt;p>Daher kann es nur Cursor-Grafik sein. Damit das ganze aber &amp;ldquo;smooth&amp;rdquo; scrollt muss man sich was überlegen.&lt;/p>
&lt;h3 id="soft-scrolling">Soft-Scrolling&lt;/h3>
&lt;p>Das größte Problem beim TMS9918/TMS9929 ist, dass dieser kein Soft-Scrolling für Cursor-Grafik (mode1/mode2) unterstützt. Damit das ganze also &amp;ldquo;smooth&amp;rdquo; scrollt müsste man pro Frame ein Zeichen verschieben. Bei 50Hz (PAL) Steckschwein, sind das 400 Pixel pro Sekunde. Das ist viel zu schnell und nicht spielbar!&lt;/p>
&lt;p>Nach ein paar Tests habe ich mich für 4px/frame entschieden, dass sind 200 Pixel pro Sekunde und damit gut 3/4 des Screens. Das ist nahezu optimal und macht das Game spannend.&lt;/p>
&lt;p>Aber wie kann ich jetzt 4 Pixel Soft-Scrolling realisieren?&lt;/p>
&lt;p>Für das 4px Soft-Scrolling werden 2 Paletten der Cursor-Grafik erstellt, wobei bei einer Palette die Grafik um exakt 4 Pixel nach links versetzt ist. Nach dem 1. Frame schalte ich einfach die 2. Palette ein. Das passiert über Video-Register 4 des TMS9929.&lt;/p>
&lt;p>lda #(.A_GX_PAT_2 / $800) ;VRAM-Adresse schreiben sta a_vreg&lt;/p>
&lt;p>lda #$84               ;Gfx-Register 4 -&amp;gt; $80 für write, 4 für 4. Registersta a_vreg&lt;/p>
&lt;p>Nach dem 2. Frame schalte ich wieder auf die 1. Palette und anschließend kopiere ich die Zeichen auf dem Bildschirm um eine Cursor-Position (8px) nach links. So erhält man ein butterweiches 4px/frame Scrolling, womit man arbeiten kann. Will man 3px/frame soft scrollen wird&amp;rsquo;s schon eklig, da man hier 7 Paletten benötigt. Man würde ja eine Palette benötigen die 3px verschoben ist, dann eine mit 6px, dann eine mit 9px was also eine Palette mit 1px Versatz entspricht, denn die 8px werden umkopiert. Dann eine mit 4px - die haben wir ja schon - usw&amp;hellip; 2px/frame ist wieder einfach, da braucht man wieder &amp;ldquo;nur&amp;rdquo; 4 Paletten ;)&lt;/p>
&lt;h3 id="steuerung">Steuerung&lt;/h3>
&lt;p>Gespielt wird über Joystick in Port 2, der Code dafür die Abfrage ist einfach.&lt;/p>
&lt;p>lda #PORT_SEL_2 ;port 2, Joystick-Port 2 einschalten sta via1porta lda via1porta ;Port lesen und entsprechend vergleichen and #JOY_UP&lt;/p>
&lt;p>Mit Joystick nach oben springt der Dino, mit Joystick nach unten duckt sich dieser ab. Der jeweilige Zustand des Dinos wird in einem ZP-Speicherplatz abgelegt und darauf reagiert dann die Animations-Routine.&lt;/p>
&lt;p>In dieser wird auf den Status reagiert und die Sprite-Pointers des Dinos entsprechend verändert.&lt;/p>
&lt;h3 id="gameplay">Gameplay&lt;/h3>
&lt;p>Nach starten des Spiels mit &amp;ldquo;Feuer&amp;rdquo; gehts also los, der Dino wird animiert, dabei werden alle paar Frames die Sprite-Pointer des Dinos geändert. Dadurch entsteht der Eindruck wie im Original, das der Dino durch die Wüste rennt.&lt;/p>
&lt;p>Das Scrolling erfolgt wie oben beschrieben, nach jedem 2. Frame sind genau 8 Pixel nach links verschoben. Am rechten Rand entsteht eine Lücke. Hier kommt der Level-Generator zum Einsatz.&lt;/p>
&lt;p>Der Level-Generator geht eine konfigurierte Liste von 0 und 1 durch. Eine 0 in der Liste bedeutet, es soll eine Wüste- oder Berg-Gruppe ausgegeben werden. Eine 1 bedeutet, es soll eine Kakteen-Gruppe ausgegeben werden. Die Auswahl ob Wüsten- oder Berg-Gruppe erfolgt per Zufall. Die Ausgabe einer der 4 Kakteen-Gruppen erfolgt ebenfalls per Zufall.&lt;/p>
&lt;p>Per Zufall wird lediglich der Offset berechnet, womit dann aus einer Adresstabelle die einzelnen Hintergrund-Gruppen selektiert werden kann. Da jede Hintergrund-Gruppe unterschiedlich lang sein kann, ist das 1. Byte reserviert und gibt die &amp;ldquo;Skript&amp;rdquo;-Länge an.&lt;/p>
&lt;h3 id="scoreboard">Scoreboard&lt;/h3>
&lt;p>Das Scoreboard besteht wie im Original aus dem 5-stelligen Highscore und dem aktuellem Score des Spiels.&lt;/p>
&lt;p>Der aktuelle Score wird alle 5 Frames erhöht, so dass man nach 1 Sekunde spielen 10 Punkte/Meter zurückgelegt hat. Es werden 3 Byte pro Score verwendet.&lt;/p>
&lt;p>sed                ;add in decimal mode
lda .score_value+2
clc
adc #$01
sta .score_value+2
bcc +
adc .score_value+1
sta .score_value+1
bcc +
adc .score_value
sta .score_value&lt;/p>
&lt;ul>
&lt;li>cld&lt;/li>
&lt;/ul>
&lt;h3 id="gezählt-wird-einfach-im-bcd-mode-des-65c02-unter-berücksichtigung-des-übertrags">Gezählt wird einfach im BCD-Mode des 65c02 unter Berücksichtigung des Übertrags.&lt;/h3>
&lt;h3 id="die-ausgabe-erfolgt-des-score-erfolgt-über-abbilden-des-dezimalwertes-jeder-stelle-auf-numerische-zeichen-der-ascii-tabelle-da-ich-beim-scrolling-permanent-die-palette-umschalte-liegt-der-zeichensatz-quasi-in-jeder-palette-vor-hier-natürlich-ohne-verschiebung-der-pixel">Die Ausgabe erfolgt des Score erfolgt über Abbilden des Dezimalwertes jeder Stelle auf numerische Zeichen der ASCII-Tabelle. Da ich beim Scrolling permanent die Palette umschalte liegt der Zeichensatz quasi in jeder Palette vor, hier natürlich ohne Verschiebung der Pixel!&lt;/h3>
&lt;p>lda .score_value
jsr .digit_out
&amp;hellip;
.digit_out
and #$0f
ora #&amp;lsquo;0&amp;rsquo;
sta a_vram
rts&lt;/p>
&lt;h3 id="wie-gehts-weiter">Wie gehts weiter?&lt;/h3>
&lt;p>Nach dem Update meines Chromes, gab es plötzlich auch einen Pterodactylus der mir im Chrome nach einiger Zeit spielen entgegen geflogen kam. Das hab ich vorher noch nicht gehabt, muss also mit dem letzten Update zu tun gehabt haben. Ich bin dran&amp;hellip;&lt;/p></content></item><item><title>Mehr Karten (UPDATE)</title><link>https://www.steckschwein.de/post/mehr-karten-update/</link><pubDate>Fri, 24 Jul 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/mehr-karten-update/</guid><description>Unser &amp;ldquo;Standard&amp;rdquo;-Massenspeicher SD-Karte funktioniert zwar an und für sehr gut, Sorgenkind war aber immer die Initialisierungs-Routine. Bisher ließen sich damit nur günstige Class4-Karten initialisieren, bei &amp;ldquo;höherwertigen&amp;rdquo; Karten schlug die Initialisierung immer fehl, sodass nur etwa 3 von 5 Karten nutzbar waren.
Das hat uns schon etwas gewurmt, denn irgendwie hatte dieser Stand ein Geschmäckle von &amp;ldquo;Funktioniert aus Versehen&amp;rdquo;. Also mussten wir da nochmal ran. Der Initialisierungs-Flow entspricht im Wesentlichen dem, was auf der bekannten Seite http://elm-chan.</description><content>&lt;p>Unser &amp;ldquo;Standard&amp;rdquo;-Massenspeicher SD-Karte funktioniert zwar an und für sehr gut, Sorgenkind war aber immer die Initialisierungs-Routine. Bisher ließen sich damit nur günstige Class4-Karten initialisieren, bei &amp;ldquo;höherwertigen&amp;rdquo; Karten schlug die Initialisierung immer fehl, sodass nur etwa 3 von 5 Karten nutzbar waren.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Das hat uns schon etwas gewurmt, denn irgendwie hatte dieser Stand ein Geschmäckle von &amp;ldquo;Funktioniert aus Versehen&amp;rdquo;. Also mussten wir da nochmal ran. Der Initialisierungs-Flow entspricht im Wesentlichen dem, was auf der bekannten Seite &lt;a href="http://elm-chan.org/docs/mmc/mmc_e.html">http://elm-chan.org/docs/mmc/mmc_e.html&lt;/a> dokumentiert ist. In den letzten Tagen haben wir diesen unter die Lupe genommen, und tatsächlich ist etwas aufgefallen. Vor dem Senden eines Kommandos muss sichergestellt werden, dass die Karte bereit ist. Hierzu sendet man solange $ff an die Karte, bis diese auch $ff zurücksendet. Dann ist die Karte bereit, ein Kommando zu empfangen. In unserer Initialisierungsroutine wurde dies zwischen CMD55 und ACMD41 (näheres bitte dem Link entnehmen) schlichtweg nicht gemacht. Plötzlich lassen sich fast alle vorhandenen Karten initialisieren. Dass dies mit den Class4-Karten trotzdem funktionierte, war also gewissermaßen tatsächlich aus Versehen.&lt;/p>
&lt;p>Das nächste Problem war dann, dass von den jetzt nutzbaren Karten über die Shell zwar im Filesystem navigiert und Verzeichnisse aufgelistet werden konnten, das eigentliche Laden von Dateien bzw. Starten von Programmen funktionierte nicht. Die Blockleseroutinen liefen korrekt durch, die geladenen Daten jedoch waren fehlerhaft. Dass die Dateisystemoperationen funktioniert haben, und nur das Einlesen von Dateien Probleme machte, war verdächtig. &lt;a href="http://wordpress.steckschwein.de/wordpress/index.php/2015/05/20/filesystem-und-shell/">Noch im Mai verkündeten wir&lt;/a> u.a. stolz, dass wir zum Dateien lesen schnelle SD-Multiblock-Transfers verwenden. Diese haben den Vorteil, dass man der Karte nur die Adresse des ersten zu lesenden Blocks übermittelt, und dann einfach liest bis der Arzt kommt oder man der Karte sagt, dass man fertig ist. Vorteil ist, dass man die Blockadresse des nächsten Blocks nicht immer selber ausrechnen muss (immerhin eine 32bit-Addition) und auch nicht immer wieder an die Karte schicken muss.&lt;/p>
&lt;p>Gut, also die fat_read-Routine zurückgebaut, und schon ist das Steckschwein mit so ziemlich jeder handelsüblichen SD-Karte kompatibel.&lt;/p>
&lt;p>&lt;strong>[UPDATE:]&lt;/strong> Mittlerweile funktionieren auch wieder Multiblock-Transfers. Der Trick war, beim Lesen von der Karte die MOSI-Leitung nicht auf L, sondern auf H zu setzen, also nicht mehr $00 zu senden, sondern $ff. Die Idee kam, nachdem sämtliche Beispiele, die sich im Web finden lassen, $ff senden. Die Stelle in der SD-Karten-Spezifikation, in der das so spezifiziert ist, ist bis dato nicht gefunden worden.&lt;/p></content></item><item><title>Schweinebauchanzeige</title><link>https://www.steckschwein.de/post/schweinebauchanzeige/</link><pubDate>Fri, 24 Jul 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/schweinebauchanzeige/</guid><description>Als Abfallprodukt der letzten Debugging-Session bezüglich SD-Karten und dessen, was von ihnen gelesen wird, hat die Shell ein kleines Hexdump-Feature bekommen, mit dem sich Speicherinhalte ähnlich wie beim &amp;ldquo;M&amp;rdquo;-Kommando bei diversen Maschinensprachemonitoren ausgeben lassen.
Die Handhabung ist entsprechend bekannt: &amp;ldquo;dump &amp;ldquo;, abgebrochen werden kann mit Ctrl-C. Als Abfallprodukt hiervon gilt das jetzt auch für Directory-Listings.
Damit hat die SteckShell nunmehr die Versionsnummer 0.10.</description><content>&lt;p>Als Abfallprodukt der letzten Debugging-Session bezüglich SD-Karten und dessen, was von ihnen gelesen wird, hat die Shell ein kleines Hexdump-Feature bekommen, mit dem sich Speicherinhalte ähnlich wie beim &amp;ldquo;M&amp;rdquo;-Kommando bei diversen Maschinensprachemonitoren ausgeben lassen.&lt;/p>
&lt;p>Die Handhabung ist entsprechend bekannt: &amp;ldquo;dump &amp;ldquo;, abgebrochen werden kann mit Ctrl-C. Als Abfallprodukt hiervon gilt das jetzt auch für Directory-Listings.&lt;/p>
&lt;p>Damit hat die SteckShell nunmehr die Versionsnummer 0.10.&lt;/p>
&lt;p>&lt;img src="images/dsc_0123.jpg" alt="Schweinebauchanzeige">&lt;/p></content></item><item><title>WDC und kein Ende</title><link>https://www.steckschwein.de/post/wdc-und-kein-ende/</link><pubDate>Fri, 26 Jun 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/wdc-und-kein-ende/</guid><description>In der letzten Zeit war es hier etwas still ums Steckschwein, was aber nicht als Indiz für Untätigkeit gelten soll. Hauptsächlich haben wir uns auf das Schreiben von Code konzentriert, die Shell wurde weiterentwickelt, etc. Darüberhinaus gab es erste Experimente mit CPLDs. Auf dieser Basis sollen ja zukünftige Verbesserungen der Hardware entstehen, begonnen bei einem eigenständigen SPI-Controller bis hin zur Zusammenfassung der bestehenden Glue-Logik rund um die Adressdekodierung. Da ich mir zu diesem Zweck testhalber solche CPLD-Entwicklungsplatinchen auf Basis des XilinX XC9572XL habe kommen lassen, stellte sich also als erstes die Frage, wie sich dessen 3.</description><content>&lt;p>In der letzten Zeit war es hier etwas still ums Steckschwein, was aber nicht als Indiz für Untätigkeit gelten soll. Hauptsächlich haben wir uns auf das Schreiben von Code konzentriert, die Shell wurde weiterentwickelt, etc. Darüberhinaus gab es erste Experimente mit CPLDs. Auf dieser Basis sollen ja zukünftige Verbesserungen der Hardware entstehen, begonnen bei einem eigenständigen SPI-Controller bis hin zur Zusammenfassung der bestehenden Glue-Logik rund um die Adressdekodierung. Da ich mir zu diesem Zweck testhalber solche &lt;a href="http://www.seeedstudio.com/depot/xc9572xl-cpld-development-board-p-799.html">CPLD-Entwicklungsplatinchen auf Basis des XilinX XC9572XL&lt;/a> habe kommen lassen, stellte sich also als erstes die Frage, wie sich dessen 3.3V-basierte Logik mit dem 5V-Steckschwein vertragen würde. Zum CPLD hin wären ja keine Probleme zu erwarten, denn die IO-Pins des XC9572XL sind 5V-tolerant. Die Richtung vom CPLD zum Steckschwein bedarf also besonderer Betrachtung, denn es muss sichergestellt werden, dass alle Bausteine am Bus, die mit dem CPLD verbunden sind, dessen 3.3V-Logikpegel zuverlässig erkennen. Als einzige wirklich problematische Komponente stellte sich hier - &lt;a href="https://www.steckschwein.de/post/murphy-iii-timing-ist-alles/">wieder mal&lt;/a> - der auf meinem Steckschwein eingesetzte (Marko nutzt einen 65c02 von Rockwell) WDC 65c02 heraus. Das Datenblatt gibt als &amp;ldquo;Input High Voltage&amp;rdquo;, also die Spannung, ab der auf der entsprechenden Leitung (BE, D0 -D7, RDY, /SO, /IRQ, /NMI, PHI2, /RES) eine logische 1 erkannt wird, mit &amp;ldquo;VDD*0.7&amp;rdquo; an. Bei einer Betriebsspannung von 5V also 3,5V. Mit 3.3V-Pegeln also schonmal nicht kompatibel. Geschweige denn mit TTL-Pegeln. Die leider so ziemlich alle auf dem Datenbus liegenden Bausteine verwenden, mit Ausnahme der WDC 65c22 VIA.  Alle anderen Bausteine geben im Datenblatt als &amp;ldquo;High Level Output Voltage&amp;rdquo; Werte von 2.4-2.7V an.  Kann also gar nicht passen. Dass das Steckschwein trotzdem mit dem WDC funktioniert ist ganz offenbar Glück bzw. der Tatsache geschuldet, dass der Chip dann doch toleranter ist als das Datenblatt uns glauben machen will.  Trotzdem nicht sauber. In zukünftigen Revisionen müssen wir also zwischen CPU und Datenbus einen 74HCT245-Buffer eindesignen, der durch TTL-kompatible Eingänge und CMOS-Ausgänge die Pegelunterschiede ausbügelt. Gleiches gilt auch für weitere Experimente mit dem 3.3V-CPLD. Oder auch mit dessen 5V-Vorgänger XC9572.  Zusammenfassend also noch einmal die Besonderheiten des 65c02 von WDC:&lt;/p>
&lt;ol>
&lt;li>Unterschiede im Pinout Pin1 beim WDC ist nicht mehr GND, sondern der Ausgang /VP (Vector Pull), der low wird, wenn die CPU an einen Vektor springt (IRQ, NMI, RESET) Pin 36 ist nur bei WDC /BE, sonst N.C. Dieser muss auf High liegen, sonst ist die CPU vom Bus abgekoppelt. Statt Takt an PHI0 anzulegen und den Rest des Systems mit PHI2 zu takten, wird bei WDC vorgeschrieben, CPU und restliches System mit dem an PHI0 angeschlossenen Oszillator zu takten&lt;/li>
&lt;li>Strafferes Timing Die wesentlich schnelleren WDC-Chips haben wesentlich kürzere Setup/Hold-Zeiten (10ns statt 30ns bei Rockwell)&lt;/li>
&lt;li>Nicht TTL-kompatibel Der WDC 65c02 erwartet wesentlich höhere Signalpegel, die entschieden über den TTL-Pegeln liegen. Dies hat auch &lt;a href="http://lc64.blogspot.de/2015/04/problems-with-wdc-w65c02.html">MrVossi bei der Entwicklung seines LC64&lt;/a> schon festgestellt. Bei ihm hat es sich allerdings deutlicher geäußert.&lt;/li>
&lt;/ol>
&lt;p>Die aktuelle Steckschwein-Revision ist somit trotz aller Bemühungen (Jumper für Takteingang, /BE, /VP) immer noch nicht mit dem WDC 65c02 kompatibel.  Im &lt;a href="https://www.steckschwein.de/post/murphy-iii-timing-ist-alles/">Beitrag über das erste WDC-Abenteuer&lt;/a> hatte ich abschließend die Frage gestellt, wie man dann einen 65(c)02 in einem vorhandenen alten System mit einem WDC 65c02 ersetzen soll. Die wäre damit dann zumindest beantwortet: &lt;strong>überhaupt nicht!&lt;/strong>&lt;/p></content></item><item><title>Filesystem und Shell</title><link>https://www.steckschwein.de/post/filesystem-und-shell/</link><pubDate>Wed, 20 May 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/filesystem-und-shell/</guid><description>Vor kurzem haben wir ja schon von ersten Gehversuchen einer FAT32-Implementation berichtet, mit der wir in der Lage waren, beim Systemstart eine Datei von SD-Karte zu laden.
Was fehlt, ist eine Möglichkeit, innerhalb eines Filesystems einer SD-Karte zu navigieren, Programme zu laden oder Dateien anzuzeigen. Um diese Lücke zu füllen, ist die SteckShell entstanden. In der aktuellen Version 0.6 unterstützt die Shell folgende Funktionen:
Directory auflisten Directory wechseln Programm laden und starten Datei anzeigen Grafik (TMS9929-Rohdaten) anzeigen Wer auf dem VCFe 16.</description><content>&lt;p>&lt;a href="http://wordpress.steckschwein.de/wordpress/index.php/2015/01/05/bootschwein/">Vor kurzem&lt;/a> haben wir ja schon von ersten Gehversuchen einer FAT32-Implementation berichtet, mit der wir in der Lage waren, beim Systemstart eine Datei von SD-Karte zu laden.&lt;/p>
&lt;p>Was fehlt, ist eine Möglichkeit, innerhalb eines Filesystems einer SD-Karte zu navigieren, Programme zu laden oder Dateien anzuzeigen. Um diese Lücke zu füllen, ist die SteckShell entstanden. In der aktuellen Version 0.6 unterstützt die Shell folgende Funktionen:&lt;/p>
&lt;ul>
&lt;li>Directory auflisten&lt;/li>
&lt;li>Directory wechseln&lt;/li>
&lt;li>Programm laden und starten&lt;/li>
&lt;li>Datei anzeigen&lt;/li>
&lt;li>Grafik (TMS9929-Rohdaten) anzeigen&lt;/li>
&lt;/ul>
&lt;p>Wer auf dem VCFe 16.0 anwesend war konnte diese Shell auch in Aktion erleben.&lt;/p>
&lt;p>Dank Marko unterstützt die Shell inzwischen sogar den 40-Zeichen-Modus des TMS99xx!&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Die Shell liegt nicht im ROM, sondern wird entweder seriell aufs Steckschwein geladen oder mit dem beschriebenen boot-Mechanismus von SD-Karte gestartet.&lt;/p>
&lt;p>Mit ihr fühlt sich das Steckschwein schon wie ein &amp;ldquo;richtiger&amp;rdquo; Computer an, denn jetzt ist eine interaktive Bedienung möglich.&lt;/p>
&lt;p>Die SteckShell dient uns sozusagen als Betriebsystem-Keimzelle, in der u.a. die FAT-Routinen reifen. Hier hat sich seit unserem rudimentären ROM-Bootloader auch einiges getan.&lt;/p>
&lt;p>Die ersten Versuche mit FAT, die auch in den allerersten Versionen der Shell noch Verwendung fanden, bestanden darin, über das Verzeichnis zu iterieren, eine Datei nach Namen oder Attribut zu finden und dann mit ihr etwas zu machen.&lt;/p>
&lt;p>Dieser Ansatz funktioniert jetzt immer noch als ROM-Bootloader, aber für die Shell sind die Anforderungen etwas andere. Man möchte eine Datei vielleicht auch nur erst in den Speicher laden, um dann zu entscheiden, was als nächstes passieren soll. Man möchte evtl. mehrere Dateien geöffnet haben, oder zumindest das aktuelle Verzeichnis und eine Datei geöffnet haben können.&lt;/p>
&lt;p>Ehe man sich versieht, befindet man sich inmitten der gleichen Überlegung, die vor einigen Jahrzehnten schon mal jemand angestellt hat, und sich dann das klassische und bekannte Interface bestehend aus open(), close(), read() usw. ausgedacht hat.&lt;/p>
&lt;p>Also wurde das Ganze in Subroutinen fat_mount, fat_open, etc. aufgedröselt.&lt;/p>
&lt;p>fat_open und fat_close verwalten eine Filedeskriptortabelle.&lt;/p>
&lt;p>fat_open bekommt einen Dateinamen als Argument und sucht diesen im aktuellen Verzeichnis. Der Startcluster und die Größe der gefundenen Datei wird in die Deskriptortabelle geschrieben. Die Adresse dieses Eintrags ist der File-Handle.&lt;/p>
&lt;p>Mit diesem kann nun fat_read die geöffnete Datei in den Speicher einlesen. Dies geschieht bei der Gelegenheit nun per SD-Multiblock-Transfer, sodass ein ganzer Cluster in einem Stück ohne Overhead durch Zwischenberechnungen der Sektornummern eingelesen werden kann.&lt;/p>
&lt;p>Das gesamte &amp;ldquo;Interface&amp;rdquo; hantiert nur mit Clusteradressen, die Berechnung der LBA-Adressen passiert intern.&lt;/p>
&lt;p>Damit haben wir eine für unsere Zwecke erst einmal ausreichende Filesystem-Implementation.&lt;/p>
&lt;p>Aktuell können wir noch keine eigentlichen &amp;ldquo;FAT&amp;rdquo;-Lookups, d.h. wir können nur mit Dateien und Verzeichnissen umgehen, die in einen Cluster passen, was jedoch bei einer Clustergröße von 32k bei einer 4GB-Karte auf einem 8-bit-System keine große Einschränkung darstellt. Spätestens wenn wir so etwas wie seek() und damit sequentiellen Zugriff auf Dateien implementieren werden wir uns auch daran setzen müssen.&lt;/p>
&lt;p>Die Shell verfügt außerdem über die Fähigkeit, die Textkonsole zu scrollen. In diesem Fall allerdings nicht über die Möglichkeiten des VDP, sondern das Textscrolling wird im regulären Arbeitsspeicher durchgeführt und der &amp;ldquo;Bildschirminhalt&amp;rdquo; während des VDP-Blank ins RAM des TMS9929 geschrieben. Dies würde sogar ermöglichen, verschiedene umschaltbare Textkonsolen a la Linux (Alt-F1..n) zu realisieren. Aber über diesen Mechanismus darf sich Marko gerne auslassen.&lt;/p></content></item><item><title>VCFe 16.0 - schon wieder vorbei</title><link>https://www.steckschwein.de/post/vcfe-16-0-schon-wieder-vorbei/</link><pubDate>Sun, 03 May 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/vcfe-16-0-schon-wieder-vorbei/</guid><description>Das VCFe 16.0 ist schon wieder vorbei. Vielen Dank an alle, die vorbeigekommen sind und/oder unsere Vorträge verfolgt haben für ihr Interesse an unserem kleinen Projekt. Besonderer Dank gilt Marco Baye für spontane Patches für den ACME-Crossassembler und Udo Möller für weitere Lektionen im Datenblätter lesen.</description><content>&lt;p>Das VCFe 16.0 ist schon wieder vorbei. Vielen Dank an alle, die vorbeigekommen sind und/oder unsere Vorträge verfolgt haben für ihr Interesse an unserem kleinen Projekt. Besonderer Dank gilt Marco Baye für spontane Patches für den ACME-Crossassembler und Udo Möller für weitere Lektionen im Datenblätter lesen.&lt;/p></content></item><item><title>Das Steckschwein auf dem VCFe 16.0</title><link>https://www.steckschwein.de/post/das-steckschwein-auf-dem-vcfe-16-0/</link><pubDate>Mon, 20 Apr 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/das-steckschwein-auf-dem-vcfe-16-0/</guid><description>Vom 1. bis 3. Mai findet das Vintage Computer Festival Europe zum 16. Mal in München statt. Genau wie letztes Jahr ist auch das Steckschwein-Projekt wieder mit von der Partie.
Wir werden die Platinenversionen sowie den Steckbrett-Urschleim präsentieren. Darüberhinaus wird es unsere aktuellen Fortschritte im Bereich &amp;ldquo;Betriebsystem&amp;rdquo;, Filesystem (SteckShell) sowie Videochip zu sehen geben. Zum den Themen &amp;ldquo;Steckschwein auf Platine&amp;rdquo; und &amp;ldquo;Video-Board&amp;rdquo; sind außerdem Vorträge vorgesehen</description><content>&lt;p>Vom 1. bis 3. Mai findet das Vintage Computer Festival Europe zum 16. Mal in München statt. Genau wie letztes Jahr ist auch das Steckschwein-Projekt wieder mit von der Partie.&lt;/p>
&lt;p>Wir werden die Platinenversionen sowie den Steckbrett-Urschleim präsentieren. Darüberhinaus wird es unsere aktuellen Fortschritte im Bereich &amp;ldquo;Betriebsystem&amp;rdquo;, Filesystem (SteckShell) sowie Videochip zu sehen geben. Zum den Themen &amp;ldquo;Steckschwein auf Platine&amp;rdquo; und &amp;ldquo;Video-Board&amp;rdquo; sind außerdem Vorträge vorgesehen&lt;/p></content></item><item><title>Schachschwein</title><link>https://www.steckschwein.de/post/schachschwein/</link><pubDate>Sat, 21 Mar 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/schachschwein/</guid><description>Nachdem das Grundsystem nun in Form von Platinen vorliegt und Marko dabei ist, das Videoboard zu layouten, ist die Gelegenheit günstig, schon einmal ein wenig vorhandene Software auf das Steckschwein zu portieren. Den Anfang macht MicroChess, 1976 von Peter Jennings für den MOS KIM-1 entwickelt und von Daryl Rictor modifiziert, um über ein serielles Terminal als Ein- /Ausgabestation spielbar zu sein, inklusive der coolen ASCII-Art-Darstellung des Schachbretts.
Dementsprechend einfach war es, es auf dem Steckschwein zum Laufen zu bekommen.</description><content>&lt;p>Nachdem das Grundsystem nun in Form von Platinen vorliegt und Marko dabei ist, das Videoboard zu layouten, ist die Gelegenheit günstig, schon einmal ein wenig vorhandene Software auf das Steckschwein zu portieren. Den Anfang macht &lt;a href="http://benlo.com/microchess/index.html">MicroChess&lt;/a>, 1976 von Peter Jennings für den MOS KIM-1 entwickelt und von &lt;a href="http://www.6502.org/source/games/uchess/uchess.htm">Daryl Rictor modifiziert&lt;/a>, um über ein serielles Terminal als Ein- /Ausgabestation spielbar zu sein, inklusive der coolen ASCII-Art-Darstellung des Schachbretts.&lt;/p>
&lt;p>Dementsprechend einfach war es, es auf dem Steckschwein zum Laufen zu bekommen. Anstatt der vorhandenen Routinen zur Ein-/Ausgabe von Bytes über die 6551 ACIA verwenden wir einfach die UART-Routinen, die unser BIOS ohnehin bereitstellt, zur Ausgabe auf dem Terminal, während als Eingabe die ans Steckschwein angeschlossene PS/2-Tastatur dient.&lt;/p>
&lt;p>&lt;img src="images/screenshot-2b2015-03-21-2b10-43-401.png" alt="screenshot-2b2015-03-21-2b10-43-401">&lt;/p>
&lt;p>Damit läuft auf dem Steckschwein erstmals ein Programm, welches kein Test-/Demoprogramm von uns ist. Weitere werden folgen.&lt;/p>
&lt;p>Um ein wenig KIM-1-Feeling beizubehalten, geben wir die 3 Zahlen, die die Züge beschreiben auch auf dem LCD-Display aus. Damit ließe sich notfalls auch ohne Terminal spielen, sofern ein physikalisches Schachbrett zur Hand ist. Wie in der guten alten Zeit.&lt;/p>
&lt;p>&lt;img src="images/img_20150321_122156.jpg" alt="img_20150321_122156">&lt;/p></content></item><item><title>Schweinebande</title><link>https://www.steckschwein.de/post/schweinebande/</link><pubDate>Mon, 23 Feb 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/schweinebande/</guid><description/><content>&lt;!-- raw HTML omitted --></content></item><item><title>Die Platinen sind da!</title><link>https://www.steckschwein.de/post/die-platinen-sind-da/</link><pubDate>Sat, 21 Feb 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/die-platinen-sind-da/</guid><description>Die Platinen für CPU/Mem, UART und IO sind fertig! Dank Überlieferung sogar jede 2mal, sodass wir gleich 2 Steck^H^H^H^H^HPlatinenschweine aufbauen können.</description><content>&lt;p>Die Platinen für CPU/Mem, UART und IO sind fertig! Dank Überlieferung sogar jede 2mal, sodass wir gleich 2 Steck^H^H^H^H^HPlatinenschweine aufbauen können.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted --></content></item><item><title>Platinen sind da II (UPDATE)</title><link>https://www.steckschwein.de/post/platinen-sind-da-ii-update/</link><pubDate>Sat, 21 Feb 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/platinen-sind-da-ii-update/</guid><description>Damit man mal was sieht!
Die UART-Platine hat noch für einiges Kopfzerbrechen gesorgt, weil sich dann doch noch ein Fehler eingeschlichen hatte. Dieser ließ sich aber durch einen Klecks Lötzinn an der richtigen Stelle korrigieren. Pin25, /ADS hätte noch auf low gezogen werden müssen. Da das von uns in KiCad verwendete Symbol diesen Pin erst gar nicht hatte, war dies im Layout auch nicht drin. Pin war im Schaltplan als &amp;ldquo;nicht verbunden&amp;rdquo; markiert.</description><content>&lt;p>Damit man mal was sieht!&lt;/p>
&lt;p>Die UART-Platine hat noch für einiges Kopfzerbrechen gesorgt, weil sich dann doch noch ein Fehler eingeschlichen hatte. Dieser ließ sich aber durch einen Klecks Lötzinn an der richtigen Stelle korrigieren. Pin25, /ADS hätte noch auf low gezogen werden müssen. Da das von uns in KiCad verwendete Symbol diesen Pin erst gar nicht hatte, war dies im Layout auch nicht drin. Pin war im Schaltplan als &amp;ldquo;nicht verbunden&amp;rdquo; markiert. Menschliches Versagen also. Toll.&lt;/p>
&lt;p>Die CPU/Mem-Platine hingegen lief auf Anhieb.&lt;/p>
&lt;!-- raw HTML omitted --></content></item><item><title>Genug</title><link>https://www.steckschwein.de/post/genug/</link><pubDate>Tue, 10 Feb 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/genug/</guid><description>Es ist ruhig geworden ums Steckschwein. Das liegt daran, dass wir genug haben. Genug von dem Gewackel auf dem Steckbrett, genug von instabilem Monitorbild und anderen diversen Störanfälligkeiten. Wir wollen endlich Code schreiben, und die Bugs dort suchen, und nicht auf dem Steckbrett. Dazu müssen wir unsere Hardware in eine stabilere Form zu bringen. Das bedeutet: Platinen. Zwar noch nicht unser Einplatiner, aber es spricht ja nichts dagegen, die einzelnen Baugruppen auf je eine Platine zu bringen, und diese zu verbinden.</description><content>&lt;p>Es ist ruhig geworden ums Steckschwein. Das liegt daran, dass wir genug haben. Genug von dem Gewackel auf dem Steckbrett, genug von instabilem Monitorbild und anderen diversen Störanfälligkeiten. Wir wollen endlich Code schreiben, und die Bugs dort suchen, und nicht auf dem Steckbrett. Dazu müssen wir unsere Hardware in eine stabilere Form zu bringen. Das bedeutet: Platinen. Zwar noch nicht unser Einplatiner, aber es spricht ja nichts dagegen, die einzelnen Baugruppen auf je eine Platine zu bringen, und diese zu verbinden. So haben wir die Möglichkeit, später einzelne Baugruppen auszutauschen oder neue (Sound!) zu ergänzen. Die Layouts sind gemacht, die Platinen in Produktion, sodass uns aktuell nichts weiter bleibt, als abzuwarten.&lt;/p>
&lt;p>So solls aussehen:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted --></content></item><item><title>Bootschwein</title><link>https://www.steckschwein.de/post/bootschwein/</link><pubDate>Mon, 05 Jan 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/bootschwein/</guid><description>Die Aufgabe, die wir dem (Steck)BIOS zugedacht haben, beschränkt sich darauf, die vorhandene Hardware zu initialisieren, auf eine eingelegte SD-Karte zu prüfen, und dann von dort das eigentliche &amp;ldquo;Betriebssystem&amp;rdquo; zu laden. Fast ein bisschen PC-like.
Hier ist die Überlegung, im Stammverzeichnis eine bestimmte Datei zu finden und an eine bestimmte Adresse in den Speicher zu laden.
Sollte dies fehlschlagen, kann man immer noch in einen Monitor oder unsere bekannte rs232-Uploadroutine springen.</description><content>&lt;p>Die Aufgabe, die wir dem (Steck)BIOS zugedacht haben, beschränkt sich darauf, die vorhandene Hardware zu initialisieren, auf eine eingelegte SD-Karte zu prüfen, und dann von dort das eigentliche &amp;ldquo;Betriebssystem&amp;rdquo; zu laden. Fast ein bisschen PC-like.&lt;/p>
&lt;p>Hier ist die Überlegung, im Stammverzeichnis eine bestimmte Datei zu finden und an eine bestimmte Adresse in den Speicher zu laden.&lt;/p>
&lt;p>Sollte dies fehlschlagen, kann man immer noch in einen Monitor oder unsere bekannte rs232-Uploadroutine springen.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Um nun also eine Datei auf der SD-Karte zu finden, müssen wir erstmal rudimentäre Unterstützung für das FAT-Dateisystem bauen. FAT stammt aus den 70er Jahren und hat als Dateisystem für MS-DOS-basierte Betriebssysteme Verbreitung gefunden. Ursprünglich war es für Disketten gedacht (FAT12), und wurde immer wieder erweitert, um auch wesentlich größere Datenträgerkapazitäten wie z.B. von Festplatten zunächst bis 2GB (FAT16), dann aber auch über diese Begrenzung heraus (FAT32) zu unterstützen.&lt;/p>
&lt;p>Da so ziemlich jede SD-Karte, die man heute kaufen kann, mindestens 2GB Kapazität hat, lassen wir FAT12 und FAT16 außen vor, und konzentrieren uns nur auf FAT32. Hierzu ist sicherlich die &lt;a href="http://msdn.microsoft.com/en-us/windows/hardware/gg463080.aspx">offizielle Dokumentation von Microsoft&lt;/a> eine sinnvolle Lektüre, als wesentlich hilfreicher hat sich aber das auf FAT32 konzentrierte &lt;a href="https://www.pjrc.com/tech/8051/ide/fat32.html">Understanding FAT32 Filesystems von Paul Stoffregen&lt;/a> erwiesen, indem es einen gezielt durch die Strukturen führt, die man für FAT32 tatsächlich braucht.&lt;/p>
&lt;p>Unsere Implementation beschränkt sich darauf, das Stammverzeichnis der ersten Partition zu lesen, bis eine Datei gefunden wird, die das &amp;ldquo;System&amp;rdquo;-Attribut hat. Diese wird eingelesen.&lt;/p>
&lt;p>Hierbei ist das Verfolgen der Clusterketten, also das eigentliche Auswerten der FAT, nicht implementiert, sodass die max. Dateigröße der Größe eines Clusters entspricht. Zum finden und laden dessen, was später mal unser &amp;ldquo;Betriebsystem&amp;rdquo; werden soll, reicht es aber.&lt;/p>
&lt;p>Der rudimentäre Code findet sich in unserem &lt;a href="https://sourceforge.net/p/steckschwein/code/ci/default/tree/fat/">Repository auf Sourceforge&lt;/a>.&lt;/p></content></item><item><title>Das Schwein kann singen...</title><link>https://www.steckschwein.de/post/das-schwein-kann-singen/</link><pubDate>Sun, 04 Jan 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/das-schwein-kann-singen/</guid><description>Das Steckschwein hat nun fast alle notwendigen Komponenten, um mit der Außenwelt zu kommunizieren, aber auch nur fast. Bisher ist es noch stumm, aber das sollte sich heute ändern. Wir haben hier noch ein paar YM3812 Schippse nebst benötigter DAC (YM3014B) rumliegen, also haben wir überlegt dem Schwein einfach das singen beizubringen. Wir wollen Musik und Sounds haben.
Der YM3812 ist ein sehr verbreiteter Chip, der sich auf OPL2 beschränkt, für unsere Zwecke aber völlig ausreichend ist.</description><content>&lt;p>Das Steckschwein hat nun fast alle notwendigen Komponenten, um mit der Außenwelt zu kommunizieren, aber auch nur fast. Bisher ist es noch stumm, aber das sollte sich heute ändern. Wir haben hier noch ein paar YM3812 Schippse nebst benötigter DAC (YM3014B) rumliegen, also haben wir überlegt dem Schwein einfach das singen beizubringen. Wir wollen Musik und Sounds haben.&lt;/p>
&lt;p>Der &lt;a href="http://de.wikipedia.org/wiki/Yamaha_YM3812">YM3812&lt;/a> ist ein sehr verbreiteter Chip, der sich auf OPL2 beschränkt, für unsere Zwecke aber völlig ausreichend ist. Nur wie stellt man das wieder an? Das &lt;a href="http://www.vgmpf.com/Docs/YM3812%20-%20Manual.pdf">Datenblatt&lt;/a> ist ziemlich dünn, reicht aber aus um klar zu machen was wir alles brauchen.&lt;/p>
&lt;ul>
&lt;li>Decoder&lt;/li>
&lt;li>dedizierter Takt, optimalerweise 3,58 Mhz (beknackt)&lt;/li>
&lt;li>DAC (YM3014) der die 16Bit Floating Point des YM3812 in eine Spannung wandelt&lt;/li>
&lt;li>Opamps&lt;/li>
&lt;/ul>
&lt;h4 id="decoder">Decoder&lt;/h4>
&lt;p>Das Design des Steckschwein ist ja mittlerweile sehr vereinfacht, und wir können den YM3812 ziemlich einfach mit einem entsprechenden 7400 an den Bus hängen. Wie beim VDP ist auch beim YM3812 ein dedizierter Read- und Write-Pin vorgesehen und zusätzlich - warum auch immer - noch ein dediziertes CS (chip select). Das CS wird über den GAL erzeugt und wird direkt an Pin 7 des YM3812 geführt. Für unseren ersten Test nehmen wir den Adressbereich $0230-$023f. Wir brauchen laut Datenblatt 2 Adressen, einmal Register-Select und einmal Register-Write. Wir wählen $0230 für den Register-Select und $0231 für den Register-Write, A0 (Adressleitung) wird direkt an Pin 4 des YM3812 gegeben. /WR, /RD erzeugen wir über einen 7400 ohne PHI2.&lt;/p>
&lt;h4 id="dedizierter-takt">Dedizierter Takt&lt;/h4>
&lt;p>Das ist schon ehern spannend, zumal ich hier gerade keinen 3.58Mhz Quartz rumliegen habe. Naja, ich hab noch die 10,738Mhz Quartze für den VDP, aber ne Teilerschaltung - Div by 3 - basteln möchte ich jetzt auch nicht. Man könnte für nen Test noch den GAL dafür verwenden. Ich beschließe aber, dass auch dass noch zu aufwändig ist für nen ersten Test und nehme einfach einen 12Mhz Oszillator und den bewährten LS393. Ich teile die 12Mhz durch 4 und führe die gewonnenen 3Mhz an den YM3812. Muss dem reichen&amp;hellip;.&lt;/p>
&lt;h4 id="dac-und-opamp">DAC und Opamp&lt;/h4>
&lt;p>Der DAC und der Opamp wird wie im Datenblatt erst einmal mit dem ganz minimalistischem Aufbau ohne RC-Filter usw. an den YM3812 angeschlossen. Noch nen Kabel dran und in den Audio-Eingang des 1084S Monitor gesteckt. Fertig, fehlt nur noch die Software.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/cA7oGLFuxXQ" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>to be continued&amp;hellip;&lt;/p></content></item><item><title>Echte Zeit</title><link>https://www.steckschwein.de/post/echte-zeit/</link><pubDate>Mon, 15 Dec 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/echte-zeit/</guid><description>Eine batteriegepufferte Echtzeituhr gehört ja heutzutage schon zur Serienausstattung, auch bei Retro-Rechnern. Das Steckschwein soll also auch eine bekommen. Chris Ward&amp;rsquo;s Design, welches uns zu Anfang als Grundlage gedient hat (mittlerweile ist davon nicht mehr viel übrig geblieben) verwendet eine DS1687, deren Intel-mäßiges Businterface über ein wenig Glue-Logik direkt an den Datenbus des 6502 angelegt ist und damit auch Platz im IO-Bereich benötigt.
Wir wollen das mit dem Steckschwein anders angehen.</description><content>&lt;p>Eine batteriegepufferte Echtzeituhr gehört ja heutzutage schon zur Serienausstattung, auch bei Retro-Rechnern. Das Steckschwein soll also auch eine bekommen. &lt;a href="http://www.chrisward.org.uk/6502/schematics/ds1687.gif">Chris Ward&amp;rsquo;s Design&lt;/a>, welches uns zu Anfang als Grundlage gedient hat (mittlerweile ist davon nicht mehr viel übrig geblieben) verwendet eine DS1687, deren Intel-mäßiges Businterface über ein wenig Glue-Logik direkt an den Datenbus des 6502 angelegt ist und damit auch Platz im IO-Bereich benötigt.&lt;/p>
&lt;p>Wir wollen das mit dem Steckschwein anders angehen. Unsere Echtzeituhr soll via SPI angebunden werden. Und auch ansonsten sind unsere Anforderungen eher bescheiden: - Einen Interrupt-Pin soll sie haben - Ein paar Bytes batteriegepuffertes RAM wären toll. - DIL-Gehäuse, sonst passts nicht aufs Steckbrett :-)&lt;/p>
&lt;p>Schlussendlich haben wir uns aus dem breiten Angebot von RTC-Chips mit SPI-Interface die DS1306 von Dallas/Maxim herausgepickt. Lediglich ein externes Uhrenquarz mit 32,768 kHz und 6pF Lastkapazität wird noch gebraucht, was gar nicht so leicht zu beschaffen ist, will man kein SMD. Letztendlich wurde es dann doch ein SMD-Quarz, aber mit Drähten dran, sodass es leicht war, es steckschweinkompatibel zu machen.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Ansonsten ist die DS1306 sehr simpel zu handhaben. Sie bietet 2 Alarme mit jeweils eigenem Interrupt-Pin  (einer active low, einer active high), 2 Taktausgänge (1Hz, 32,768kHz), Möglichkeiten zur Batterie- bzw. Akkupufferung, satte 96 Bytes gepuffertes RAM und ein pipileicht zu handhabendes SPI-Interface.&lt;/p>
&lt;p>&lt;img src="images/img-20141213-wa0004.jpeg" alt="img-20141213-wa0004">&lt;/p>
&lt;p>So war es dann auch ein Leichtes, ein kleines Programm zu schreiben, welches per Interrupt getriggert die Uhrzeit aus der RTC liest und auf dem LCD ausgibt. Der Interrupt, der dies auslöst wird ebenfalls im Sekundentakt von der RTC getriggert. Schneller kann die DS1306 nämlich nicht, eine höhere Auflösung als Sekunden ist nicht möglich. Auch die Tatsache, dass der Chip-Enable-Pin active high ist, ist etwas umständlich. Aber soweit wir das sehen konnten, ist das bei vielen RTC-Chips so. So müssen wir dies entweder Softwaremäßig berücksichtigen, oder das SPI_Select-Signal vorher durch einen Inverter leiten.&lt;/p></content></item><item><title>Eine fanTASTische Reise</title><link>https://www.steckschwein.de/post/eine-fantastische-reise/</link><pubDate>Mon, 15 Dec 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/eine-fantastische-reise/</guid><description>Von unserem Plan, einen AVR-µC als PS/2-Tastaturcontroller als SPI-Slave einzusetzen, haben wir ja schon in der Vergangenheit berichtet. Damals hieß es: &amp;ldquo;Bequemerweise gibt es zahlreiche fertige Lösungen, die z.B. am anderen Ende rs232 sprechen. Wir wollen aber nur wegen einer Tastatur keinen zweiten UART verbauen. Fehlt also nur eine kleine Anpassung auf SPI.&amp;rdquo;
Hiermit sollte das Schicksal seinen Lauf nehmen. Der kühne Griff in die Bastelkiste sollte einen ATtiny2313 zu Tage fördern, welcher der zugedachten Aufgabe durchaus gewachsen zu sein schien.</description><content>&lt;p>Von unserem Plan, einen AVR-µC als PS/2-Tastaturcontroller als SPI-Slave einzusetzen, haben wir ja schon &lt;a href="http://wordpress.steckschwein.de/wordpress/index.php/2014/07/11/tore-zur-welt/">in der Vergangenheit&lt;/a>  berichtet. Damals hieß es: &amp;ldquo;Bequemerweise gibt es zahlreiche fertige Lösungen, die z.B. am anderen Ende rs232 sprechen. Wir wollen aber nur wegen einer Tastatur keinen zweiten UART verbauen. Fehlt also nur eine kleine Anpassung auf SPI.&amp;rdquo;&lt;/p>
&lt;p>Hiermit sollte das Schicksal seinen Lauf nehmen. Der kühne Griff in die Bastelkiste sollte einen ATtiny2313 zu Tage fördern, welcher der zugedachten Aufgabe durchaus gewachsen zu sein schien.&lt;/p>
&lt;p>Als Ausgangsbasis für das Tastaturinterface sollte der Beispielcode aus &lt;a href="http://www.atmel.com/Images/doc1235.pdf">AVR Application Note 313&lt;/a> dienen, der die Scancodes der PS/2-Tastatur nach ASCII umsetzt und per rs232 ausgibt. Dies wäre also die Stelle für die &amp;ldquo;kleine Anpassung auf SPI&amp;rdquo;, leider aber hat der ATtiny2313 anders als ein Controller der ATmega-Reihe keine native SPI-Schnittstelle. Dafür gibt es dort das Universal Serial Interface (USI), mit dem sich auch eine SPI-Schnittstelle nachbilden lassen sollte. Lediglich das SPI-Slave-Select fehlt der USI und muss per Software nachgebaut werden.&lt;/p>
&lt;p>Der PS/2 Controller soll als SPI-Slave genau wie RTC und SD-Karte  angesprochen werden. Hierbei wollen wir den AVR sozusagen als Coprozessor betrachten, der nicht nur das Umsetzen der Scancodes nach ASCII nach einer zu definierenden Keymap übernehmen, sondern auch als Tastaturpuffer dienen soll, sodass das Steckschwein selbst sowas nicht braucht. Das Steckschwein soll bei bei Bedarf also direkt den Controller fragen bzw. warten bis dieser einen Tastendruck liefert.&lt;/p>
&lt;p>Dieser Ansatz brachte nun einige Probleme mit sich. Ein Programm auf dem Steckschwein, dass per SPI den Controller pollte, bekam meist nur Datenmüll zurück. Schrieb man den Puffer voll, und startete dann die Abfrage, kamen diese Daten zumeist korrekt auf dem Steckschwein an.&lt;/p>
&lt;p>Diese Fehlerbild legt nahe, dass das Verarbeiten des CLK-Signals der Tastatur via INT0-Interrupt irgendwie Einfluss auf das Timing der USI hat, zumal das Erhöhen des Taktes des AVR eine kleine Abmilderung bedeutete.&lt;/p>
&lt;p>Was nun folgen sollte war eine mehrwöchige Reihe von frustrierenden Debugging-Sessions, ohne jedoch dass es zu einem schlüssigen Ergebnis kam. Frustrierend insofern, als dass für eine solch trivial anmutende und wenig aufregende Aufgabenstellung max. 2 Tage angesetzt waren.&lt;/p>
&lt;p>Als einzige Erkenntnis blieb zumindest, dass das Erhöhen der Taktfrequenz scheinbar eine leichte Besserung zur Folge hatte. Nur kann der ATtiny &amp;ldquo;nur&amp;rdquo; bis max. 20MHz getaktet werden, und selbst eine leichte Übertaktung auf 22MHz brachte keine vollständige Lösung des Problems. Zudem der Nachgeschmack den der Gedanke auslöste, dass der Tastaturcontroller eines 4MHz Rechners für seine Aufgabe mehr als 5mal so hoch getaktet werden wollte wie der Hauptprozessor.&lt;/p>
&lt;p>Marko und ich verblieben, dass wir das Problem in der nächsten gemeinsamen Session mal geballt betrachten wollten. Ich verkroch mich frustriert im KiCad-Layouteditor.&lt;/p>
&lt;p>Aber: Mir läßt sowas keine Ruhe. Als allerletztes Aufbäumen vor der Kapitulation habe ich beschlossen, den ATtiny in die Bastelkiste zu verbannen, und stattdessen einen ATmega8 mit seinem nativen SPI-Interface auszuprobieren. (Spoiler: Im Post über die RTC sieht man schon den verbauten ATmega8) Schlussendlich schrumpfte so der SPI-Code auf eine Handvoll Zeilen und alle oben beschriebenen Probleme waren schlicht und ergreifend weg! Und das sogar bei einer Taktfrequenz weit unter 22MHz, nämlich genau 4MHz, die nun auch vom internen RC-Oszillator erzeugt werden.&lt;/p>
&lt;p>Was blieb, war etwas Fleißarbeit, um Modifier-Keys wie Ctrl und Alt zu unterstützen und das Tastaturmapping auf deutsches Layout anzupassen. Zusätzlich fängt die Firmware noch Tasten(-kombinationen) wie SysRq und Ctrl-Alt-Del ab, und steuert damit IO-Pins an, sodass man über die Tastatur Reset und NMI auslösen kann.&lt;/p>
&lt;p>Der ATmega8 mutet mit seinen 8k Flash-Speicher natürlich äußerst fett an, aber sicherlich lassen sich diese noch sinnvoll nutzen um etwa mehrere Tastaturmappings unterzubringen. Auch ein PS/2-Mausinterface wäre denkbar.&lt;/p>
&lt;p>Aber aktuell sind wir sehr glücklich, dass wir endlich einen Tastaturcontroller haben, der so funktioniert wie wir das gerne möchten.&lt;/p></content></item><item><title>ROM an, ROM aus</title><link>https://www.steckschwein.de/post/rom-an-rom-aus/</link><pubDate>Sun, 26 Oct 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/rom-an-rom-aus/</guid><description>Nachdem wir also mit dem Adressdecoder durchaus zufrieden sind, müssen wir uns noch einen Weg überlegen, die /ROMOFF-Leitung per Software steuerbar zu machen. Wenn es schon beim BIOS-Update Test äußerst nützlich ist einfach nur eine Brücke umzustecken und damit das ROM zu deaktivieren, wie praktisch muss es erst sein, dies einfach durch Beschreiben einer Speicherstelle zu tun.
Was wir also brauchen, ist ein IO-Pin, der die /ROMOFF-Leitung steuert. Zusätzlich muss dieser Pin beim Einschalten des Systems einen definierten Zustand haben, damit sichergestellt ist, daß zu diesem Zeitpunkt das ROM eingeblendet ist.</description><content>&lt;p>Nachdem wir also mit dem Adressdecoder durchaus zufrieden sind, müssen wir uns noch einen Weg überlegen, die /ROMOFF-Leitung per Software steuerbar zu machen. Wenn es schon beim BIOS-Update Test äußerst nützlich ist einfach nur eine Brücke umzustecken und damit das ROM zu deaktivieren, wie praktisch muss es erst sein, dies einfach durch Beschreiben einer Speicherstelle zu tun.&lt;/p>
&lt;p>Was wir also brauchen, ist ein IO-Pin, der die /ROMOFF-Leitung steuert. Zusätzlich muss dieser Pin beim Einschalten des Systems einen definierten Zustand haben, damit sichergestellt ist, daß zu diesem Zeitpunkt das ROM eingeblendet ist. Passende Pins finden wir an der VIA und am UART. Die Portpins der VIA beispielsweise sind initial als Eingänge geschaltet und per internem Pullup high. Auch die OUT1 und OUT2-Pins des UART sind initial high. Gegen den UART-Ansatz spricht, dass sich diese Pins  nur über ein Write-Only-Register setzen lassen und es keine Möglichkeit gibt, den Zustand dieser Pins über irgendein UART-Register abzufragen.&lt;/p>
&lt;p>Der VIA-Ansatz hat den Nachteil, dass die Pins zwar einen definierten Zustand haben, dies aber nur &amp;ldquo;zufällig&amp;rdquo;, weil die VIA-Pins initial immer als Eingang definiert sind und damit nach &amp;ldquo;außen&amp;rdquo; Hi werden. Außerdem sind die Ports der VIA alle verplant. Port B ist vollständig für SPI vorgesehen, Port A stellt die Joystickports. Sicher wäre es möglich, von Port B einen SPI_SS abzuknapsen, doch so richtig sauber wäre das nicht.&lt;/p>
&lt;p>Besser für eine richtig saubere Lösung wäre also eine dedizierte Schaltung, die folgendes erfüllen soll: - Einen Pin mit definiertem Ausgangszustand - Dieser soll durch Schreiben in eine Speicherstelle verändert werden können - Der Zustand soll durch Lesen der Speicherstelle ermittelt werden können - Es soll kein vorhandener Chip (VIA, UART, ..) missbraucht werden&lt;/p>
&lt;p>Kurz: Wir wollen einen dedizierten Ausgabeport in den Adressraum bzw. IO-Bereich einblenden. Der ideale Baustein hierfür wäre ein 8bit Tri-State Latch mit Reset. Einen Baustein, der all das kann, finden wir nicht. Die nächstbeste Möglichkeit wäre ein 74hct273, einem 8bit-Latch mit Reset, dem wir einen 74hct244-Buffer vorschalten, um ihn vom Bus zu nehmen, wenn er nicht selektiert ist. Leider befindet sich kein 74hct273 in der Bastelkiste, sodass erste Experimente mit einem Flipflop aus einem 74ls74 und einem Tri-State-Buffer im für das SD-Karten-Interface bereits verbauten 74hct125 stattfinden müssen. Sozusagen die kleine Variante mit nur einem Bit.&lt;/p>
&lt;p>&lt;strong>Update:&lt;/strong> Nach reiflicher Überlegung kann auf den Buffer auch verzichtet werden. Das Latch legt ja nur Eingänge auf den Bus, und tut nur etwas, wenn es per /CS eine CLK-Flanke bekommt. Also rationalisieren wir den Buffer weg und sparen einen Chip.&lt;/p>
&lt;p>&lt;img src="images/screen-2bshot-2b2014-10-26-2bat-2b16-33-081.png" alt="screen-2bshot-2b2014-10-26-2bat-2b16-33-081">&lt;/p>
&lt;p>/MEMCTL haben wir den IO-Select-Pin des GAL genannt. Mit dieser Verdrahtung ist es nun möglich, das Flipflop durch Beschreiben einer Speicherstelle zu kippen. Was noch fehlt, ist die Möglichkeit, den Zustand des Ports auslesen zu können.&lt;/p>
&lt;p>Ein Ansatz wäre, den Ausgang des Flipflop über einen weiteren Buffer wieder an den Datenbus zu koppeln und abhängig davon, ob gelesen oder geschrieben wird, den einen oder andere Buffer zu aktivieren. Dies würde aber zusätzliche Logik erfordern. Ein Ansatz mit geringerem Chipcount ist uns lieber. Wie wäre es, wenn wir für Schreibzugriffe an diesen Port nicht nur das Latch, sondern auch das darunterliegende RAM selektieren? Das geschriebene Byte würde somit im RAM gespiegelt. Dann müßte nur noch sichergestellt werden, dass das Latch nur noch bei Schreibzugriffen selektiert wird, sodass Lesezugriffe nur noch im RAM landen. Dies erfordert Anpassungen an der Dekoderlogik im GAL:&lt;/p>
&lt;p>/MEMCTL = /A15*/A14*/A13*/A12 * /A11*/A10*A9*/A8 * A7*A6*A5*A4 * /RW ; $02f0&lt;/p>
&lt;p>Wir legen unsere /MEMCTL-Leitung so weit wie möglich ans Ende des IO-Bereichs, und beziehen RW mit in den Term ein. Der Term für LORAM muss auch angepasst werden, damit $02f0 nicht mehr teil des reinen IO-Blocks ist. Hierzu nehmen wir A7 mit in den Term auf, was den IO-Bereich verkleinert (halbiert), sodass dieser an $027F endet. Mehr IO-Pins haben wir ohnehin nicht. Gleichzeitig haben wir noch Reserven im Adressraum, falls wir doch mal einen Block größer 16 Byte brauchen.&lt;/p>
&lt;p>Vorher CSLORAM = /A14 * /A13 * /A12 * /A11 * /A10 * A9 * /A8 + A15&lt;/p>
&lt;p>Nachher&lt;/p>
&lt;p>CSLORAM = /A14 * /A13 * /A12 * /A11 * /A10 * A9 * /A8 * /A7 + A15&lt;/p>
&lt;p>Hiermit hat sich die Speicherbelegung wie folgt verändert.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Bereich&lt;/th>
&lt;th>Was&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$0000 - $01ff&lt;/td>
&lt;td>RAM (Zeropage und Stack)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0200 - $027f&lt;/td>
&lt;td>IO-Bereich&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0280 - $02ef&lt;/td>
&lt;td>RAM (reserviert)*&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$02f0 - $02ff&lt;/td>
&lt;td>MEMCTL-Register&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0300 - $dfff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$e000 - $ffff&lt;/td>
&lt;td>ROM (ausblendbar)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>* Das RAM an dieser Stelle ist im Grunde nutzbar, da wir aber Stand heute noch nicht wissen, ob dort später nicht doch noch IO-Adressen gemappt werden, deklarieren wir diesen Bereich als &amp;ldquo;reserviert&amp;rdquo;.&lt;/p>
&lt;p>Jetzt fehlen nur noch die &amp;ldquo;richtigen&amp;rdquo; Chips, um das Ganze 8bit breit umzusetzen.&lt;/p>
&lt;p>Von den jetzt noch freien 7 Bit des so entstandenen &amp;ldquo;Memctl-Register&amp;rdquo; (nennen wir es ruhig so) verbinden wir Bit 1 und Bit 2 mit den Adressleitungen A13 und A14 des ROM, die vorher hart auf Masse lagen. Damit haben wir die Möglichkeit, die kompletten 32K des ROM zu nutzen, auch wenn wir aktuell noch nicht genau wissen, wofür :-). Aber so ist dann schonmal nichts verbaut.&lt;/p>
&lt;p>Der kleine Schönheitsfehler dieser Lösung soll nicht verschwiegen werden: Der Inhalt des RAM ist beim Einschalten bekanntlich nicht definiert. Direkt nach dem Einschalten und bevor das erste Mal ins Register geschrieben wurde, lesen wir aus dem Register also alles, nur nicht den Zustand des Latch. Hier werden wir uns etwas Schlaues per Software überlegen müssen.&lt;/p></content></item><item><title>Dekoder, die Dritte</title><link>https://www.steckschwein.de/post/dekoder-die-dritte/</link><pubDate>Thu, 23 Oct 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/dekoder-die-dritte/</guid><description>Bekanntlich dekodiert unser GAL die oberen 8bit des Adressbus, um den Bereich $8000-$ffff unter RAM, IO-Bereich und ROM einzuteilen. Die unteren 32k werden am Decoder vorbei direkt von der Adressleitung A15 selektiert. Das Memory-Mapping, das sich daraus ergibt, ist - zur Wiederholung - wie folgt:
Bereich Was $0000 - $7fff RAM $8000 - $cfff RAM $d000 - $dfff IO-Bereich $e000 - $ffff ROM Die letzte Änderung am Decoder war, das ROM bei Bedarf ausblendbar zu machen.</description><content>&lt;p>Bekanntlich dekodiert unser GAL die oberen 8bit des Adressbus, um den Bereich $8000-$ffff unter RAM, IO-Bereich und ROM einzuteilen. Die unteren 32k werden am Decoder vorbei direkt von der Adressleitung A15 selektiert. Das Memory-Mapping, das sich daraus ergibt, ist - zur Wiederholung - wie folgt:&lt;/p>
&lt;p> &lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Bereich&lt;/th>
&lt;th>Was&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$0000 - $7fff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$8000 - $cfff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$d000 - $dfff&lt;/td>
&lt;td>IO-Bereich&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$e000 - $ffff&lt;/td>
&lt;td>ROM&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;a href="http://wordpress.steckschwein.de/wordpress/index.php/2014/07/01/noch-schlauerer-decoder/">Die letzte Änderung&lt;/a> am Decoder war, das ROM bei Bedarf ausblendbar zu machen. Dieser Mechanismus hat sich beim Test von BIOS-Updates als pures Gold erwiesen, da man ums neu Brennen des EEPROM herumkommt. Das spart Zeit und schont Material.&lt;/p>
&lt;p>Trotzdem sehen wir noch viel Raum für Verbesserungen. Insbesondere im IO-Bereich hätten wir gerne mehr Granularität. Aktuell verschenken wir ganze 4K, jedes IO-Device bekommt eine ganze 256 byte-Page zugeschustert. Die meisten Chips  in dem Bereich haben gerade mal eine Handvoll Register.&lt;/p>
&lt;p>Würden wir nicht nur die oberen 8, sondern 12 bit des Adressbus dekodieren, hätten wir 16byte-Blöcke für IO-Devices. Wir würden mit einer 256byte-Page mehr als locker auskommen. Der Chip mit den meisten Registern ist unsere 65c22 VIA mit genau 16 Stück. Alle anderen haben weit weniger. Passt also.&lt;/p>
&lt;p>Bei der Gelegenheit bereinigen wir das Pinout des GAL, indem wir die Glue-Logic für das LCD rauswerfen. Dadurch brauchen wir im Decoder auch kein PHI2 mehr, was uns einen freien Eingang zurückgibt, und die /CS-Pins sind alle gleichförmig active low. Die Sonderlocke E_LCD muss jetzt aus /CSIO in einem 7400 extern generiert werden.&lt;/p>
&lt;p>&amp;mdash;&amp;mdash;-___/&amp;mdash;&amp;mdash;-&lt;/p>
&lt;p>A15 |  1           24 | VCC&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A14 |  2           23 | CSIO&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A13 |  3           22 | CSSND&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A12 |  4           21 | CSVDP&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A11 |  5           20 | CSVIA&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A10 |  6           19 | CSUART&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A9 |  7           18 | CSHIRAM&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A8 |  8           17 | CSLORAM&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A7 |  9           16 | CSROM&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A6 | 10           15 | ROMOFF&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A5 | 11           14 | RW&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>GND | 12           13 | A4&lt;/p>
&lt;hr>
&lt;p>Wer genau hinschaut, erkennt, dass /CSHIRAM ein Pendant bekommen hat: /CSLORAM.&lt;/p>
&lt;p>Hintergrund ist, dass wir uns entschieden haben, den IO-Bereich &amp;ldquo;nach unten&amp;rdquo; zu verschieben, und zwar nach $0200, direkt über den Stack. Damit ist das RAM von $0300 bis $dfff komplett nutzbar. Blendet man das ROM aus, lassen sich die kompletten 64k minus 768 bytes für Zeropage, Stack und IO vollständig nutzen. Ein IO-Bereich mittendrin bei $d000 würde da stören.&lt;/p>
&lt;p>Wie eingangs erwähnt wurde der RAM-Baustein für $0000-$7fff direkt über die A15 selektiert. Würde der GAL so den IO-Bereich nach $0200 blenden, wären dort dann der selektierte IO-Baustein und das RAM selektiert, was zumindest bei Lesezugriffen nicht funktionieren kann. Folglich muss der GAL auch das CS für das untere RAM kontrollieren.&lt;/p>
&lt;p>Die Gleichung sieht folgendermaßen aus:&lt;/p>
&lt;p>CSLORAM = /A14 * /A13 * /A12 * /A11 * /A10 * A9 * /A8 + A15&lt;/p>
&lt;p>Als äußerst hilfreich hat sich übrigens die App &lt;a href="https://play.google.com/store/apps/details?id=com.flx.flxkarnaugh&amp;amp;hl=de">FLXKarnaugh&lt;/a> erwiesen. Die neue Memory-Map sieht also so aus:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Bereich&lt;/th>
&lt;th>Was&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$0000 - $01ff&lt;/td>
&lt;td>RAM (Zeropage und Stack)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0200 - $02ff&lt;/td>
&lt;td>IO-Bereich&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0300 - $dfff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$e000 - $ffff&lt;/td>
&lt;td>ROM (ausblendbar)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Für uns fühlt sich das Design jetzt deutlich &amp;ldquo;sauberer&amp;rdquo; an. Der GAL hat die alleinige Kontrolle über den Adressraum, macht dafür aber auch nichts anderes als Adressdekodierung und wird nicht auch noch für Glue-Logic-Aufgaben missbraucht. A propos Glue Logic - die Ausgänge des GAL reichen nur bis Adresse $0240, also demultiplexen wir /CSIO, indem wir es als Enable für ein 74ls139 verwenden, und A4 und A5 dort dekodieren. Damit erhalten wir 3 weitere CS-Pins für IO-Komponenten und haben immer noch Platz im IO-Bereich.&lt;/p>
&lt;p>Als nächstes wollen wir uns einen Weg überlegen, die /ROMOFF-Leitung per Software zu steuern.&lt;/p></content></item><item><title>Zurück vom VCFe.CH</title><link>https://www.steckschwein.de/post/zurueck-vom-vcfe-ch/</link><pubDate>Wed, 22 Oct 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/zurueck-vom-vcfe-ch/</guid><description>Das VCFe.CH war ein großer Spaß und wieder haben wir uns über das Interesse an unserem Projekt gefreut. Bei der Gelegenheit haben wir in einem kleinen Vortrag die letzten Fortschritte und aktuellen Stand des Steckschweins, wie es jetzt offiziell heißt, gehalten. Hier sind die Folien
Außerdem gehört uns jetzt die Domain steckschwein.de, wo in Zukunft unsere Projektwebsite entstehen soll.</description><content>&lt;p>Das VCFe.CH war ein großer Spaß und wieder haben wir uns über das Interesse an unserem Projekt gefreut. Bei der Gelegenheit haben wir in einem kleinen Vortrag die letzten Fortschritte und aktuellen Stand des Steckschweins, wie es jetzt offiziell heißt, gehalten. &lt;a href="https://drive.google.com/file/d/0B82yoNWUtYziMXdOdDYwNmZXT3M/view?usp=sharing">Hier sind die Folien&lt;/a>&lt;/p>
&lt;p>Außerdem gehört uns jetzt die Domain &lt;a href="http://steckschwein.de/">steckschwein.de&lt;/a>, wo in Zukunft unsere Projektwebsite entstehen soll.&lt;/p></content></item><item><title>Steckschwein auf dem VCFe.CH</title><link>https://www.steckschwein.de/post/steckschwein-auf-dem-vcfe-ch/</link><pubDate>Wed, 15 Oct 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/steckschwein-auf-dem-vcfe-ch/</guid><description>Wir sind wieder unterwegs und zeigen unsere Steckschweine herum. Am Samstag, dem 18.10. werden wir auf dem VCFe.CH in Winterthur zugegen sein, und den aktuellen Stand unseres Projekts vorstellen. Auch ein kleiner Vortrag ist geplant.
Wir freuen uns!</description><content>&lt;p>Wir sind wieder unterwegs und zeigen unsere Steckschweine herum. Am Samstag, dem 18.10. werden wir auf dem VCFe.CH in Winterthur zugegen sein, und den aktuellen Stand unseres Projekts vorstellen. Auch ein kleiner Vortrag ist geplant.&lt;/p>
&lt;p>Wir freuen uns!&lt;/p>
&lt;p>&lt;a href="http://www.vcfe.org/DATA/CH-Naechstes_Mal.jpg">&lt;img src="images/CH-Naechstes_Mal.jpg" alt="">&lt;/a>&lt;/p></content></item><item><title>TMS9929 Composite Video und RGB+H/Y</title><link>https://www.steckschwein.de/post/tms9929-composite-video-und-rgbhy/</link><pubDate>Mon, 28 Jul 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/tms9929-composite-video-und-rgbhy/</guid><description>Damit Dommas nicht langweilig wird und auch in den Gfx-Genuss kommt muss natürlich eine Lösung her. Er hat momentan keine Möglichkeit das Steckschwein mit Grafik an seinem geliebten Commodore 1084-S Monitor zu betreiben. Was ist also zu tun?
Wir haben ja im Post &amp;hellip; beschrieben wie wir aus dem YRyBy des TMS9929 ein brauchbares RGB+Sync (BAS) Signal erzeugen können. Das funktioniert auch wunderbar an allen derzeit gängigen CRT-Fernsehern und auch an allen neuzeitlichen Flat-Screens wenn diese noch einen SCART-Anschluss oder ebend RGB+Sync (PAL-RGB) Eingänge besitzen.</description><content>&lt;p>Damit Dommas nicht langweilig wird und auch in den Gfx-Genuss kommt muss natürlich eine Lösung her. Er hat momentan keine Möglichkeit das Steckschwein mit Grafik an seinem geliebten Commodore 1084-S Monitor zu betreiben. Was ist also zu tun?&lt;/p>
&lt;p>Wir haben ja im Post &amp;hellip; beschrieben wie wir aus dem YRyBy des TMS9929 ein brauchbares RGB+Sync (BAS) Signal erzeugen können. Das funktioniert auch wunderbar an allen derzeit gängigen CRT-Fernsehern und auch an allen neuzeitlichen Flat-Screens wenn diese noch einen SCART-Anschluss oder ebend RGB+Sync (PAL-RGB) Eingänge besitzen. Am 1084-S geht aber nur RGB+H/V, d.h. das horizontale und vertikale Sync-Signal muss getrennt vorliegen. Wir haben aber nur ein Composite-Sync mit dem RGB+S vorliegen. Wir brauchen einen Sync-Separator. Genau das macht der LM1881 und kompatible.&lt;/p>
&lt;p> &lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>Problem&lt;/strong>: &lt;strong>Die Schaltung funktioniert nicht, zumindest nicht am Monitor 1084S&lt;/strong>&lt;/p>
&lt;p>Damit gehts also nicht, das erzeugte SYNC taugt dem 1084S nicht, wir bekommen kein Bild, sondern nur geflimmer.&lt;/p>
&lt;p>Den 1084S nochmal genau angeschaut, um dann festzustellen, dass der ja eigentlich auch nur ein Fernseher ist. Mit dem Eingang CVBS/L und dem Umschalter am Front-Panel CVBS/RGB lässt sich der 1084S mit dem analogen RGB-Signal über die DIN-Buchse und zusätlzich dem SYNC-Signal am CVBS/L betreiben. Wir machen einen Test und es funktioniert, wir bekommen ein super Bild.&lt;/p>
&lt;p>Da wir jetzt aber ein völlig unkonventionelles Kabel benutzen, wir aber als Ziel einen 1-Platinenrechner haben der kompatibel zum Rest der Welt sein soll, entschließen wir uns noch die fehlende SCART-Buchse am 1084S nazurüsten. Dazu muss lediglich eine entsprechende SCART-Buchse eingebaut werden und die RGB-Pins am &lt;a href="http://de.wikipedia.org/wiki/SCART">SCART&lt;/a> - Pin 7 (blau), Pin 11 (grün), Pin 15 (rot) - mit dem bereits vorhandenen RGB-Anschlüssen der RGB DIN-Buchse des 1084S verbinden. Zum Glück ist dies nicht erforderlich, denn auch bei der 1084S Baureihe ohne SCART-Buchse ist dies bereits vorgesehen. Wir müssen uns lediglich Gedanken um das (F)BAS/Video-SYNC machen, was an Pin 20 der SCART-Buchse anliegt. Das SYNC muss im 1084S, wie oben bereits erwähnt, mit dem CVBS/L Cinch-Eingang verbunden werden.&lt;/p>
&lt;p>Im folgenden Schaltplan eines 1084S Models mit SCART-Buchse kann man diesen Signalpfad deutlich erkennen.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Wie auch immer, in unseren 1084S ohne SCART-Buchse ist dieser Pfad nicht verbunden. Dazu kommt das Problem, dass der Schalter CVBS/RGB im Front-Panel lediglich CVBS am Cinch-Eingang oder ebend RGB über die DIN-Buchse zulässt.&lt;/p>
&lt;p>Schaltet man auf RGB wird über den Transistor TS509 der Video-Eingang über Cinch kurzgeschlossen, den es soll ja das H-/V-Sync der DIN-Buchse verwendet werden, was mit dem LM1881 und oben beschriebenen Ansatz nicht funktioniert hat.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Also ziehen wir die Basis des TS509 kurzerhand auf Masse, so dass quasi der CVBS/RGB Schalter das Video-Signal nicht mehr kurzschließen kann und wir unser SYNC via Cinch oder ebend jetzt über SCART zusammen mit dem RGB am SCART in den 1084S speisen können.&lt;/p>
&lt;p>Wir schrauben den 1084S wieder zusammen und sind zufrieden, immerhin haben wir jetzt ein Super Bild und einen SCART-Anschluss für den 1084S.&lt;/p>
&lt;p>&lt;a href="https://steckschwein.files.wordpress.com/2014/07/d39ce-1084s_scart_rgb.jpeg">&lt;img src="images/d39ce-1084s_scart_rgb.jpeg" alt="">&lt;/a>&lt;/p></content></item><item><title>SPI mit 65c22 VIA</title><link>https://www.steckschwein.de/post/spi-mit-65c22-via/</link><pubDate>Sun, 13 Jul 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/spi-mit-65c22-via/</guid><description>Es gibt verschiedene Ansätze, einem 6502-basierten System SPI beizubiegen. Daryl Rictor hat z.B. einen CPLD-basierten SPI-Controller mit passendem Businterface entwickelt. Meist jedoch wird eine 6522 VIA hergenommen und SPI per Bit Banging implementiert. Auch hier gibt es verschiedenen Ansätze, Andre Fachat hat es mit ein wenig externer Logik sogar geschafft, das Schieberegister der VIA im für SD-Karten nötigen SPI Mode 0 zu betreiben. Normalerweise geht das ja nicht, das das Schieberegister der VIA die Daten nicht vor dem ersten Taktimpuls anlegen kann.</description><content>&lt;p>Es gibt verschiedene Ansätze, einem 6502-basierten System SPI beizubiegen. Daryl Rictor hat z.B. einen &lt;a href="http://sbc.rictor.org/65spi.html">CPLD-basierten SPI-Controller&lt;/a> mit passendem Businterface entwickelt. Meist jedoch wird eine 6522 VIA hergenommen und SPI per Bit Banging implementiert. Auch hier gibt es verschiedenen Ansätze, Andre Fachat hat es mit ein wenig externer Logik sogar geschafft, das Schieberegister der &lt;a href="http://www.6502.org/users/andre/csa/spi/index.html">VIA im für SD-Karten nötigen SPI Mode 0&lt;/a> zu betreiben. Normalerweise geht das ja nicht, das das Schieberegister der VIA die Daten nicht vor dem ersten Taktimpuls anlegen kann.&lt;/p>
&lt;p>Unser Ansatz verwendet den VIA Port B zum Senden. An PB0 liegt der SPI Takt an, an PB7 das Datenbit (MOSI). Die Pins dazwischen dienen als Slave-Select-Leitungen. Der Empfang der Daten vom SPI-Slave (MISO) übernimmt das Schieberegister der VIA, welches extern betaktet werden soll.&lt;/p>
&lt;p>Diese Betriebsart der VIA ist berühmt berüchtigt für einen &lt;a href="http://en.wikipedia.org/wiki/MOS_Technology_6522#Shift_register">Bug&lt;/a>, der dafür sorgen kann, das das Schieberegister ein Bit &amp;ldquo;vergisst&amp;rdquo;, nämlich dann, wenn die fallende Flanke des Systemtakts und die fallende Flanke des Schieberegister-Takts an CB1 zeitlich eng zusammenfallen. In diesem Fall wird die Flanke an CB1 ignoriert, was zum Verlust des entsprechenden Bit führt.&lt;/p>
&lt;p>Mit dem Oszilloskop sehen wir, dass es zwischen den fallenden Flanken beider Takte ausreichend Versatz gibt, sodass wir uns keine Sorgen machen.&lt;/p>
&lt;p>&lt;img src="images/83d46-tekway128_2.gif" alt=""> Versatz von PHI2 (gelb) und SPICLK (blau)&lt;/p>
&lt;p>Jetzt brauchen wir nur noch die Routinen zum Bit-Banging des Ports:&lt;/p>
&lt;p>Diese Routine überträgt das Byte im Akku per SPI. Das empfangene Byte wird anschließend aus dem Schieberegister in den Akku geladen.&lt;/p>
&lt;pre tabindex="0">&lt;code>spi_rw_byte
phx
phy
sta tmp0        ; zu transferierendes byte im akku nach tmp0 retten
ldx #$08
lda via1portb   ; Port laden
and #$fe        ; SPICLK loeschen
asl             ; Nach links rotieren, damit das bit nachher an der richtigen stelle steht
tay              ; bunkern
-
rol tmp0
tya             ; portinhalt
ror             ; datenbit reinschieben
sta via1portb   ; ab in den port
inc via1portb   ; takt an
sta via1portb   ; takt aus
dex
bne -           ; schon acht mal?
lda via1sr      ; Schieberegister auslesen
ply
plx
rts
&lt;/code>&lt;/pre>&lt;p>Da wir eher häufiger lesen als schreiben, gibt es dafür auch noch eine Routine, die nochmal wesentlich schneller arbeitet, da wir uns den Code für das Zerlegen des zu sendenden Bytes ja sparen können. Damit es richtig schnell geht, unrollen wir die Schleife für die Takterzeugung.&lt;/p>
&lt;pre tabindex="0">&lt;code>spi_r_byte
phy
lda via1portb   ; Port laden
AND #$7e   ; * Daten und Takt ausschalten
TAY             ; aufheben
ORA #$01
STA via1portb ; Takt An 1
STY via1portb ; Takt aus
STA via1portb ; Takt An 2
STY via1portb ; Takt aus
STA via1portb ; Takt An 3
STY via1portb ; Takt aus
STA via1portb ; Takt An 4
STY via1portb ; Takt aus
STA via1portb ; Takt An 5
STY via1portb ; Takt aus
STA via1portb ; Takt An 6
STY via1portb ; Takt aus
STA via1portb ; Takt An 7
STY via1portb ; Takt aus
STA via1portb ; Takt An 8
STY via1portb ; Takt aus
lda via1sr
ply
rts
&lt;/code>&lt;/pre>&lt;p>An dieser Stelle vielen Dank an &lt;a href="http://www.vcfe.org/">Hans Franke&lt;/a>, der uns auf die Idee mit SPI gebracht, die Idee mit dem Schieberegister hatte und mit uns die optimierten SPI-Routinen entwickelt hat.&lt;/p></content></item><item><title>Tore zur Welt</title><link>https://www.steckschwein.de/post/tore-zur-welt/</link><pubDate>Fri, 11 Jul 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/tore-zur-welt/</guid><description>Um dem Ziel eines &amp;ldquo;richtigen&amp;rdquo; Computers näher zu kommen, brauchen wir nicht nur einen Videochip, wir brauchen auch Eingabegeräte und Massenspeicher.
Zwar soll unser Rechner so retro sein, dass es ihn damals, zur Hochzeit der 8bit-Heimcomputer, durchaus hätte geben können, realistischerweise wollen wir ihn jedoch mit durchaus modernen Schnittstellen ausstatten. Die 8bit-Rechner aus &amp;ldquo;unserer Zeit&amp;rdquo; haben IO-Chips wie den 6526 oder 6522 benutzt, um Tastatur (Matrix), Joysticks und Massenspeicher anzusteuern. Das haben wir auch vor.</description><content>&lt;p>Um dem Ziel eines &amp;ldquo;richtigen&amp;rdquo; Computers näher zu kommen, brauchen wir nicht nur einen Videochip, wir brauchen auch Eingabegeräte und Massenspeicher.&lt;/p>
&lt;p>Zwar soll unser Rechner so retro sein, dass es ihn damals, zur Hochzeit der 8bit-Heimcomputer, durchaus hätte geben können, realistischerweise wollen wir ihn jedoch mit durchaus modernen Schnittstellen ausstatten. Die 8bit-Rechner aus &amp;ldquo;unserer Zeit&amp;rdquo; haben IO-Chips wie den 6526 oder 6522 benutzt, um Tastatur (Matrix), Joysticks und Massenspeicher anzusteuern. Das haben wir auch vor. Nur etwas anders. Wir verwenden eine 65c22 VIA, und machen sie zu einem &lt;a href="http://de.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI&lt;/a> &amp;ldquo;Master&amp;rdquo;. Damit wollen wir einen wesentlichen Teil der Peripherie anbinden.&lt;/p>
&lt;p>SD-Karten unterstützen SPI direkt, sodass unsere angepeilte Massenspeicherlösung quasi schon fertig ist. Damit ersparen wir es uns, einen irgendwie gearteten Laufwerkscontroller ansteuern zu müssen oder gar über einen Haufen TTL eine IDE-Schnittstelle für alte Platten oder CompactFlash-Karten bauen zu müssen. Der einzige Zusatzaufwand, den wir hardwaremäßig noch betreiben müssen, ist eine 3.3V-Spannungsversorgung und eine Anpassung der 5V-Pegel der VIA auf 3.3V für die SD-Karte, denn SD-Karten laufen mit 3.3V und ihre Eingänge sind nicht 5V-tolerant. Der Rest ist Software.&lt;/p>
&lt;p>In Sachen Tastatur setzen wir auch auf eine Standardschnittstelle, nämlich PS/2. Das ist immer noch retro genug, und PS/2-Tastaturen sind immer noch einfacher zu beschaffen als Matrixtastaturen. Als kleiner Stilbruch bietet sich als Tastaturcontroller ein kleiner AVR-Microcontroller an, der die Scancodes der Tastatur in ASCII-Codes wandelt. Bequemerweise gibt es zahlreiche fertige Lösungen, die z.B. am anderen Ende rs232 sprechen. Wir wollen aber nur wegen einer Tastatur keinen zweiten UART verbauen. Fehlt also nur eine kleine Anpassung auf SPI. Aber zunächst mal die SD-Karte.&lt;/p>
&lt;p>Mit SPI hätten wir darüberhinaus noch viel mehr Möglichkeiten, ohne allzu großen Aufwand weitere SPI-fähige Komponenten wie RTCs, EEPROMS oder vielleicht sogar USB-Hosts anzubinden.&lt;/p>
&lt;p>Der Schaltplan zeigt, wie wir aktuell die VIA nutzen, um eine SD-Karte anzusprechen. Port B stellt die Steuerleitungen, wobei die beiden &amp;ldquo;äußeren&amp;rdquo; Bits 0 und 7 für SPICLK und MOSI verwendet werd, weil sie sich durch Inkrementieren, Dekrementieren bzw. Bit-Shifting schnell ansprechen lassen. Die 6 Bit dazwischen dienen als Slave-Select-Leitungen. MISO geht direkt in CB2, dem Eingang des Schieberegisters der VIA, welcher von PB0 an CB1 extern über unsere SPI-Clock getaktet wird. Damit läuft das Schieberegister exakt in dem Modus, der durch den berühmt berüchtigten VIA-Bug betroffen ist. Wir leben gerne gefährlich. Die Alternative wäre gewesen, ein externes Schieberegister zu benutzen, welches dann Port A belegt hätte. So bleibt dieser frei.&lt;/p>
&lt;p>&lt;a href="https://steckschwein.files.wordpress.com/2014/07/fa076-spi.png">&lt;img src="images/fa076-spi.png" alt="">&lt;/a>&lt;/p></content></item><item><title>Noch schlauerer Decoder</title><link>https://www.steckschwein.de/post/noch-schlauerer-decoder/</link><pubDate>Tue, 01 Jul 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/noch-schlauerer-decoder/</guid><description>Wir sind jetzt also fast in der Lage, das RAM unter dem ROM zu nutzen. Hineinschreiben geht, lesen noch nicht. Da ist das ROM noch im Weg. Wir müssen also einen Weg finden, die GAL-Logik von außen zu beeinflussen. Unser GAL hat noch genügend Eingänge, sodass wir einen Pin zum ROM-Ein-/Ausschalter machen wollen. Lesezugriffe nach $e000-$ffff sollen also nur noch dann im ROM landen, wenn es &amp;ldquo;eingeschaltet&amp;rdquo; ist. Sonst wollen wir ins RAM.</description><content>&lt;p>Wir sind jetzt also fast in der Lage, das RAM unter dem ROM zu nutzen. Hineinschreiben geht, lesen noch nicht. Da ist das ROM noch im Weg. Wir müssen also einen Weg finden, die GAL-Logik von außen zu beeinflussen. Unser GAL hat noch genügend Eingänge, sodass wir einen Pin zum ROM-Ein-/Ausschalter machen wollen. Lesezugriffe nach $e000-$ffff sollen also nur noch dann im ROM landen, wenn es &amp;ldquo;eingeschaltet&amp;rdquo; ist. Sonst wollen wir ins RAM. Die wiederum erweiterte Logik im GAL sieht jetzt so aus:&lt;/p>
&lt;p>/CSHIRAM = G1*/A2                                 + G1*/A1*/A0          + /RW*G1*A2*A1 ; Writes to $e000-$ffff go to the RAM          + /ROMOFF*RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the RAM, IF ROMOFF is Low /CSROM   = ROMOFF*RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the ROM, IF ROMOFF is High ROMOFF haben wir Pin 13 des GAL zugeordnet. Und tatsächlich startet unser Steckschwein nur noch, wenn dieser PIN mittels eines PullUp-Widerstands nach High gezogen wird.  Lassen wir unser Testprogramm aus dem letzten Post nochmal laufen:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Das gewohnte Bild, Lesezugriff geht ins ROM, Schreibzugriff ins RAM. Jetzt ziehen wir ROMOFF auf Masse und schalten damit das ROM aus:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Volltreffer, das ROM wird nicht mehr selektiert, wir landen immer im RAM. ROMOFF müssen wir jetzt nur noch per Software steuerbar machen, und unser nutzbares RAM hat sich um 8k erweitert, sofern wir in Kauf nehmen, dass wir keine ROM-Routinen verwenden können, solange wir dort lesen. Aber das ist beim C64 ja auch nicht anders. Ein konkreter Verwendungszweck der neuen Dekoderlogik drängt sich bereits auch ohne Softwaresteuerung der ROMOFF-Leitung auf: Das Testen neuer Versionen des ROM-Code(BIOS) ohne jedesmal das EEPROM brennen zu müssen. Schon richtig modern. Als abschließendes Experiment verbinden wir ROMOFF mit dem Bit0 von Port A der VIA. Die VIA hat die angenehme Eigenschaft, dass ihre Ports im Urzustand immer als Eingänge geschaltet sind und die Pins durch interne Pullups auf H gezogen werden. Um jetzt aus dem RAM ab $e000 zu lesen, brauchen wir nur Bit 0 von Port A der VIA zu löschen. Folgendes Programm testet, ob das auch so klappt: lda #000001         sta via1porta ; Pin 0 von Port A auf 1 setzen -&amp;gt; ROM ein         sta via1ddra  ; Pin 0 von Port A als Ausgang setzen lda #$00         ldx #$42         stx $e000     ; $42 landet im RAM dec via1porta ; Pin 0 von Port A ist jetzt 0 -&amp;gt; ROM  aus         lda $e000     ; $42 aus dem RAM lesen         inc via1porta ; -&amp;gt; ROM ein jsr lcdhex&lt;/p>
&lt;p>&amp;hellip; und auf dem LCD erscheint die $42. Freude.&lt;/p></content></item><item><title>Schlauer(er) Decoder</title><link>https://www.steckschwein.de/post/schlauerer-decoder/</link><pubDate>Tue, 01 Jul 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/schlauerer-decoder/</guid><description>Im Rahmen unserer Reihe &amp;ldquo;Kleine Verbesserungen an der Architektur&amp;rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:</description><content>&lt;p>Im Rahmen unserer Reihe &amp;ldquo;Kleine Verbesserungen an der Architektur&amp;rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:&lt;/p>
&lt;p>/CSHIRAM = G1*/A2                          + G1*/A1*/A0 /CSROM   = G1*A2                  Wir machen also die CS-Signale statisch von der anliegen Adresse abhängig. Aber es sollte doch möglich sein, grundsätzlich auch zwischen Reads und Writes auf die entsprechenden Adressen zu unterscheiden, oder? Die /RW-Leitung des Prozessors liegt ohnehin am GAL an. Was spricht dagegen, Lesezugriffe nach $e000-$ffff aus dem ROM zu holen, Schreibzugriffe aber immer ins RAM zu leiten? Der C64 kann das schließlich auch. Schreiben wir ein kleines Testprogramm:&lt;/p>
&lt;p>main ldx #$00 loop lda $e000,x sta $e000,x inx cpx #$ff bne loop jmp main&lt;/p>
&lt;p>Wir lesen also aus dem ROM-Bereich und schreiben gleich wieder zurück. Das Oszilloskop zeigt uns /CSHIRAM (gelb) und /CSROM (blau):&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Die Schreibzugriffe landen erwartungsgemäß nicht im RAM, dieses wird zu keiner Zeit selektiert.&lt;/p>
&lt;p>Jetzt passen wir die Gleichungen für /CSHIRAM und /CSROM an, indem wir die Abhängigkeit von /RW berücksichtigen:&lt;/p>
&lt;p>/CSHIRAM = G1*/A2&lt;/p>
&lt;ul>
&lt;li>
&lt;p>G1*/A1*/A0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/RW*G1*A2*A1 ; Writes to $e000-$ffff go to the RAM&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>/CSROM   = RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the ROM&lt;/p>
&lt;p>Und jetzt lassen wir unser Programm nochmal laufen:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Wir erkennen einen Lesezugriff (/CSROM, LDA $e000,x) und direkt darauf einen Schreibzugriff ins RAM (/CSHIRAM, STA $e000,x).&lt;/p>
&lt;p>Hurra, schreiben wir jetzt &amp;ldquo;ins ROM&amp;rdquo;, landen unsere Schreibzugriffe automatisch im darunterliegenden RAM. Allerdings nützt uns das noch nichts, denn noch können wir aus dem RAM nicht lesen.&lt;/p>
&lt;p>Im nächsten Teil erweitern wir also die GAL-Logik um einen Steuerpin, mit dem wir das ROM vollständig ausblenden und das RAM entsprechend freilegen können.&lt;/p></content></item><item><title>Verfeinerungen am Design</title><link>https://www.steckschwein.de/post/verfeinerungen-am-design/</link><pubDate>Tue, 24 Jun 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/verfeinerungen-am-design/</guid><description>So langsam geht es weiter mit der Steckschweinentwicklung.
Die Timingprobleme mit dem VDP bedürfen einer eingehenden Prüfung und Messung, um genau zu verstehen, wo was nicht passt. Unsere Ideen mit Puffern und/oder versetzten Taktsignalen, um den VDP früher &amp;ldquo;kommen&amp;rdquo; zu lassen stellen wir zurück, bis wir gesicherte Erkenntnisse haben. Ein Herumdoktern aufgrund von Vermutungen halten wir nicht für zielführend. Vorher ist es auch nicht sinnvoll, irgendwelche Platinen zu löten.
Stattdessen stecken wir ein wenig Hirnschmalz ins aktuelle Design.</description><content>&lt;p>So langsam geht es weiter mit der Steckschweinentwicklung.&lt;/p>
&lt;p>Die Timingprobleme mit dem VDP bedürfen einer eingehenden Prüfung und Messung, um genau zu verstehen, wo was nicht passt. Unsere Ideen mit Puffern und/oder versetzten Taktsignalen, um den VDP früher &amp;ldquo;kommen&amp;rdquo; zu lassen stellen wir zurück, bis wir gesicherte Erkenntnisse haben. Ein Herumdoktern aufgrund von Vermutungen halten wir nicht für zielführend. Vorher ist es auch nicht sinnvoll, irgendwelche Platinen zu löten.&lt;/p>
&lt;p>Stattdessen stecken wir ein wenig Hirnschmalz ins aktuelle Design. Die Anbindung des UART fällt negativ auf. Hier wurde der &lt;a href="http://www.6502.org/users/andre/icaphw/c64ser.html">Ansatz von Andre Fachat&lt;/a> quasi 1:1 kopiert, sodass der GAL die Signale /RD und /WR für den UART abhängig von PHI2 und der angelegten Adresse erzeugt, während PHI2 ausserdem an CS1 des UART anliegt. Das funktioniert, fügt sich aber nicht ganz in unser Design ein.&lt;/p>
&lt;p>Eigentlich sollte es möglich sein, im GAL ein einfaches /CS-Signal für den UART zu erzeugen. Die Aufsplittung von /WR nach /OE und /WE haben wir ja ohnehin schon gemacht, sodass wir diese einfach direkt an /RD und /WR des UART geben können. Dadurch, dass PHI2 und /OE, /WE durch tPROP des 7400 versetzt sind, sollte sich hier dann auch eine Timingfehlerquelle in Luft aufgelöst haben. Als angenehmer Nebeneffekt wird wieder ein Output Pin am GAL frei.&lt;/p>
&lt;p>Erste Tests haben gezeigt, dass nun auch unser &lt;a href="http://8bit-gefriemel.blogspot.de/2014_04_02_archive.html">&amp;ldquo;OK&amp;rdquo;-Problem&lt;/a>, hinter dem wir lange hinterhergesucht haben, nicht mehr auftritt, egal, ob wir das System wie von WDC empfohlen direkt mit dem Oszillator takten oder ob wir 6502-Oldschool den Taktausgang des Prozessors PHI2O benutzen.&lt;/p></content></item><item><title>Von Hummeln und Puffern</title><link>https://www.steckschwein.de/post/von-hummeln-und-puffern/</link><pubDate>Mon, 02 Jun 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/von-hummeln-und-puffern/</guid><description>Nach dem VCFe ist erstmal nicht viel aktive Entwicklung passiert. Vielmehr haben wir die Erkenntnis, dass wir ein grundsätzliches Timing-Problem haben (danke nochmal an Udo Möller) ein klein wenig sacken lassen. Im Grunde genommen ist es so, wie es sich aus dem vorletzten Post schon herauslesen läßt. Der WDC 65c02 hat eine Data Hold Time von 10ns, während der TMS9929 30ns braucht, sein Zeug vom Bus zu holen. Die verwendeten 16550er UARTs auch.</description><content>&lt;p>Nach dem VCFe ist erstmal nicht viel aktive Entwicklung passiert. Vielmehr haben wir die Erkenntnis, dass wir ein grundsätzliches Timing-Problem haben (danke nochmal an Udo Möller) ein klein wenig sacken lassen. Im Grunde genommen ist es so, wie es sich aus dem vorletzten Post schon herauslesen läßt. Der WDC 65c02 hat eine Data Hold Time von 10ns, während der TMS9929 30ns braucht, sein Zeug vom Bus zu holen. Die verwendeten 16550er UARTs auch. Eine klassische Hold Time Violation also. Ein bisschen muss man sich da schon wundern, dass das Zeug überhaupt funktioniert und so erklärt sich auch der ein oder andere staunende Blick auf dem VCFe. &lt;a href="http://www.ist-schlau.de/">Simon&lt;/a> schlägt vor, das Projekt &amp;ldquo;Bumblebee&amp;rdquo; zu nennen, da Hummeln bekanntlich rein physikalisch gar nicht fliegen können, es aber dennoch tun, weil ihnen Physik total egal ist.&lt;/p>
&lt;p>Wir treffen 3 Entscheidungen:&lt;/p>
&lt;ol>
&lt;li>Wir halten am WDC-Prozessor fest. Die &amp;ldquo;alten&amp;rdquo; Rockwells haben 30ns Hold Time, damit treten die Timingprobleme mit dem TMS9929 kaum auf und das sogar bei 2MHz. Hingegen sind die WDC-Chips weiterhin neu verfügbar, und daran möchten wir uns orientieren.&lt;/li>
&lt;li>Wir brauchen Platinen. Steckbretter bringen bekanntlich ihre ganz eigenen Fehlerquellen mit sich, und Fehlersuche in dem Gestrüpp gestaltet sich zunehmend schwieriger. Zudem ist der TMS9929 mit seinen DRAMs derart empfindlich, das wir spätestens hier nicht um einen stabilen, gelöteten Aufbau herumkommen. Der aktuelle Stand soll also auf einzelne Lochrasterkarten verteilt werden. Diese verbinden wir mit einem einem 50pol. Flachbandkabel (SCSI-2) als &amp;ldquo;Backplane&amp;rdquo;.&lt;/li>
&lt;li>Wir brauchen Puffer. Wir hoffen, die Hold Times dadurch in den Griff zu bekommen, indem wir den Datenbus und die entsprechenden Steuerleitungen puffern. In der Bastelkiste liegen 74ls245, diese sollten es tun. Sinn der Übung ist es, die Verzögerungen aufzufangen, die durch die Adressdekodierung im GAL entstehen und somit 10-15ns Zeit &amp;ldquo;rauszuholen&amp;rdquo;. Datenleitungen, Steuerleitungen und CS-Signale sollten dann keinen nennenswerten Versatz mehr aufweisen. Schaltpläne folgen.&lt;/li>
&lt;/ol></content></item><item><title>VCFe 15 - Schön wars!</title><link>https://www.steckschwein.de/post/vcfe-15-schoen-wars/</link><pubDate>Sun, 04 May 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/vcfe-15-schoen-wars/</guid><description>Das VCFe 15 ist zu Ende, wo eine größere Öffentlichkeit unsere Steckschweine und Experimente live in Augenschein nehmen konnte, und wo wir am Sonntag Mittag auch einen kleinen Vortrag zu Entstehung der Idee, des Steckschweins und Problemen halten durften.
Wer uns verpasst hat, findet zumindest hier die Folien.
Wir sind immer noch überwältigt von all der positiven Resonanz, die wir erfahren haben. Insgeheim hatten wir eher damit gerechnet, dass unsere Basteleien von den Cracks eher belächelt würden, aber das Gegenteil war der Fall.</description><content>&lt;p>Das &lt;a href="http://www.vcfe.org/D/">VCFe 15&lt;/a> ist zu Ende, wo eine größere Öffentlichkeit unsere Steckschweine und Experimente live in Augenschein nehmen konnte, und wo wir am Sonntag Mittag auch einen kleinen Vortrag zu Entstehung der Idee, des Steckschweins und Problemen halten durften.&lt;/p>
&lt;p>Wer uns verpasst hat, findet zumindest hier &lt;a href="https://drive.google.com/file/d/0B82yoNWUtYziaHJscW9sVjVpNVk/edit?usp=sharing">die Folien&lt;/a>.&lt;/p>
&lt;p>Wir sind immer noch überwältigt von all der positiven Resonanz, die wir erfahren haben. Insgeheim hatten wir eher damit gerechnet, dass unsere Basteleien von den Cracks eher belächelt würden, aber das Gegenteil war der Fall. So viel konstruktive Vorschläge, fachliche Unterstützung und sogar Sachspenden - damit haben wir nicht gerechnet und wir freuen uns tierisch! Vielen Dank an alle!&lt;/p>
&lt;p> &lt;/p>
&lt;p>&lt;a href="https://steckschwein.files.wordpress.com/2014/05/16910-img-20140502-wa0008.jpg">&lt;img src="images/16910-img-20140502-wa0008.jpg" alt="">&lt;/a>&lt;/p>
&lt;p> &lt;/p>
&lt;p>&lt;a href="https://steckschwein.files.wordpress.com/2014/05/51450-img-20140503-wa0000.jpg">&lt;img src="images/51450-img-20140503-wa0000.jpg" alt="">&lt;/a>&lt;/p></content></item><item><title>Murphy III - Timing ist alles</title><link>https://www.steckschwein.de/post/murphy-iii-timing-ist-alles/</link><pubDate>Mon, 14 Apr 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/murphy-iii-timing-ist-alles/</guid><description>In den Posts http://8bit-gefriemel.blogspot.de/2014/03/murphy.html und http://8bit-gefriemel.blogspot.de/2014/04/murphy-ii.html sind einige merkwürdige Phänomene und deren Lösungsversuche geschildert. Wie sich heute gezeigt hat, konnten wir gar nicht weiter daneben liegen.
Alles Quatsch. Die Fehlersuche nach dem &amp;ldquo;K&amp;rdquo;-Problem. Stack und so. Alles super. Klar, das mit dem Initialisieren des Stackpointers war natürlich richtig und wichtig, und dass die uart_tx routine besser funktioniert wenn man auf Stack-Operationen verzichtet, hätte uns eigentlich eher stutzig machen sollen. Aber der Reihe nach.</description><content>&lt;p>In den Posts &lt;a href="http://8bit-gefriemel.blogspot.de/2014/03/murphy.html">http://8bit-gefriemel.blogspot.de/2014/03/murphy.html&lt;/a> und &lt;a href="http://8bit-gefriemel.blogspot.de/2014/04/murphy-ii.html">http://8bit-gefriemel.blogspot.de/2014/04/murphy-ii.html&lt;/a> sind einige merkwürdige Phänomene und deren Lösungsversuche geschildert. Wie sich heute gezeigt hat, konnten wir gar nicht weiter daneben liegen.&lt;/p>
&lt;p>Alles Quatsch. Die Fehlersuche nach dem &amp;ldquo;K&amp;rdquo;-Problem. Stack und so. Alles super. Klar, das mit dem Initialisieren des Stackpointers war natürlich richtig und wichtig, und dass die uart_tx routine besser funktioniert wenn man auf Stack-Operationen verzichtet, hätte uns eigentlich eher stutzig machen sollen. Aber der Reihe nach.&lt;/p>
&lt;p>Der alte Rockwell 65c02P4 wurde nämlich derweil durch einen funkelnagelneuen WDC 65c02S6TPG-14 ersetzt. Dieser brauchte zunächst einen Pullup-Widerstand für den BE-Pin, ohne den sich seine Bus-Leitungen im Tri-State-Zustand befunden hätten. Toll, wenn man den Prozessor vom Bus trennen muss, weil er ihn sich z.B. mit einem Grafikchip teilen muss. In unserem Fall aber ist der 65c02 immer der Chef. Also auf high mit dem Pin.&lt;/p>
&lt;p>Relativ unvermittelt und mit keiner zu dem Zeitpunkt offensichtlichen Änderung an der Schaltung traten dann die oben beschriebenen Probleme auf. Die Fehlersuche brachte durchaus einiges zu Tage, wie beispielsweise die bislang nicht vorhandene Initialisierung des Stackpointers, jedoch führte nichts wirklich zu einer Lösung. Die Änderung der uart_tx_routine führte dazu, dass der Upload wieder funktioniert. Bis das Problem nach einem BIOS-Update mit kaum Code-Änderungen wieder auftrat. Diesmal mit einem nicht immer erfolgreich durchlaufenden Speichertest. Das K-Problem war zurück, und hat Verstärkung mitgebracht.&lt;/p>
&lt;p>Es half nichts. Es blieb nur, zu rekapitulieren, welche Änderungen an der Schaltung vorgenommen wurden. In Chris Wards ursprünglichem Design waren die OE-Pins der 62256 SRAMS direkt mit den CS-Pins verbunden. Ein selektierter Chip hatte also automatisch auch seine Daten auf den Bus gelegt. Dies ist möglich, weil die WE-Leitung bei den verwendeten HY62256ALP-10-Bausteine ohnehin immer Vorrang hat. Aus irgendeinem Grund hat mir das nicht gefallen und ich habe die OE-Pins mit dem generierten OE-Signal verbunden, welches auch den OE-Pin des EEPROM steuert. Bislang hat dies auch immer problemlos funktioniert. Interessanterweise traten aber auch auf Markos Schaltung unerklärliche Phänomene auf, nachdem diese Modifikation dort vorgenommen wurde.&lt;/p>
&lt;p>Dann der WDC-Prozessor. Hatte es diese Probleme auch mit dem Rockwell gegeben? Der WDC kann schließlich mit bis zu 14MHz getaktet werden, der Rockwell immerhin mit 4 MHz. Zeit, mal einen Blick ins Datenblatt zu werfen. Schnell fällt auf, dass der Rockwell z.B. eine Address hold time von 30ns hat, der WDC aber nur 10ns. Eigentlich klar, der Chip ist für weit höhere Frequenzen ausgelegt, also sind auch die Timings empfindlicher. Aber dann sollte uns noch eine Sache wie Schuppen von den Augen fallen&amp;hellip;&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Eingehendere Lektüre des WDC-Datenblatts liess uns dann noch auf folgende Perle stoßen:&lt;/p>
&lt;p>&lt;em>An external oscillator is recommended for driving PHI2 and used for the main system clock. All production test timing is based on PHI2. &lt;strong>PHI2O and PHI1O were used in older systems for system timing&lt;/strong> and internal oscillators when an external crystal was used.&lt;/em> Und weiter, als Fußnote zu den Timings:&lt;/p>
&lt;ol>
&lt;li>PHI1O and PHI2O clock delay from PHI2 is no longer specified or tested and WDC recommends using an oscillator for system time base and PHI2 processor input clock.&lt;/li>
&lt;/ol>
&lt;p>Jeder 6502 hat bisher das Systemtiming selbst generiert und am Pin PHI2O bereitgestellt. Von dort aus wurde alles mit Takt versorgt, was einen Takteingang hat. Damit hat WDC nun gebrochen und empfiehlt, den Systemtakt direkt am Oszillator abzugreifen. Das hatten wir beim Austausch Rockwell gegen WDC natürlich nicht berücksichtigt, wer denkt denn an sowas. Unser Rechner hat seinen Takt old-school-like vom PHI2O bezogen. Der Screenshot vom Logic Analyzer zeigt, dass PHI2O manchmal, aber nicht immer einen Versatz.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Dementsprechend war die Lösung des Problems dann denkbar simpel: Die Taktleitungen für den Rest des Systems 2 Pins weiter nach rechts gesteckt.&lt;/p>
&lt;p>Bleibt die Frage, was man denn macht, wenn man einen 65c02 aus einem alten System ersetzen möchte. Der WDC dürfte ohne Anpassungen nicht stabil laufen.&lt;/p></content></item><item><title>TMS9929 Wir sind am Ziel!</title><link>https://www.steckschwein.de/post/tms9929-wir-sind-am-ziel/</link><pubDate>Mon, 14 Apr 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/tms9929-wir-sind-am-ziel/</guid><description>Nachdem das Timing vom Steckschwein grundsätzlich passt, sind auf einmal auch sämtliche Voodoo-Fehler verschwunden.
Jetzt lässt sich der VDP auch besser ansprechen, allerdings gibt es schon noch ein paar Probleme zu lösen, bspw. ist das DRAM sehr instabil irgendwie flackert ständig der Screen oder die Zeichen &amp;ldquo;Nullen&amp;rdquo; sich aus. Wir untersuchen das Steckbrett und die Spannungsversorgung. Wir beschließen, die Steckbrettkabel durch kurze blanke Drahtbrücken zu ersetzen und platzieren direkt am Vcc der einzelnen DRAMs die Abblock-Kondensatoren mit 100nF.</description><content>&lt;p>Nachdem das Timing vom Steckschwein grundsätzlich passt, sind auf einmal auch sämtliche Voodoo-Fehler verschwunden.&lt;/p>
&lt;p>Jetzt lässt sich der VDP auch besser ansprechen, allerdings gibt es schon noch ein paar Probleme zu lösen, bspw. ist das DRAM sehr instabil irgendwie flackert ständig der Screen oder die Zeichen &amp;ldquo;Nullen&amp;rdquo; sich aus. Wir untersuchen das Steckbrett und die Spannungsversorgung. Wir beschließen, die Steckbrettkabel durch kurze blanke Drahtbrücken zu ersetzen und platzieren direkt am Vcc der einzelnen DRAMs die Abblock-Kondensatoren mit 100nF. Genauso die Spannungsversorgung des VDPs, hier auch nochmal kurze Drahtbrücken verwenden und einen Abblock-Kondensator direkt an Vcc vorsehen.&lt;/p>
&lt;p>Wow, das Bild steht! Wie auf den Fernseher gemalt.Wir verbiegen den C64 Zeichensatz noch soweit, dass wir bequem ASCII-Zeichen als Text eingeben können ohne umständlich zu konvertieren.&lt;/p>
&lt;p>Und so sieht&amp;rsquo;s dann aus.&lt;/p>
&lt;p>&lt;a href="https://steckschwein.files.wordpress.com/2014/04/9b2ed-vdp_breakthrough.jpg">&lt;img src="images/9b2ed-vdp_breakthrough.jpg" alt="TMS9929 displaying cbm 64 letters" title="TMS9929 ">&lt;/a>&lt;/p></content></item><item><title>Schaltplan</title><link>https://www.steckschwein.de/post/schaltplan/</link><pubDate>Sat, 05 Apr 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/schaltplan/</guid><description>Damit Klarheit darüber herrscht, worum es überhaupt geht, haben wir den Schaltplan in die einzelnen Gruppen (Prozessor+ Freunde, Speicher, UART) zerlegt.
Die aktuelle Stückliste liest sich laut Eagle folgendermaßen:
Part Value Device C1 100n C5/3 C3 1n C-EU025-025X050 C4 10n C-EU025-025X050 C5 10µF CPOL-EUE2,5-6E C6 100n C5/3 C7 100n C5/3 C8 100n C5/3 C12 1µF CPOL-EUE2,5-6E C13 100n C5/3 C14 100n C5/3 C15 100n C5/3 C16 1µF CPOL-EUE2,5-6E C17 1µF CPOL-EUE2,5-6E C18 1µF CPOL-EUE2,5-6E C19 1µF CPOL-EUE2,5-6E IC1 CY62256LL-PC CY62256LL-PC IC3 CY62256LL-PC CY62256LL-PC IC4 NE555 NE555 IC5 28c64 2864 IC6 16550 UART XR-16C550P IC8 74LS06N 74LS06N IC9 GAL22V10 22V10 IC10 MAX232 MAX232 QG1 2MHz XO-14 QG2 1.</description><content>&lt;p>Damit Klarheit darüber herrscht, worum es überhaupt geht, haben wir den Schaltplan in die einzelnen Gruppen (Prozessor+ Freunde, Speicher, UART) zerlegt.&lt;/p>
&lt;p>Die aktuelle Stückliste liest sich laut Eagle folgendermaßen:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Part    &lt;/th>
&lt;th>Value          &lt;/th>
&lt;th>Device&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>C1      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C3      &lt;/td>
&lt;td>1n            &lt;/td>
&lt;td>C-EU025-025X050&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C4      &lt;/td>
&lt;td>10n            &lt;/td>
&lt;td>C-EU025-025X050&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C5      &lt;/td>
&lt;td>10µF          &lt;/td>
&lt;td>CPOL-EUE2,5-6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C6      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C7      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C8      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C12      &lt;/td>
&lt;td>1µF            &lt;/td>
&lt;td>CPOL-EUE2,5-6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C13      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C14      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C15      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3           &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C16      &lt;/td>
&lt;td>1µF            &lt;/td>
&lt;td>CPOL-EUE2,5-6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C17      &lt;/td>
&lt;td>1µF            &lt;/td>
&lt;td>CPOL-EUE2,5-6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C18      &lt;/td>
&lt;td>1µF            &lt;/td>
&lt;td>CPOL-EUE2,5-6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C19      &lt;/td>
&lt;td>1µF            &lt;/td>
&lt;td>CPOL-EUE2,5-6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC1      &lt;/td>
&lt;td>CY62256LL-PC  &lt;/td>
&lt;td>CY62256LL-PC  &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC3      &lt;/td>
&lt;td>CY62256LL-PC  &lt;/td>
&lt;td>CY62256LL-PC  &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC4      &lt;/td>
&lt;td>NE555          &lt;/td>
&lt;td>NE555        &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC5      &lt;/td>
&lt;td>28c64          &lt;/td>
&lt;td>2864          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC6      &lt;/td>
&lt;td>16550 UART    &lt;/td>
&lt;td>XR-16C550P    &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC8      &lt;/td>
&lt;td>74LS06N        &lt;/td>
&lt;td>74LS06N      &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC9      &lt;/td>
&lt;td>GAL22V10      &lt;/td>
&lt;td>22V10        &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC10    &lt;/td>
&lt;td>MAX232        &lt;/td>
&lt;td>MAX232         &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>QG1      &lt;/td>
&lt;td>2MHz          &lt;/td>
&lt;td>XO-14&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>QG2      &lt;/td>
&lt;td>1.8432MHz      &lt;/td>
&lt;td>XO-14&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R2      &lt;/td>
&lt;td>3.3k          &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R3      &lt;/td>
&lt;td>1M            &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R4      &lt;/td>
&lt;td>1M            &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R5      &lt;/td>
&lt;td>3.3k          &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R6      &lt;/td>
&lt;td>3.3k          &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R7      &lt;/td>
&lt;td>3.3k          &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R8      &lt;/td>
&lt;td>3.3k          &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R9      &lt;/td>
&lt;td>4.7k          &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S1      &lt;/td>
&lt;td>DTE6          &lt;/td>
&lt;td>DTE6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>U1      &lt;/td>
&lt;td>65c02          &lt;/td>
&lt;td>G65SC02P&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>U3      &lt;/td>
&lt;td>65c22          &lt;/td>
&lt;td>G65SC22P&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>V1      &lt;/td>
&lt;td>74138N        &lt;/td>
&lt;td>74138N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>V2      &lt;/td>
&lt;td>74LS00N        &lt;/td>
&lt;td>74LS00N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>X2      &lt;/td>
&lt;td>RS232          &lt;/td>
&lt;td>F09HP&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;img src="images/28878-cpu.png" alt="CPU">
Der 65c02-Prozessor nebst Oszillator und RESET-Schaltung, welche aus dem Commodore-PET übernommen wurde und dem GAL, der zu Dekodierung des Adressbereichs von $8000 bis $ffff dient. Nicht zu sehen ist der Pull-Up-Widerstand für die BE (Bus Enable)-Leitung der WDC-Variante des 65x02, ohne den der Prozessor in einen Tri-State-Zustand geht und sich vom Bus abkoppelt.&lt;/p>
&lt;p>&lt;img src="images/e4c5e-romram.png" alt="ROMRAM">
Das EEPROM und die beiden 32k SRAM-Bausteine. Etwas schwer zu erkennen: die Adressleitung A15 des Prozessors dient den &amp;ldquo;unteren&amp;rdquo; 32k (IC1) als CS-Signal. Das CS_HIRAM-Signal hingegen erzeugt der GAL (siehe oben). Der Schaltplan unterschlägt, dass wir in Wirklichkeit ein 28c256-EEPROM verwendet haben, welches wir durch auf Masse legen von A14 und A13 auf 8k &amp;ldquo;kastriert&amp;rdquo; haben.&lt;/p>
&lt;p>&lt;img src="images/e0273-uart.png" alt="UART">
Der UART + Glue Logic, um dessen Bus-Interface an das des 65c02 anzupassen. Die Invertierung von RESET und INT(IRQ) übernimmt ein 74ls06. Beim RESET-Signal ist aufgrund dessen Open Collector-Treibers noch ein Pull-Up-Widerstand nötig.&lt;/p>
&lt;p>&lt;img src="images/b3061-rs232.png" alt="rs232">
Der Vollständigkeit halber.&lt;/p>
&lt;p>&lt;img src="images/9ee9c-via.png" alt="VIA"> Die Anbindung der 65x22 VIA gestaltet sich trivial und erweitert unseren kleinen Rechner um vielseitige IO-Möglichkeiten.&lt;/p></content></item><item><title>Exkurs: Wie kommt Code aufs Steckschwein?</title><link>https://www.steckschwein.de/post/exkurs-wie-kommt-code-aufs-steckschwein/</link><pubDate>Thu, 03 Apr 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/exkurs-wie-kommt-code-aufs-steckschwein/</guid><description>Die Programmierung eines Computers, der nur aus einer gesteckten Schaltung besteht und weder Tastatur noch Speichermöglichkeit hat, ist eine mühsame Angelegenheit. Die allerersten Experimente bekamen ihr Futter auf einem 27128-EPROM serviert. Bekanntlich wollen diese vor dem Beschreiben mit neuem Code mit UV-Licht gelöscht werden. Also wurde für jedes Update ein EPROM mit neuem Code gebrannt, um die EPROMS anschließend in 10er-Packen ins Löschgerät zu schieben. 15 Minuten Kaffeepause.
Überhaupt, Code: Für die ersten Experimente hat es genügt, die reinen Hexcodes in einen Hexeditor zu tippen und die Daten dann zu brennen.</description><content>&lt;p>Die Programmierung eines Computers, der nur aus einer gesteckten Schaltung besteht und weder Tastatur noch Speichermöglichkeit hat, ist eine mühsame Angelegenheit. Die allerersten Experimente bekamen ihr Futter auf einem 27128-EPROM serviert. Bekanntlich wollen diese vor dem Beschreiben mit neuem Code mit UV-Licht gelöscht werden. Also wurde für jedes Update ein EPROM mit neuem Code gebrannt, um die EPROMS anschließend in 10er-Packen ins Löschgerät zu schieben. 15 Minuten Kaffeepause.&lt;/p>
&lt;p>Überhaupt, Code: Für die ersten Experimente hat es genügt, die reinen Hexcodes in einen Hexeditor zu tippen und die Daten dann zu brennen. Dies war vertretbar, da die ersten Programme etwa so aussahen: EA EA EA EA EA EA EA EA C9 C9 C9 C9 C9 C9 C9 C9 4C 00 0E&lt;/p>
&lt;p>Der Erwerb einiger EEPROMS des Typs 28c256 stellten eine große Erleichterung dar, als das Steckschwein langsam zu einem &amp;ldquo;richtigen&amp;rdquo; Computer und der Testcode damit immer umfangreicher würde. Die UV-Kaffeepausen entfielen, der Chip konnte einfach wieder neu gebrannt werden. Moderne Zeiten.&lt;/p>
&lt;p>Auch der komplexere Code erforderte langsam neue Herangehensweisen. Komplexere Routinen wurden auf dem C64 im Maschinensprachemonitor vorgeschrieben und die Hexcodes dann abgetippt und auf EEPROM gebrannt (ja, echt). Aber auch mühselig. Neues Werkzeug musste her. Und zwar in Form des &lt;a href="https://sourceforge.net/projects/acme-crossass/">ACME-Crossassemblers&lt;/a>. Nach kurzer Eingewöhnung (warum haben wir das nicht gleich so gemacht?) konnte nun drauflosgecoded werden dass die Schwarte kracht. Wenn nur dieses leidige Chip Umstecken nicht wäre.&lt;/p>
&lt;p>Unser Steckschwein verfügte inzwischen über eine 65c51 ACIA und damit über eine RS232-Schnittstelle. Das mußte sich doch irgendwie nutzen lassen. Steckschwein-seitig sollte das BIOS nur die Hardware initialisieren, im Falle der ACIA die Verbindungsparameter (Baudrate, Stopbit..) setzen, und dann einfach nur die Schnittstelle pollen und auf Futter warten. Und dieses dann Byte für Byte in den Speicher schreiben und am Ende an diese Adresse springen.&lt;/p>
&lt;p>Auf der anderen Seite des rs232-Kabels entschieden wir uns, ein kleines Python-Programm zu schreiben, welches mittels &lt;a href="http://pyserial.sourceforge.net/">Pyserial&lt;/a> die Kommunikation übernehmen sollte. Als rätselhaft schwierig gestaltete es sich, Daten &amp;ldquo;am Stück&amp;rdquo; an das Steckschwein zu senden, die Kommunikation brach nach wenigen Bytes ab. Wir hielten das zunächst für eine Macke der an Macken nicht armen ACIA, und programmierten drum herum. Die Laderoutine auf dem Steckschwein quittierte jedes empfangene Byte mit einem &amp;ldquo;*&amp;rdquo;. Das Python programm schrieb ein Byte, und las ein &amp;ldquo;*&amp;rdquo;. Als &amp;ldquo;Ende-Markierung&amp;rdquo; dienten 5 Null-Bytes am Ende des Programms. Wurde also das fünfte $00 empfangen, nahm die Laderoutine keine Daten mehr entgegen und führte ein JMP $1000 aus, wo der Code auch seine Startadresse zu haben hatte. Diese Methode war auch bei 19200 baud ziemlich lahm, aber tat ihren Job erstmal. Kein elendes Chip umstecken mehr. Den angeblichen ACIA-Macken wurde keine weitere Beachtung mehr geschenkt, sollte die ACIA doch schließlich durch einen 16550 UART abgelöst werden. Vorher den Code nochmal anzufassen wäre nicht sinnvoll.&lt;/p>
&lt;p>Nachdem also besagter 16550 einige Nerven gekostet hatte (hierzu an anderer Stelle mehr), war es Zeit, die Uploadroutine zu überarbeiten. Zum Einen sollte nach einem berechtigen Einwand von Marko die Endmarkierung mit den 5 Nullbytes weg. Sowas kommt nämlich durchaus vor, wenn man mal Zeichensätze oder sowas hochladen will. Zum anderen wäre es praktisch, wenn man die Ladeadresse wählen könnte. Doch zuallererst sollte dieser *-Hack weg. Denn dieser war auch mit dem UART noch nötig. Also sind entweder ACIA und UART beide gleich bescheuert, oder wir machen irgendwas falsch.&lt;/p>
&lt;p>Eigentlich sollte es möglich sein, mittels&lt;/p>
&lt;p>ser.write(code)&lt;/p>
&lt;p>unseren ganzen Code komplett rüberzuschieben, ohne zwischendrin irgendeinen Pseudo-Handshake veranstalten zu müssen. Trotzdem kommen immer nur ein paar Bytes an, dann ist Schluß. Experimentieren mit irgendwelchen Timeout-Parametern von pyserial brachte keine Abhilfe. Nach einigem Probieren ging dann ein Licht an. Wir hatten folgendes probiert:&lt;/p>
&lt;p>ser.write(code) time.sleep(1)&lt;/p>
&lt;p>Und siehe da - der Code wurde komplett übertragen. Anscheinend ist es so, dass in pyserial write nicht blockiert, read nach eingestelltem Timeout aber schon. Jedenfalls ist das auf dem Mac so, zu testen ob sich pyserial auf anderen Systemen anders verhält, haben wir uns erspart.&lt;/p>
&lt;p>Ich schreibe die Uploadroutine so um, dass sie 2 Bytes erwartet, nämlich die Ladeadresse, dies dann mit &amp;ldquo;OK&amp;rdquo; quittiert, dann nochmal 2 Bytes, nämlich die Länge der zu übertragenden Daten, wieder &amp;ldquo;OK&amp;rdquo;, dann die Daten selbst, bis die entsprechende Anzahl Bytes empfangen wurde, dann wieder &amp;ldquo;OK&amp;rdquo;.&lt;/p>
&lt;p>Das Python-Programm macht demnach einfach bytes = ser.write(struct.pack(&amp;rsquo;&amp;lt;h&amp;rsquo;, startaddr))         if ser.read(2) == &amp;lsquo;OK&amp;rsquo;:                 print &amp;ldquo;Start address %d bytes&amp;rdquo; % (bytes, ) bytes = ser.write(struct.pack(&amp;rsquo;&amp;lt;h&amp;rsquo;, length))         if ser.read(2) == &amp;lsquo;OK&amp;rsquo;:                 print &amp;ldquo;Length %d bytes&amp;rdquo; % (bytes, ) bytes = ser.write(content)         if ser.read(2) == &amp;lsquo;OK&amp;rsquo;:                 print &amp;ldquo;Length %d bytes&amp;rdquo; % (bytes, )&lt;/p>
&lt;p>Das war&amp;rsquo;s. Einfacher gehts fast nicht, die Ladeaddresse ist frei wählbar, und wir übertragen den Code dank UART jetzt mit 115200 baud statt mit 19200.&lt;/p></content></item><item><title>Murphy II</title><link>https://www.steckschwein.de/post/murphy-ii/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/murphy-ii/</guid><description>Flugs also ein ROM gebrannt mit der memtest-routine, in die nach der Reset-Routine eingesprungen wird. Gleiches Ergebnis. Beim ersten Auftreten des &amp;ldquo;K statt OK&amp;rdquo;-Fehlers ist erstmal die doch etwas windig anmutende Verdrahtung der Adressleitungen zwischen Prozessor, den RAM-Bausteinen und dem ROM mit &amp;ldquo;richtigen&amp;rdquo; Steckbrettstrippen statt Klingeldraht nachverdrahtet worden. Das war vermutlich etwas voreilig, schließlich hats vorher ja auch schon funktioniert. Schließlich stellt sich heraus, dass sich hier in der Tat ein paar Fehler eingeschlichen haben, die auch beim Durchklingeln der einzelnen Adressleitungen nicht aufgefallen sind: Kurzschlüsse.</description><content>&lt;p>Flugs also ein ROM gebrannt mit der memtest-routine, in die nach der Reset-Routine eingesprungen wird. Gleiches Ergebnis. Beim ersten Auftreten des &amp;ldquo;K statt OK&amp;rdquo;-Fehlers ist erstmal die doch etwas windig anmutende Verdrahtung der Adressleitungen zwischen Prozessor, den RAM-Bausteinen und dem ROM mit &amp;ldquo;richtigen&amp;rdquo; Steckbrettstrippen statt Klingeldraht nachverdrahtet worden. Das war vermutlich etwas voreilig, schließlich hats vorher ja auch schon funktioniert. Schließlich stellt sich heraus, dass sich hier in der Tat ein paar Fehler eingeschlichen haben, die auch beim Durchklingeln der einzelnen Adressleitungen nicht aufgefallen sind: Kurzschlüsse.  Nachdem diese behoben wurden, läuft unser Speichertest auch wieder komplett durch.  Zeit also, sich dem eigentlichen Problem anzunehmen. Wo bleibt das &amp;ldquo;O&amp;rdquo;? Interessanterweise scheint das Empfangen von Daten nicht betroffen zu sein, denn die memtest-Routine funktioniert hochgeladen genauso wie aus dem ROM.  Also schaue ich mir die Routine an, die Daten (bytes) über den UART sendet.&lt;/p>
&lt;p>i_uart_tx         pha -       lda uart1lsr         and #$20         beq - pla         sta uart1rxtx&lt;/p>
&lt;p>rts&lt;/p>
&lt;p>Sieht doch erstmal nicht verkehrt aus. Ich mache trotzdem ein Experiment, und ersetze die Stackoperationen, indem ich stattdessen auf das X-Register ausweiche:&lt;/p>
&lt;p>i_uart_tx         tax -       lda uart1lsr         and #$20         beq - stx uart1rxtx rts Und auf einmal kriege ich mein &amp;ldquo;OK&amp;rdquo;. Schnall ich jetzt nicht. Ist der Stack kaputt? Ich mache mir ein paar grundsätzliche Gedanken und halte die Idee, den Stack Pointer einfach mal zu initialisieren, für gut. Ich packe entsprechenden Code an den Beginn der RESET-Routine, und lösche auch gleich das Dezimal-Flag. ; disable interrupt        sei ; clear decimal flag cld ; init stack pointer ldx #$ff&lt;/p>
&lt;p>txs&lt;/p>
&lt;p>Ich baue die uart_tx-Routine zurück und bekomme wieder nur &amp;ldquo;K&amp;rdquo;. Während also das Initialisieren des Stack-Pointers richtig und wichtig ist, ist unser Problem noch ein anderes. Die uart_tx-Routine sieht jetzt so aus, und bleibt so: i_uart_tx         pha         phx tax -       lda uart1lsr         and #$20         beq - stx uart1rxtx plx         pla&lt;/p>
&lt;p>rts&lt;/p>
&lt;p>Der Stack wird nach einem kurzen Testprogramm für fehlerfrei befunden. Trotzdem funktioniert die serielle Kommunikation noch nicht. Es kommt nicht das an, was gesendet wird. Das hat doch eigentlich schon funktioniert. Die Initialisierung des UART wird nochmal unter die Lupe genommen.&lt;/p>
&lt;p>lda #0        sta uart1fcr    ; FIFO off Das FCR-Register ist das FIFO-Control-Register. Die FIFO schalten wir durch das ablegen von 0 ab, da wir gerade nur Polling nutzen. Das Register bietet auch Bits zum löschen der Empfangs- und Sende-FIFO sowie setzen des &amp;ldquo;Füllstandes&amp;rdquo; bei welchen ein Interrupt ausgelöst werden soll. Laut Datenblatt aktiviert bzw. deaktiviert das Bit 0 dieses Registers die FIFO. Alle anderen Bits werden nur dann berücksichtigt, wenn Bit 0 auf 1 ist. Also vielleicht einfach mal pauschal die FIFOs löschen, und dann abschalten? lda #7            sta uart1fcr         lda #0       sta uart1fcr    ; FIFO off&lt;/p>
&lt;p>Das scheint richtig gewesen zu sein, wir haben wieder eine funktionierende Upload-Routine.&lt;/p>
&lt;p>Da ich mich inzwischen genug über den 16550 geärgert habe, beschließe ich, dass er mir ruhig was Gutes tun könnte, und setze den Baudraten-Divisor auf &amp;ldquo;1&amp;rdquo; und damit eine Baudrate von 115200.&lt;/p>
&lt;p>Die Feststellung, dass das sogar stabil funktioniert versöhnt mich fürs erste wieder und ich gehe zufrieden ins Bett.&lt;/p></content></item><item><title>... kein Spaß - Murphy schlägt zu</title><link>https://www.steckschwein.de/post/kein-spass-murphy-schlaegt-zu/</link><pubDate>Mon, 31 Mar 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/kein-spass-murphy-schlaegt-zu/</guid><description>Neben all den ermutigenden Experimenten gibt es natürlich auch immer mal wieder Rückschläge. Mittlerweile haben wir schon ein durchaus komplexes Gebilde auf dem Steckbrett, welches ja per se nicht die ideale Plattform ist, um so etwas zu bauen.
So wie aktuell gerade mein &amp;ldquo;Steckschwein&amp;rdquo; ein sehr merkwürdiges Verhalten an den Tag legt, ohne dass an der Schaltung etwas geändert worden wäre (Marko ist Zeuge).
Vorab nochmal der Ablauf unserer Upload-Routine, mit der wir das Steckschwein via RS232 mit Code befüttern:</description><content>&lt;p>Neben all den ermutigenden Experimenten gibt es natürlich auch immer mal wieder Rückschläge. Mittlerweile haben wir schon ein durchaus komplexes Gebilde auf dem Steckbrett, welches ja per se nicht die ideale Plattform ist, um so etwas zu bauen.&lt;/p>
&lt;p>So wie aktuell gerade mein &amp;ldquo;Steckschwein&amp;rdquo; ein sehr merkwürdiges Verhalten an den Tag legt, ohne dass an der Schaltung etwas geändert worden wäre (Marko ist Zeuge).&lt;/p>
&lt;p>Vorab nochmal der Ablauf unserer Upload-Routine, mit der wir das Steckschwein via RS232 mit Code befüttern:&lt;/p>
&lt;ol>
&lt;li>Transferprogramm sendet die Ladeaddresse (2 bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;li>Anzeige der Ladeaddresse im LCD&lt;/li>
&lt;li>Transferprogramm übermittelt die Länge der zu sendenden Daten (2 bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;li>Anzeige der Länge in Bytes im LCD&lt;/li>
&lt;li>Upload-Routine addiert Startaddresse + Länge in Bytes und errechnet so die Endadresse&lt;/li>
&lt;li>Anzeige der Endaddresse im LCD&lt;/li>
&lt;li>Transferprogramm sendet den Code (n bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;/ol>
&lt;p>Völlig unprovoziert wird auf einmal das &amp;ldquo;O&amp;rdquo; unterschlagen, sodass wir nur noch ein &amp;ldquo;K&amp;rdquo; erhalten. Dies läßt sich gut mit einem Terminalprogramm nachvollziehen. Um weiter debuggen zu können, passen wir das Transferprogramm an, dass es sich auch mit &amp;ldquo;K&amp;rdquo; zufriedengibt und laden eine echo-Routine, die die empfangenen Zeichen wieder über RS232 zurückschreibt und außerdem auf dem Display ausgibt.&lt;/p>
&lt;p>Wir beobachten, wie einige Zeichen wieder ge-echo-t werden, andere nicht, während sie nebst einigem Müll sowie der Ziffer 0 auf dem Display ausgegeben werden.&lt;/p>
&lt;p>Ein ähnliches Phänomen haben wir schon beim Einbau/Programmierung des UART beobachtet. Damals war der Fehler, dass die FIFO aktiviert war. Da wir den UART aktuell nur mittels Polling betreiben, gab es Probleme, die sich mit der Deaktivierung der FIFO beheben ließen. Das ist hier anders. Und zu allem Überfluss scheint das Phänomen zeitweilig auch wieder zu verschwinden. Will heissen: Ohne unser Zutun kam auch wieder ein &amp;ldquo;OK&amp;rdquo;. Dann wieder nicht mehr. Die zugegeben bis dato etwas windige Verdrahtung der Speicherchips wurde bei der Gelegenheit durch &amp;ldquo;richtige&amp;rdquo; Steckstrippen ersetzt. Die dabei entstandenen Fehler wurden schließlich auch gefunden, sodass wir mit einem Tag Verzug wieder so weit waren, das eigentliche Problem zu erforschen.&lt;/p>
&lt;p>Unsere Mem-Test-Routine läßt sich hochladen, zeigt aber immer denselben Fehler. Da wir nicht sicher sein können, ob die Routine tatsächlich korrekt hochgeladen wurde, macht weiteres Testen nur Sinn, wenn die dazu notwendigen Routinen bereits im ROM liegen.&lt;/p></content></item><item><title>ACIA muss wieder raus</title><link>https://www.steckschwein.de/post/acia-muss-wieder-raus/</link><pubDate>Fri, 28 Mar 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/acia-muss-wieder-raus/</guid><description>Die 65x51 ACIA erschien uns als die am tiefsten hängende Frucht, um eine RS232 Schnittstelle zu implementieren, nachdem wir Bit Banging nach C64 Vorbild ziemlich schnell verworfen hatten.
Auch programmiertechnisch mach die ACIA einen simplen Eindruck, ganze drei Register wollen beherrscht werden.
Die rs232-Schnittstelle ermöglicht uns, Code auf den Steckbrettrechner zu laden, ohne jedesmal das EEPROM neu brennen zu müssen. Eine gewaltige Erleichterung.
Aber - wir haben es bereits erwähnt - die ACIA hat keine Zukunft bei uns.</description><content>&lt;p>Die 65x51 ACIA erschien uns als die am tiefsten hängende Frucht, um eine RS232 Schnittstelle zu implementieren, nachdem wir Bit Banging nach C64 Vorbild ziemlich schnell verworfen hatten.&lt;br>
Auch programmiertechnisch mach die ACIA einen simplen Eindruck, ganze drei Register wollen beherrscht werden.&lt;br>
Die rs232-Schnittstelle ermöglicht uns, Code auf den Steckbrettrechner zu laden, ohne jedesmal das EEPROM neu brennen zu müssen. Eine gewaltige Erleichterung.&lt;/p>
&lt;p>Aber - wir haben es bereits erwähnt - die ACIA hat keine Zukunft bei uns. Die uns vorliegenden Chips können mit bis zu 2 MHz getaktet werden. Wir aber wollen hoch hinaus. Mit den aktuellen 65cXX-Chips von WDC sind schließlich bis zu 14MHz möglich.&lt;br>
Darüberhinaus sind mit der ACIA ohne Hacks nur 19200 baud möglich, und selbst hochgezüchtet sind mehr als 38400 baud nicht drin. Dazu kommt, dass es keinen Puffer gibt und für jedes empfangene Byte ein Interrupt ausgelöst werden müßte.&lt;/p>
&lt;p>Die Entscheidung ist gefallen. Die ACIA hat uns viel Spass gemacht, aber noch mehr Spass macht ein modernerer Schnittstellenchip: der 16550 UART, bekannt aus der Welt der IBM-kompatiblen.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Der 16550 kann zunächst einmal seine niedere Herkunft als PC-Chip nicht verbergen. Reset und Interrupt-Signal sind active high, sodass hier schonmal ein wenig Glue Logic vonnöten ist. Das Reset-Signal wird durch einen freien Inverter des 74ls04 geschickt. Um die IRQ-Leitung bei einem Interrupt auf L ziehen zu können, benötigen wir hier einen Inverter mit Open Collector-Ausgang. Dazu kommt ein 74ls06 zu Einsatz, der auch bis jetzt nichts anderes macht als das IRQ-Signal des UART zu verarbeiten.&lt;br>
Das Businterface erfordert weitere Anpassungen. Der 16550 hat ein jeweils separates Signal für RD (read) und WR (write), und zwar wahlweise eins als active high und eins als active low. Irgendwie muss man 40 Pins ja voll kriegen. Das jeweils nicht benötigte Signal wird entsprechend auf Potential gelegt. Also legen wir RD und WR auf Masse und kümmern uns nur noch um /RD und /WR.&lt;br>
Einen dedizierten Takteingang, wie wir es von den Chips der 65xx-Serie gewohnt sind, gibt es auch nicht.&lt;br>
Wir lassen uns von &lt;a href="http://www.6502.org/users/andre/icaphw/c64ser.html">Andre Fachats Umbau eines C64 auf 16550&lt;/a> inspirieren und legen CS0 auf High, CS2 auf Low und geben den Systemtakt PHI2 auf CS1. Somit ist der Chip immer nur selektiert, wenn PHI2 H ist. Die Adressdekodierung übernimmt hier wieder der GAL. Das CS-Signal von dort dient als Enable-Signal für einen 74ls138, der aus /RW und PHI2 separate /RD und /RW Signale dient. Der 74ls138 hat sogar noch einen Eingang und zwei Ausgänge frei, sodass sich unter Dazunahme einer weiteren Adressleitung sehr einfach ein zweiter UART unterbringen ließe. Auch hier dient die Arbeit von Andre Fachat als Vorbild.&lt;/p>
&lt;p>Richtig spassig wird der 16550 aber, wenn es an die Programmierung geht. Er verfügt über 12 Register, die an 8 Adressen ansprechbar sind. Auch Nicht-Mathematiker erkennen hier sofort, dass hier Registeradressen doppelt belegt sind. Registeradresse A beherbergt, wenn gelesen, also Register X, wenn geschrieben wird, ist es aber Register Y. Wahnsinn.&lt;br>
Quasi als kleiner Trost und Bonbon verfügt der 16550 dafür aber über das &amp;ldquo;Scratchpad&amp;rdquo;-Register. Dort kann man ein Byte ablegen und auch wieder lesen. Ansonsten beeinflusst es das Verhalten des Chips in keiner Weise. Die Bezeichnung &amp;ldquo;Scratchpad&amp;rdquo; legt nahe, dass dort Registerinhalte &amp;ldquo;entworfen&amp;rdquo; werden könnten, um sie dann von dort in das entsprechde Register zu übertragen. Nur verfügt der 16550 über keinerlei Möglichkeit, den Inhalt eines seiner Register ins Scratchpad zu legen oder von dort zu holen, sodass es jede andere Specherstelle genauso tut. Was bleibt ist, dass man quasi mit jedem verbauten 16550 ein Byte RAM gratis erhält. Sogesehen kann man gar nicht genug UARTs haben.&lt;/p></content></item><item><title>Das Design wird erweitert</title><link>https://www.steckschwein.de/post/das-design-wird-erweitert/</link><pubDate>Sun, 16 Mar 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/das-design-wird-erweitert/</guid><description>Sinn der Sache ist ja nicht, etwas 1:1 nachzubauen, sondern ein möglichst eigenes Design. Nachdem wir mit Chris&amp;rsquo; Design - bzw. dessen, was wir davon übernommen haben (Adressdekodierung, ACIA, VIA) - genug herumgespielt hatten, galt es, &amp;ldquo;unser&amp;rdquo; Ding draus zu machen. Der erste Schritt war ein Sprung ins kalte Wasser in die uns bislang noch unbekannte Welt der Programmierbaren Logik. Dazu haben wir zunächst die Adressdekodierung bestehend aus 74ls138/74ls154 sowie etwas glue Logic in VHDL implementiert und auf ein GAL22V10D gebrannt.</description><content>&lt;p>Sinn der Sache ist ja nicht, etwas 1:1 nachzubauen, sondern ein möglichst eigenes Design. Nachdem wir mit Chris&amp;rsquo; Design - bzw. dessen, was wir davon übernommen haben (Adressdekodierung, ACIA, VIA) - genug herumgespielt hatten, galt es, &amp;ldquo;unser&amp;rdquo; Ding draus zu machen. Der erste Schritt war ein Sprung ins kalte Wasser in die uns bislang noch unbekannte Welt der Programmierbaren Logik. Dazu haben wir zunächst die Adressdekodierung bestehend aus 74ls138/74ls154 sowie etwas glue Logic in VHDL implementiert und auf ein GAL22V10D gebrannt. Somit haben wir 3 TTL-ICs durch einen GAL ersetzt und wieder Platz auf dem Steckbrett geschaffen. Und das Beste: Änderungen an der Dekodierungslogik laufen ab sofort minimalinvasiv.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Die erste Erweiterung ist ein /CS-Signal für den 2. 62256-Chip, der sich seinen Adressbereich mit 4k IO-Bereich und 8K ROM teilen darf und uns immerhin noch 20k nutzbares RAM beschert. Anfängliche Pläne, das unter dem ROM und IO liegende RAM nach Vorbild des C64 nutzbar zu machen stellen wir erstmal zurück. Zu viel Aufwand für lumpige 12k.&lt;/p>
&lt;p>Inzwischen gibt es auch eine rs232-Schnittstelle auf Basis einer 65x51 ACIA. Der vorliegende Chip kann mit max. 2MHz getaktet werden, daher ist der diskret aufgebaute 3MHz-Oszillator wieder arbeitslos. An seiner Stelle betaktet ein 2MHz-TTL-Oszillator unseren Rechner.&lt;/p>
&lt;p>Diese Begrenzung auf 2MHz gefällt uns nicht, eigentlich wollten wir den Rechner später so hoch wie möglich takten, auf jeden Fall mit 4MHz. Modernere CPUs sowie VIAs von WDC, die bis zu 14MHz Taktfrequenz vertragen, sind so gut wie geordert. Einzig die ACIA soll komplett durch einen moderneren Chip ersetzt werden, da sie uns nicht nur auf 2MHz, sondern auch auf 19200 baud begrenzt. Ein bisschen zu vintage, darum soll als nächtes die ACIA einem zeitgemäßeren Chip weichen.&lt;/p></content></item><item><title>Ein richtiger Computer soll es sein</title><link>https://www.steckschwein.de/post/ein-richtiger-computer-soll-es-sein/</link><pubDate>Sat, 15 Mar 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/ein-richtiger-computer-soll-es-sein/</guid><description>Nachdem die vorangegangenen Spielereien sehr ermutigend verliefen, war der nächste Schritt klar. Wenn wir so weit kommen, kommen wir auch noch weiter. Das Ziel ist jetzt definitiv ein funktionierender 8bit-Rechner mit 64k RAM.
Da der 6502 keinen DRAM-Refresh liefert und wir uns den Aufwand eines diskreten Refresh-Generators ersparen wollen, soll es ein SRAM-basiertes Design werden. Bei ein wenig Recherche beim Elektronik-Versenders unseres Vertrauens stellen wir fest, dass 2x32k*8 in Form von zwei 2 62256 eine komfortable Lösung sein würden.</description><content>&lt;p>Nachdem die vorangegangenen Spielereien sehr ermutigend verliefen, war der nächste Schritt klar. Wenn wir so weit kommen, kommen wir auch noch weiter. Das Ziel ist jetzt definitiv ein funktionierender 8bit-Rechner mit 64k RAM.&lt;/p>
&lt;p>Da der 6502 keinen DRAM-Refresh liefert und wir uns den Aufwand eines diskreten Refresh-Generators ersparen wollen, soll es ein SRAM-basiertes Design werden. Bei ein wenig Recherche beim Elektronik-Versenders unseres Vertrauens stellen wir fest, dass 2x32k*8 in Form von zwei 2 62256 eine komfortable Lösung sein würden. A15 würde den Chip mit den unteren 62256 selektieren, um alles oberhalb würde sich ein kleines TTL-Grab kümmern, denn irgendwo muss ja noch ein Bereich für verschiedene IO-Bausteine hin.&lt;/p>
&lt;p>Etwas mehr Recherche bei 6502.org bringt uns zum Projekt von Chris Ward (&lt;a href="http://www.chrisward.org.uk/6502/spec.shtml">http://www.chrisward.org.uk/6502/spec.shtml&lt;/a>), der eine simple und effektive Adressdekodierung hat, und die selben Ansätze bereits weiter gedacht hat. Zusätzlich zeigt er, wie simpel es ist, ein LCD-Display nach hd44780-Standard an den Datenbus zu klemmen. Also stellen wir uns auf die Schultern dieses Giganten, und beschließen, auf Basis dieses Designs weiterzumachen. Der 500Hz-Taktgeber weicht einem Quarzoszillator mit 3MHz, mehr verkraftet die verwendete VIA nicht. Die CPU könnte auch 4MHz.&lt;/p>
&lt;!-- raw HTML omitted --></content></item><item><title>TMS9929 - Wir wollen was sehen...</title><link>https://www.steckschwein.de/post/tms9929-wir-wollen-was-sehen/</link><pubDate>Sun, 02 Mar 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/tms9929-wir-wollen-was-sehen/</guid><description>&amp;hellip; und zwar auf einem Bildschirm! Aber wie stellt man sowas an?! Nun, wir schauen uns um, was Ende der 70-er bzw. Anfang der 80-er Jahre Stand der Technik war und was sich mit überschaubarem Aufwand an eine 6502 CPU &amp;ldquo;anschließen&amp;rdquo; lässt. Die Auswahl ist leider überschaubar, denn es sollte irgendwas in DIP maximal noch SDIP sein und dazu noch irgendwie lieferbar - &amp;ldquo;new old stock&amp;rdquo;.
Wir fanden die TMS9918/28/29-Serie und einige Nachfolger wie den TMS9938/58.</description><content>&lt;p>&amp;hellip; und zwar auf einem Bildschirm! Aber wie stellt man sowas an?! Nun, wir schauen uns um, was Ende der 70-er bzw. Anfang der 80-er Jahre Stand der Technik war und was sich mit überschaubarem Aufwand an eine 6502 CPU &amp;ldquo;anschließen&amp;rdquo; lässt. Die Auswahl ist leider überschaubar, denn es sollte irgendwas in DIP maximal noch SDIP sein und dazu noch irgendwie lieferbar - &amp;ldquo;new old stock&amp;rdquo;.&lt;/p>
&lt;p>Wir fanden die TMS9918/28/29-Serie und einige Nachfolger wie den TMS9938/58. Für&amp;rsquo;s erste sollte es ein TMS9929 sein, weil der tatächlich noch zu beschaffen ist und dazu auch noch im DIP-Gehäuse daherkommt. Der -29 ist für den europäischen Markt gebaut worden, um diese an PAL-Fernsehgeräte anschließen zu können. Hier eine kleiner Auszug  der technischen Fähigkeiten, die im &lt;a href="http://msx.hansotten.com/uploads/ffiles/1980%20TMS9918%20Advertisement.jpg">Jahre 1980&lt;/a> wahrscheinlich gigantisch wirkten.&lt;/p>
&lt;p>• 256x192 resolution on TV screen • 15 unique colors plus transparent • General 8-bit bidirectional interface to Central Processor Unit (CPU) • Direct wiring to 4K, 8K, or 16K dynamic RAM memories • Automatic and transparent refresh of dynamic RAMs • Unique planar representation for 3D simulation • Standard 40-pin package • Color difference outputs allow RGB drive - TMS992SA/9929A&lt;/p>
&lt;p>Ok, schauen wir uns mal das &lt;a href="http://www.bitsavers.org/components/ti/TMS9900/TMS9918A_TMS9928A_TMS9929A_Video_Display_Processors_Data_Manual_Nov82.pdf">Datenblatt&lt;/a> an. Aha, oha, soso&amp;hellip;. sieht doch gar nicht so schwierig aus. Jetzt brauchen wir noch passende DRAM&amp;rsquo;s da wird&amp;rsquo;s schon schwieriger. Zum Glück hat der Dommas sowas in seiner Bastelkiste, gleich nen ganzen Sack diverser Typen. Glück gehabt&amp;hellip;. Im Datenblatt steht TMS4116, in der Bastelkiste finde ich NEC416 die sind exakt baugleich von daher pinkompatibel. Die DRAMs an den VDP zu kleben ist im Datenblatt beschrieben, ich lese mir das ganze bestimmt 50 Mal durch, hab nen Knoten im Kopf und verstehe nicht warum man das damals so kompliziert machen musste&amp;hellip; Dazu kommt, dass ich Beschaltung und Funktionsweise von DRAMs das letzte mal vor 14 Jahren gehört habe. Also lese ich mich auch hier nochmal ein.&lt;/p>
&lt;p>Für den TMS9929 brauchen wir 8 16K DRAMs, die 1Bit organisiert sind, ebend genau der 4116 Typ oder baugleich. Ich besorge mir also noch ein paar Steckbretterund jede Menge Steckbrettkabel, um das Gestrüpp herzustellen.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Fertig, ich freu mich, seh zwar noch nix bin aber zuversichtlich&amp;hellip;&lt;/p></content></item><item><title>Doppelt hält besser</title><link>https://www.steckschwein.de/post/doppelt-haelt-besser/</link><pubDate>Sat, 22 Feb 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/doppelt-haelt-besser/</guid><description>Damit sich ein &amp;ldquo;Steckschwein&amp;rdquo; nicht so einsam fühlt, haben wir das ganze nochmal geklont. Jetzt hat jeder sein eigenes Steckschwein und kann daran rumschrauben oder besser gesagt rumstecken.
Da wir das Tooling &amp;ldquo;leichtgewichtig&amp;rdquo; halten wollen, gabs auch gleich ein kleines Problem zu lösen. Die Dekoder-Logik für den GAL wurde bisher in VHDL definiert und mit dem Hersteller-Produkt http://www.latticesemi.com/ispleverclassic ein entsprechendes JEDEC-File erzeugt. Das war uns dann doch viel zu unhandlich und wir haben uns nach Alternativen umgetan.</description><content>&lt;p>Damit sich ein &amp;ldquo;Steckschwein&amp;rdquo; nicht so einsam fühlt, haben wir das ganze nochmal geklont. Jetzt hat jeder sein eigenes Steckschwein und kann daran rumschrauben oder besser gesagt rumstecken.&lt;/p>
&lt;p>Da wir das Tooling &amp;ldquo;leichtgewichtig&amp;rdquo; halten wollen, gabs auch gleich ein kleines Problem zu lösen. Die Dekoder-Logik für den GAL wurde bisher in VHDL definiert und mit dem Hersteller-Produkt &lt;a href="http://www.latticesemi.com/ispleverclassic">http://www.latticesemi.com/ispleverclassic&lt;/a> ein entsprechendes JEDEC-File erzeugt. Das war uns dann doch viel zu unhandlich und wir haben uns nach Alternativen umgetan. Die Wahl fiel auf &lt;a href="https://github.com/daveho/GALasm">https://github.com/daveho/GALasm&lt;/a>, ein kleines aber feines Tool mit dem aus einigen booleschen Ausdrücken für die Dekoder-Logik genauso gut ein JEDEC-File erzeugt werden kann.&lt;/p>
&lt;pre tabindex="0">&lt;code>GAL22V10    ; first line : used GAL 8Bit Dekoder   
; second line: any text (max. 8 char.)
; PIN assignment
; G1       ; A15 of 6502 (Pin 25)
A2       ; A14 of 6502 (Pin 24)
A1       ; A13 of 6502 (Pin 23)
A0       ; A12 of 6502 (Pin 22)
B0       ; A08 of 6502 (Pin 20)
B1       ; A09 of 6502 (Pin 19)
B2       ; A10 of 6502 (Pin 18)
B3       ; A11 of 6502 (Pin 17)
RW       ; RW of 6502 (Pin 34)
PHI2     ; PHI2 of 6502 (Pin 39)
NC
GND
NC
CSROM    ;CS signal for ROM at $e000-$ffff
OE
WE       ;with PHI2 synchronized WE
CSHIRAM  ;CS for ram between  $8000-$cfff
CSACIA   ;6551 ACIA   at $d000
CSVIA    ;6522 VIA    at $d100
ELCD     ;LCD-Display at $d200
VDPCSR   ;Read VDP at $d400
VDPCSW   ;Write VDP at $d400
CSUART   ;CS for UART at $d300
VCC
;
;  boolean expressions
;
OE       = /RW  ; - output enable (active low, read from adress)
/WE      = /RW * PHI2     ; - write enable, combined with PHI2 (Pin 39) for synchronisation
/CSHIRAM = G1*/A2         ; $8000-$cfff + G1\*/A1\*/A0
/CSROM   = G1*A2*A1*A0   ; $e000-$ffff + G1\*A2\*A1\*/A0
/CSACIA  = G1 * A2*/A1*A0 * /B3*/B2*/B1*/B0  ; $d000
/CSVIA   = G1 * A2*/A1*A0 * /B3*/B2*/B1*B0   ; $d100
ELCD     = PHI2 * G1 * A2*/A1*A0 * /B3*/B2*B1*/B0  ; $d200 - LCD-Display at $d200
/CSUART  = G1 * A2*/A1*A0* /B3*/B2*B1*B0           ; $d300 - UART
&lt;/code>&lt;/pre>&lt;p>Mehr ist&amp;rsquo;s dann auch nicht, ganz oben der Typ des GAL&amp;rsquo;s in dem Fall ein 10-er, d.h. 10-Input, 10-Output-Pins. Darunter das PIN-Assignment, einfach in aufsteigender Reihenfolge deklarieren, also Pin1 - G1, Pin2 A2 usw.. bis VCC Pin 24. Dann noch die Boolschen-Ausdrücke, wobei * ein AND darstellt und + ein logisches OR. Negation mit /. Compiler anwerfen mittels.&lt;/p>
&lt;p>Jetzt noch das ganze auf den GAL brutzeln, am besten mit dem Universal programmer TL866C und schon läuft&amp;rsquo;s.&lt;/p></content></item><item><title>Am Anfang war das NOP</title><link>https://www.steckschwein.de/post/am-anfang-war-das-nop/</link><pubDate>Wed, 12 Feb 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/am-anfang-war-das-nop/</guid><description>Wenn man 20 Jahre lang den Jugendtraum mit sich rumträgt, einen 8bit-Rechner selber zu bauen, dann hat man 20 Jahre Zeit, einzurosten. Langsames Rantasten an das große Ziel ist angesagt.
In diesem Fall soll unser 65c02 erstmal nur NOPs ausführen und wir wollen zuschauen, was auf dem Adressbus passiert. Der Datenbus ist hart verdrahtet auf NOP ($EA, 11101010) . Als Reset-Schaltung kommt eine auf Basis des allseits beliebten NE555 zum Einsatz.</description><content>&lt;p>Wenn man 20 Jahre lang den Jugendtraum mit sich rumträgt, einen 8bit-Rechner selber zu bauen, dann hat man 20 Jahre Zeit, einzurosten. Langsames Rantasten an das große Ziel ist angesagt.&lt;/p>
&lt;p>In diesem Fall soll unser 65c02 erstmal nur NOPs ausführen und wir wollen zuschauen, was auf dem Adressbus passiert. Der Datenbus ist hart verdrahtet auf NOP ($EA, 11101010) . Als Reset-Schaltung kommt eine auf Basis des allseits beliebten NE555 zum Einsatz. Die gleiche Schaltung verrichtet auch im legendären Commodore PET ihren Dienst, also eine Chance, eine kleine Hommage mit einzubauen:&lt;/p>
&lt;p>&lt;img src="images/80cba-pet_reset.png" alt="">&lt;/p>
&lt;p>Als Taktgenerator missbrauchen wir den Kalibrierausgang des Oszilloskops, der unsere Computer-Keimzelle mit 1 kHz taktet.&lt;/p>
&lt;p>Am Adressbus sind nun, über 74ls245-Treiber, 16 LEDs angeschlossen, an denen wir erkennen können, welche Adresse anliegt:&lt;/p>
&lt;p> 
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/ZLhVni8Wy5Y" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;/p>
&lt;p>Was wir also spannendes hier sehen ist folgendes:&lt;/p>
&lt;p>Nach dem Reset sprint der 65c02 an seinen Reset-Vektor, nämlich $fffc, liest dort die Adresse $EAEA (der Datenbus ist ja auf $EA hart verdrahtet), springt nach $EAEA, liest die erste Instruktion ein, nämlich ein NOP ($EA) und so weiter. Könnte man sich stundenlang ansehen.&lt;/p></content></item><item><title>Euphorie: Jetzt auch RAM!</title><link>https://www.steckschwein.de/post/euphorie-jetzt-auch-ram/</link><pubDate>Wed, 12 Feb 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/euphorie-jetzt-auch-ram/</guid><description>Die Euphorie ob des Ausgangs des letzten Versuchs nutzend wird jetzt weitergebaut. Immerhin sind wir so nah an einem richtigen Computer. Was fehlt, ist RAM. Leider nichts im Haus.
Eine temporäre Organspende aus einem C64-Easyflash-Cartridge (Cooles Teil: http://skoe.de/easyflash/doku.php?id=start) verschafft uns ein 6264 SRAM. Dieses verdrahten wir analog zum EPROM, allerdings brauche es hier noch einen Hauch von Gatterlogik, um das EEPROM ans obere Ende des Adressraums zu mappen, während das SRAM in den unteren 8k lebt.</description><content>&lt;p>Die Euphorie ob des Ausgangs des letzten Versuchs nutzend wird jetzt weitergebaut. Immerhin sind wir so nah an einem richtigen Computer. Was fehlt, ist RAM. Leider nichts im Haus.&lt;/p>
&lt;p>Eine temporäre Organspende aus einem C64-Easyflash-Cartridge (Cooles Teil: &lt;a href="http://skoe.de/easyflash/doku.php?id=start">http://skoe.de/easyflash/doku.php?id=start&lt;/a>) verschafft uns ein 6264 SRAM. Dieses verdrahten wir analog zum EPROM, allerdings brauche es hier noch einen Hauch von Gatterlogik, um das EEPROM ans obere Ende des Adressraums zu mappen, während das SRAM in den unteren 8k lebt.&lt;/p>
&lt;p>Der Testcode wird um einige JSR und RTS erweitert (Stack!). Eine grüne LED an der RW-Leitung zeigt uns Schreibzugriffe an.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/zjhkhsHbYMg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></content></item><item><title>Mehr Mut: Es werde Code!</title><link>https://www.steckschwein.de/post/mehr-mut-es-werde-code/</link><pubDate>Wed, 12 Feb 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/mehr-mut-es-werde-code/</guid><description>Nachdem uns nach einiger Zeit dann doch langweilig wurde, den Prozessor beim NOPs ausführen zu beobachten musste der nächste Kick her: Es soll Code ausführen! Also ein wenig Code geschrieben (dieser ist leider nicht überliefert, enthielt lediglich einige NOPs und JMPs, gerade genug also, um uns in blanke Verzückung zu versetzen), auf ein 27128 EPROM gebrannt und an Adress- und Datenbus angeschlossen. /OE und /CS des EPROM wurden einfach auf Masse gelegt.</description><content>&lt;p>Nachdem uns nach einiger Zeit dann doch langweilig wurde, den Prozessor beim NOPs ausführen zu beobachten musste der nächste Kick her: Es soll Code ausführen! Also ein wenig Code geschrieben (dieser ist leider nicht überliefert, enthielt lediglich einige NOPs und JMPs, gerade genug also, um uns in blanke Verzückung zu versetzen), auf ein 27128 EPROM gebrannt und an Adress- und Datenbus angeschlossen. /OE und /CS des EPROM wurden einfach auf Masse gelegt. Adressleitungen A0-A12 des EPROM wurden mit dem Adressbus des Prozessors verbunden, die verbliebenen Adressleitungen des Prozessors blieben frei. Also haben wir nun 8k ROM, die sich innerhalb der 64k Adressraum des 65c02 8 mal wiederholen.&lt;/p>
&lt;p>Um das visuelle Erleben intensiver zu gestalten wurde der Datenbus mit Hilfe eines 74ls245 und 8 roter LEDs ebenfalls sichtbar gemacht. Für den Takt sorgt mittlerweile ein Rechteckgenerator auf NE555-Basis, der beschauliche 500Hz liefert.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/z5xyLgUeEcM" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></content></item><item><title>About</title><link>https://www.steckschwein.de/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/about/</guid><description>These are times where one just gets bombed with gigahertz, gigabytes. The Steckschwein is an 8bit computer that wants to show how much know how is already to be found in a rather simple computer.
Our mission is to create a computer that might have existed during the heyday of 8bit home computers. Only with more modern interfaces to the outside world, since nobody wants to fiddle with floppy disks anymore.</description><content>&lt;p>These are times where one just gets bombed with gigahertz, gigabytes. The Steckschwein is an 8bit computer that wants to show how much know how is already to be found in a rather simple computer.&lt;/p>
&lt;p>Our mission is to create a computer that might have existed during the heyday of 8bit home computers. Only with more modern interfaces to the outside world, since nobody wants to fiddle with floppy disks anymore.&lt;/p>
&lt;p>The name &amp;ldquo;Steckschwein&amp;rdquo; originates to the very early stages of our project, where everything was prototyped on breadboards (german: &amp;ldquo;Steckbrett&amp;rdquo;), and we all know that those things can be real pigs.&lt;/p>
&lt;p>&lt;img src="images/steckschwein-e1442404875521.jpg" alt="steckschwein"> Early days&lt;/p>
&lt;p>&lt;img src="images/schweinebande.jpg" alt="schweinebande"> First PCB based prototypes&lt;/p>
&lt;p>We started off with a very small test circuit, having the 65c02 execute only NOPs, by hard wiring the data lines to $EA. Then,  we started to add new components step by step, such as ROM, RAM, IO interface (65c22 VIA), serial interface (UART 16550), until we arrived at the current specifications:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://de.wikipedia.org/wiki/MOS_Technology_6502">65c02-CPU&lt;/a> @ &lt;a href="https://www.steckschwein.de/post/chiptuning/">8MHz&lt;/a>&lt;/li>
&lt;li>64k RAM&lt;/li>
&lt;li>32k bankable ROM&lt;/li>
&lt;li>Video chip &lt;a href="https://en.wikipedia.org/wiki/Texas_Instruments_TMS9918">TMS9929&lt;/a>, now upgraded to &lt;a href="https://en.wikipedia.org/wiki/Yamaha_V9958">V9958&lt;/a>&lt;/li>
&lt;li>Sound chip &lt;a href="https://de.wikipedia.org/wiki/Yamaha_YM3812">YM3812&lt;/a> (OPL2)&lt;/li>
&lt;li>rs232 via &lt;a href="https://en.wikipedia.org/wiki/16550_UART">UART 16550&lt;/a>&lt;/li>
&lt;li>SPI used as main peripheral bus for:
&lt;ul>
&lt;li>sd-card based mass storage&lt;/li>
&lt;li>PS/2-peripheral controller (keyboard, mouse) (ATmega8)&lt;/li>
&lt;li>RTC (&lt;a href="http://www.maximintegrated.com/en/products/digital/real-time-clocks/DS1306.html">Maxim DS1306&lt;/a>)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Further reading and more details on &lt;a href="https://www.steckschwein.de/hardware/">Steckschwein Hardware&lt;/a>.&lt;/p></content></item><item><title>Hardware</title><link>https://www.steckschwein.de/hardware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/hardware/</guid><description>It it&amp;rsquo;s current incarnation, the Steckschwein consists of 4 main units:
CPU/Memory IO (VIA 65c22), now also including UART SPI-Devices UART 16550 Joysticks and user port Video / audio board with V9958 VDP and YM3812 (OPL2) sound chip The 62c22 VIA is mainly utilized as SPI master to implement SPI as the main peripheral bus, connecting SD-card, RTC and the ATmega8 (used as PS/2 controller) to the system. The block diagram shows how things are working together.</description><content>&lt;p>It it&amp;rsquo;s current incarnation, the Steckschwein consists of 4 main units:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://www.steckschwein.de/cpuramdecoder/">CPU/Memory&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.steckschwein.de/via-65c22-as-spi-master/">IO (VIA 65c22), now also including UART&lt;/a>
&lt;ol>
&lt;li>&lt;a href="https://www.steckschwein.de/spi-devices/">SPI-Devices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.steckschwein.de/uart-16550/">UART 16550&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.steckschwein.de/joysticks-and-user-port/">Joysticks and user port&lt;/a>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;a href="https://www.steckschwein.de/v9958-video-board/">Video / audio board with V9958 VDP and YM3812 (OPL2) sound chip&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>The 62c22 VIA is mainly utilized as SPI master to implement SPI as the main peripheral bus, connecting SD-card, RTC and the ATmega8 (used as PS/2 controller) to the system. The block diagram shows how things are working together.&lt;/p>
&lt;p>&lt;strong>Schematics and pcb layouts&lt;/strong> can be found at our &lt;a href="https://bitbucket.org/steckschwein/steckschwein-hardware">scm repository on bitbucket.org&lt;/a>.&lt;/p>
&lt;p>&lt;img src="images/blockschaltbild.png" alt="blockschaltbild">&lt;/p>
&lt;p>&lt;a href="https://www.steckschwein.de/blockschaltbild.pdf">Block diagram as PDF&lt;/a>&lt;/p></content></item><item><title>Impressum</title><link>https://www.steckschwein.de/impressum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/impressum/</guid><description>Angaben gemäß § 5 TMG: Thomas Woinke Schüleinstraße 4 81673 München
Marko Lauke
Gräfin-Dönhoff-Straße 16
83024 Rosenheim
Kontakt E-Mail: info (at) steckschwein.de
Fax: +49 3212 115 8877
Datenschutzerklärung (DSGVO) Auf dieser Webseite werden keine personenbezogenen Daten erhoben, gespeichert oder verarbeitet.
Data Protection Policy (GDPR) This website does not collect, store or process Personally Identifiable Information (PII).
Verweis auf Dritte Diese Website wird auf Github als Github Pages gehostet. Die Github Privacy Policy ist hier hinterlegt.</description><content>&lt;h2 id="angaben-gemäß--5-tmg">Angaben gemäß § 5 TMG:&lt;/h2>
&lt;p>Thomas Woinke &lt;br>
Schüleinstraße 4 &lt;br>
81673 München&lt;/p>
&lt;p>Marko Lauke&lt;br>
Gräfin-Dönhoff-Straße 16&lt;br>
83024 Rosenheim&lt;/p>
&lt;h2 id="kontakt">Kontakt&lt;/h2>
&lt;p>E-Mail: info (at) steckschwein.de&lt;br>
Fax: +49 3212 115 8877&lt;/p>
&lt;h2 id="datenschutzerklärung-dsgvo">Datenschutzerklärung (DSGVO)&lt;/h2>
&lt;p>Auf dieser Webseite werden keine personenbezogenen Daten erhoben, gespeichert oder verarbeitet.&lt;/p>
&lt;h2 id="data-protection-policy-gdpr">Data Protection Policy (GDPR)&lt;/h2>
&lt;p>This website does not collect, store or process Personally Identifiable Information (PII).&lt;/p>
&lt;h2 id="verweis-auf-dritte">Verweis auf Dritte&lt;/h2>
&lt;p>Diese Website wird auf &lt;a href="https://www.github.com/">Github&lt;/a> als &lt;a href="https://pages.github.com/">Github Pages&lt;/a> gehostet. Die Github Privacy Policy ist &lt;a href="https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement">hier&lt;/a> hinterlegt.&lt;/p>
&lt;h2 id="third-party-inclusion">Third Party Inclusion&lt;/h2>
&lt;p>This website is hosted by &lt;a href="https://www.github.com/">Github&lt;/a> using &lt;a href="https://pages.github.com/">Github Pages&lt;/a> Pages). The Github Privacy Policy is available &lt;a href="https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement">hier&lt;/a>.&lt;/p>
&lt;h2 id="distanzierung">Distanzierung&lt;/h2>
&lt;p>Mit Urteil vom 12. Mai 1998 hat das Landgericht Hamburg entschieden, dass man durch die Ausbringung eines Links die Inhalte der gelinkten Seite ggf. mit zu verantworten hat. Dies kann - so das Landgericht - nur dadurch verhindert werden, dass man sich ausdrücklich von diesen Inhalten distanziert. Wir haben auf unserem Onlineangebot zu anderen Seiten im Internet gelinkt. Für all diese Links gilt: Wir möchten ausdrücklich betonen, dass wir keinerlei Einfluss auf die Gestaltung und die Inhalte der gelinkten Seiten haben. Wir distanzieren uns vorsorglich von allen fremden Inhalten.&lt;/p>
&lt;p>Quelle: &lt;em>&lt;a href="http://www.e-recht24.de/">http://www.e-recht24.de&lt;/a>&lt;/em>&lt;/p></content></item><item><title>IO: VIA 65c22 as SPI-Master</title><link>https://www.steckschwein.de/via-65c22-as-spi-master/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/via-65c22-as-spi-master/</guid><description>One of the fundamental design decisions when creating the Steckschwein was to use SPI as the main peripheral bus. This way, various different devices can be utilized using a single interface protocol. The main killer feature for using SPI was to be able to use an SD card as mass storage. This gives us mass storage with almost no extra hardware effort, only level conversion is needed between the system (5V) and the card (3.</description><content>&lt;p>One of the fundamental design decisions when creating the Steckschwein was to use SPI as the main peripheral bus. This way, various different devices can be utilized using a single interface protocol. The main killer feature for using SPI was to be able to use an SD card as mass storage. This gives us mass storage with almost no extra hardware effort, only level conversion is needed between the system (5V) and the card (3.3V).&lt;/p>
&lt;p>The most common io device for the 6502 processor is the 6522 VIA (Versatile Interface Adapter). In our case, we are using it among a few other things as as the SPI master. VIA port B is solely dedicated to be used with SPI devices. The direction MISO (Master In, Slave Out) is covered by the internal shift register of the VIA. The VIA pins are used as follows:&lt;/p>
&lt;p>|PB0|SPICLK|
|PB1|SS1 SD-card|
|PB2|SS2 PS/2 keyboard controller (ATmega8)|
|PB3|SS3 RTC (DS1306)|
|PB4|SS4 (unused)|
|PB5|sd card write protect|
|PB6|sd card detect|
|PB7|MOSI|
|CB1|SPICLK (connected to PB0)|
|CB2|MISO|&lt;/p>
&lt;p>Basically, the process of reading data via SPI only consists of setting the appropriate slave select pin to low and then &amp;ldquo;wiggling&amp;rdquo; the PB0 pin as fast as possible, which is determined by how fast the CPU is able to write to the port. This also means that the shift register is used in &amp;ldquo;Shift In - External CB1 Clock Control (011)&amp;quot;-mode, which is the very mode affected by the infamous &lt;a href="http://forum.6502.org/viewtopic.php?t=342#p2310">VIA-Bug&lt;/a>. We did not do anything circuit wise to implement a workaround. We rather rely on the fact, that we create the SPI clock using the processor and hereby have the SPI clock locked to the system clock, so the signal slopes have a fixed delay. This should take care of the bug not to occur. Hopefully.&lt;/p>
&lt;p>&lt;img src="images/io_via.png" alt="io_via">&lt;/p>
&lt;p>&lt;a href="https://steckschwein.files.wordpress.com/2018/03/io.pdf" title="io">Schematic as PDF&lt;/a>&lt;/p></content></item><item><title>Joysticks and user port</title><link>https://www.steckschwein.de/joysticks-and-user-port/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/joysticks-and-user-port/</guid><description>Since after using all of VIA Port B for SPI, all we have left is Port A to hook up anything else. One of our design goals is to be able to hook up two Atari/Commodore style joysticks. With only one 8bit IO port left, this is a bit tricky. Our first approach was to wire up the joysticks in a matrix like arrangement, but this suffered from the infamous matrix ghosting problem.</description><content>&lt;p>Since after using all of VIA Port B for SPI, all we have left is Port A to hook up anything else. One of our design goals is to be able to hook up two Atari/Commodore style joysticks. With only one 8bit IO port left, this is a bit tricky. Our first approach was to wire up the joysticks in a matrix like arrangement, but this suffered from the infamous &lt;a href="https://www.dribin.org/dave/keyboard/one_html/">matrix ghosting problem&lt;/a>. Also, port A was completely blocked and could not be used for anything else that way.&lt;/p>
&lt;p>Our next approach included tri state drivers behind every joystick port. That way, in order to read the state of a particular joystick, the respective driver has to be enabled first. It is also possible to disable the drivers altogether, freeing port A up completely, which made it possible to add a freely programmable user port.&lt;/p>
&lt;p>&lt;img src="images/io_joyports.png" alt="io_joyports">&lt;/p></content></item><item><title>Software</title><link>https://www.steckschwein.de/software/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/software/</guid><description>Repositories One can find the complete sources for BIOS, SteckOS, Firmware for the keyboard controller, decoder sources of the GAL&amp;rsquo;s and full schematics and board layouts as KiCad-projects at bitbucket.org
All software (steckOS, BIOS, libraries, tools, games, stuff): https://bitbucket.org/steckschwein/steckschwein-code
Hardware (Schematics, PCB Layouts): https://bitbucket.org/steckschwein/steckschwein-hardware
Steckschwein Emulator: https://github.com/Steckschwein/steckschwein-emulator
Tools We almost exclusively use Open Source-Software to design and code for the Steckschwein.
cc65 - http://cc65.github.io/cc65/ Extensive suite of cross development tools for almost every 6502 based platform.</description><content>&lt;h2 id="repositories">Repositories&lt;/h2>
&lt;p>One can find the complete sources for BIOS, SteckOS, Firmware for the keyboard controller, decoder sources of the GAL&amp;rsquo;s and full schematics and board layouts as KiCad-projects at bitbucket.org&lt;/p>
&lt;p>All software (steckOS, BIOS, libraries, tools, games, stuff): &lt;a href="https://bitbucket.org/steckschwein/steckschwein-code">https://bitbucket.org/steckschwein/steckschwein-code&lt;/a>&lt;/p>
&lt;p>Hardware (Schematics, PCB Layouts): &lt;a href="https://bitbucket.org/steckschwein/steckschwein-hardware">https://bitbucket.org/steckschwein/steckschwein-hardware&lt;/a>&lt;/p>
&lt;p>Steckschwein Emulator: &lt;a href="https://github.com/Steckschwein/steckschwein-emulator">https://github.com/Steckschwein/steckschwein-emulator&lt;/a>&lt;/p>
&lt;h2 id="tools">Tools&lt;/h2>
&lt;p>We almost exclusively use Open Source-Software to design and code for the Steckschwein.&lt;/p>
&lt;ul>
&lt;li>cc65 - &lt;a href="http://cc65.github.io/cc65/">http://cc65.github.io/cc65/&lt;/a> Extensive suite of cross development tools for almost every 6502 based platform. We mostly use ca65 because of the linker. Also, we have a few tools written in C.&lt;/li>
&lt;li>KiCad - &lt;a href="http://kicad-pcb.org/">http://kicad-pcb.org/&lt;/a> Powerful eda suite once you get the hang of it. We use it for all things hardware.&lt;/li>
&lt;li>GALasm - &lt;a href="https://github.com/daveho/GALasm">https://github.com/daveho/GALasm&lt;/a> Our GAL-based address decoding logic and our wait state generator logic are defined using GALasm, which is an ancient tool, but still very useful.&lt;/li>
&lt;li>py65mon - &lt;a href="https://github.com/mnaberez/py65">https://github.com/mnaberez/py65&lt;/a> We use it&amp;rsquo;s 6502-emulator/simulator for automated testing using unit tests.&lt;/li>
&lt;li>Acme - &lt;a href="https://sourceforge.net/projects/acme-crossass/">https://sourceforge.net/projects/acme-crossass/&lt;/a> Very nice 65xx crossassembler for almost every platform. We used ACME in the beginning, but moved on to ca65 from the cc65 suite. We still use it for quick-and dirty stuff.&lt;/li>
&lt;/ul></content></item><item><title>SPI-Devices</title><link>https://www.steckschwein.de/spi-devices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/spi-devices/</guid><description>SD-Card as really cheap and lazy mass storage Most important device on the Steckschwein using the SPI-Bus and therefore the &amp;ldquo;killer application&amp;rdquo;, that sold the idea of using SPI to us, is the sd card. The only additional hardware effort was to level shift the signals from and to the sd-card, as it runs on 3.3V while the Steckschwein uses 5V. To accomplish this, the SPI clock, SPI slave select and MOSI are converted using a 74LS07, with it&amp;rsquo;s open collector outputs pulled up to 3.</description><content>&lt;h3 id="sd-card-as-really-cheap-and-lazy-mass-storage">SD-Card as really cheap and lazy mass storage&lt;/h3>
&lt;p>Most important device on the Steckschwein using the SPI-Bus and therefore the &amp;ldquo;killer application&amp;rdquo;, that sold the idea of using SPI to us, is the sd card. The only additional hardware effort was to level shift the signals from and to the sd-card, as it runs on 3.3V while the Steckschwein uses 5V. To accomplish this, the SPI clock, SPI slave select and MOSI are converted using a 74LS07, with it&amp;rsquo;s open collector outputs pulled up to 3.3V. The other direction, MISO, is routed to one of the units of a 74HCT125, whose inputs can deal with 3.3V logic and whose outputs are TTL compliant, hence HCT.&lt;/p>
&lt;p>With mass storage implemented as simple as that, why bother fiddling around with floppy disk controllers or IDE drives or stuff like that?&lt;/p>
&lt;p>&lt;img src="images/io_sdcard.png" alt="io_sdcard">&lt;/p>
&lt;h4 id="atmega8-used-as-ps2-keyboard-controller">ATmega8 used as PS/2 keyboard controller&lt;/h4>
&lt;p>An ATmega8 is used as PS/2 keyboard and maybe (later) mouse controller. The code running on the ATmega is based on &lt;a href="http://www.atmel.com/Images/doc1235.pdf">AVR Application Note 313&lt;/a> , but without the UART code. Instead, we added code to act as an SPI slave. Also, we implemented a german keyboard layout and support for a few modifier keys that was missing in the original code. Also, special keys or key combinations like SysRq and the three-finger-salute are being handled directly by the keyboard controller to pull the respective signals like NMI or trigger a hardware reset.&lt;/p>
&lt;p>&lt;img src="images/io_kbdctrl.png" alt="io_kbdctrl">&lt;/p>
&lt;p>&lt;strong>RTC DS1306&lt;/strong>&lt;/p>
&lt;p>The RTC DS1306 delivers the current time down to second resolution, supports two alarms and also has 96 bytes of battery backed memory, which makes it double as storage for system boot parameters. In fact, we store the name of the file to load at boot time and also the UART parameters there. Main reason to add the RTC was, that a real nice machine of course needs an RTC, but also as a time source to set the proper file creation time and date in our FAT32 implementation.&lt;/p>
&lt;p>&lt;img src="images/io_rtc.png" alt="io_rtc">&lt;/p></content></item><item><title>UART 16550</title><link>https://www.steckschwein.de/uart-16550/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/uart-16550/</guid><description>The 16550 UART was the first chip to be attached to the CPU bus that does not have a native 65xx bus interface and hence needed a little more effort. The reset and interrupt signals are active high, while the 6502 needs them to be active low. So reset needed to be inverted, and interrupt is driven through a 74LS06 inverter driver with open collector outputs in order to be able to be wire-ORed to the system interrupt line.</description><content>&lt;p>The 16550 UART was the first chip to be attached to the CPU bus that does not have a native 65xx bus interface and hence needed a little more effort. The reset and interrupt signals are active high, while the 6502 needs them to be active low. So reset needed to be inverted, and interrupt is driven through a 74LS06 inverter driver with open collector outputs in order to be able to be wire-ORed to the system interrupt line. Furthermore, there is no combined R/W line, so that signal hat to be split up into /WR and /RD. Here, we just use /OE and /WE which are generated on the CPU board.&lt;/p>
&lt;p>&lt;img src="images/io_uart.png" alt="io_uart">&lt;/p></content></item><item><title>Yamaha V9958/YM3812 Video/Audio Board</title><link>https://www.steckschwein.de/v9958-video-board/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/v9958-video-board/</guid><description>Our current audio/video board is based on the Yamaha V9958. The V9958 is the successor of the V9938, which in turn is the successor to our TMS9929/9918, which has served our project for quite some time. But it is hard to ignore what the V9958 has to offer (80 column text mode to begin with), so we decided to use it as the first major upgrade to the Steckschwein Hardware specs in a couple of years.</description><content>&lt;p>Our current audio/video board is based on the Yamaha V9958. The V9958 is the successor of the V9938, which in turn is the successor to our TMS9929/9918, which has served our project for quite some time. But it is hard to ignore what the V9958 has to offer (80 column text mode to begin with), so we decided to use it as the first major upgrade to the Steckschwein Hardware specs in a couple of years.&lt;/p>
&lt;p>Like the &lt;a href="http://steckschwein.de/hardware/tms9929-video-display-processor/">9929 board&lt;/a>, the all new, all more powerful video board based on the mighty &lt;a href="https://www.msx.org/wiki/Yamaha_V9958">Yamaha V9958&lt;/a> chip has two parts - the video chip part with the 128k video memory (64k x 4 DRAM this time) and the signal part, using the Sony CXA2075M chip not only as RGB output stage, but also to generate composite video and s-video. This should increase the number of Steckschwein-compatible monitors a big deal. We also now have 128K of video memory, which gives us modes like 256x212 wth 256 colours. Also, we have 64K of &amp;ldquo;extended RAM&amp;rdquo;, which can be used to keep stuff within access of the video chip.&lt;/p>
&lt;p>The current board revision also contains the sound chip, which makes it the audio / video board.&lt;/p>
&lt;p>And by thinking sound chip and 8bit, the first thing comes to mind is of course the MOS 6581 SID chip, prominently used in the C64 and hands down the best sound chip from the 8bit era. But the SID has a few drawbacks that would make it difficult to use for the Steckschwein:&lt;/p>
&lt;ol>
&lt;li>It’s maximum clock rating is 2MHz. We’re already running at 8MHz, so that’s going to be a problem.&lt;/li>
&lt;li>While not hard to come by, SID chips aren’t cheap. Prices of about 40 Euros or more per unit are common. And those chips are not NOS, they are most likely pulled from a C64. We do not want to build the Steckschwein out of scavenged parts.&lt;/li>
&lt;/ol>
&lt;p>We decided to use the Yamaha &lt;a href="https://en.wikipedia.org/wiki/Yamaha_YM3812">YM3812&lt;/a> chip, which might be better known as OPL2. That’s right, the very chip that was used on early PC sound cards such as AdLib or the first Sound Blaster cards. OPL2 chips are easy to come by, and they are rather cheap.&lt;/p>
&lt;p>&lt;img src="images/v9958_audio.png" alt="v9958 audio">
&lt;img src="images/v9958_schematic.png" alt="v9958 schematic">
&lt;img src="images/v9958_video.png" alt="v9958 video">&lt;/p>
&lt;p> &lt;/p>
&lt;p>&lt;a href="https://www.steckschwein.de/v9958.pdf">Schematics as PDF&lt;/a>&lt;/p></content></item></channel></rss>