<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Steckschwein emulator - Steckschwein</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=Steckschwein rel=home><div class="logo__item logo__text"><div class=logo__title>Steckschwein</div><div class=logo__tagline>An 8bit computer for the 21st century</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li><li class=menu__item><a class=menu__link href=/><span class=menu__text>Blog</span></a></li><li class=menu__item><a class=menu__link href=/hardware/><span class=menu__text>Hardware</span></a></li><li class=menu__item><a class=menu__link href=/software/><span class=menu__text>Software</span></a></li><li class=menu__item><a class=menu__link href=/resources/><span class=menu__text>Resources</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Steckschwein emulator</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 110 28 1 1 0 010-28m0 3a3 3 0 100 22 3 3 0 000-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class=meta__text datetime=2019-12-09T00:00:00Z>December 09, 2019</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/allgemein/ rel=category>Allgemein</a></span></div></div></header><div class="content post__content clearfix"><p>Back from the VCFB (Vintage Computer Festival Berlin) 2019 where we had good talks, met interesting people and got new ideas. Especially from <a href=https://www.pagetable.com/>Michael Steil</a> who just asked the simple question <strong>&ldquo;How you can develop software for the Steckschwein without an emulator?&rdquo;</strong></p><p>With the answer in my mind I felt a little annoyed and also &ldquo;triggered&rdquo; at the same time&mldr; However, Michael Steil was nice enough to strip down his Commander X16-Emulator into a barebone 65c02 computer emulator, so all we had to do was to implement our memory map (easy) and borrow a V9958 video chip implementation from blueMSX and implement it into the emulator (hard).</p><p>We&rsquo;ll guide you through the adaption of the emulator step by step. Let&rsquo;s start with the &ldquo;easy&rdquo; part, the&mldr;</p><h3 id=memory-mapping>Memory Mapping</h3><p>is done in a dedicated file <a href=https://github.com/twoinke/steckschwein-emulator/blob/master/memory.c>memory.c</a> where we simply do the dispatching to a dedicated hardware emulation upon a given address. Luckily the Steckschwein i/o is located in a dedicated and continuous address range within $0200-$0280.</p><p>So if the CPU accesses these address range e.g. asking for a byte from such an address via</p><p><code>LDA $0220</code></p><p>the emulator dispatches the memory read to the corresponding i/o implementation. this  is done with a simple ordered &ldquo;if-cascade&rdquo; as follows</p><pre tabindex=0><code>uint8_t
real_read6502(uint16_t address, bool debugOn, uint8_t bank)
{
	if (address &lt; 0x0200)
	{ // RAM
		return RAM[address];
	}
	else if (address &lt; 0x0280) { // I/O
		// TODO I/O map?
		if (address  &lt; 0x210) // UART at $0200
		{
			return uart_read(address &amp; 0xf);
		}
		else if (address &lt; 0x0220) // VIA at $0210
		{
			return via1_read(address &amp; 0xf);
		}
		else if (address &lt; 0x0230) // VDP at $0220
		{
			return ioPortRead(NULL,address);
		}
</code></pre><p>The LDA shown above will end up in the line with</p><p><code>return ioPortRead(NULL,address);</code></p><p>and thus our VDP implementation is asked for a byte to read.</p><p>All other addresses are either RAM or ROM depending on the value within our memory control port $0230. For more details check out the <a href=http://steckschwein.de/hardware/cpuramdecoder/>memory map</a>.</p><h3 id=via-and-sdcard>VIA and SDCard</h3><p>The X16 and the Steckschwein share a few similar approaches, for example in terms of mass storage and/or peripheral communication. Both use the VIA to implement the SPI bus protocol via &ldquo;bit banging&rdquo; to communicate with various components, such as the SD card or the RTC. This part of the emulator almost completely derived from the X16 emulator, with only small modifications.</p><h3 id=emulating-the-v9958>Emulating the V9958</h3><p>The video part was much more difficult, because Steckschwein uses the <a href=http://steckschwein.de/hardware/v9958-video-board/>V9958</a>. Emulating that kind of video chip is much much work todo and requires a very good understanding what&rsquo;s really going on within the chip at every µs when the screen is drawn.</p><p>Fortunately the MSX and MSX2 systems are very good documented and there are plenty of emulators with source available. As this sounds good the outcome of our investigation was quite sober. Only the fMSX and the blueMSX emulators gave us an idea how we can use or reuse the code of the VDP implementation.</p><p>Although the <a href=http://www.bluemsx.com/>blueMSX</a> code is not maintained anymore we decided to give&rsquo;em a try. This is because the blueMSX implementation is build more like a kind of emulator framework which can be used to build emulators for a wide range of hardware and not only for MSX systems.</p><p>For short, the following changes where made to get the emulator with the VDP work</p><ol><li>strip out unnecessary code and extract the raw VDP V9558 implementation</li><li>create a blueMSX board implementation for Steckschwein</li><li>adapt the fake6502.c code to the blueMSX API with the appropriate cpu callbacks</li><li>glue code to dispatch the i/o access of addresses $220-$224 to the blueMSX VDP code</li><li>get cyclic exact timings required for video by using the blueMSX timer loop</li></ol><p>And here we are&mldr; the emulator is able to boot our bios, which in turn mounts the sdcard and loads the kernel just like the real Steckschwein does.</p><p><img src=images/steckschwein_emulator_vdp-1.jpg alt=steckschwein_emulator_vdp></p><p>On the screenshot you may have noticed the &ldquo;date&rdquo; tool, which actually gives the correct datetime. Hence the rtc emulation is also done already.</p><p>to be continued&mldr;</p><p>code: <a href=https://github.com/Steckschwein/steckschwein-emulator>https://github.com/Steckschwein/steckschwein-emulator</a></p></div></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__links><a class=footer__link href=/impressum/>Impressum</a></div><div class=footer__copyright>&copy; 2025 Steckschwein.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>