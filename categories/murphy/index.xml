<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>murphy on Steckschwein</title><link>https://www.steckschwein.de/categories/murphy/</link><description>Recent content in murphy on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 16 Oct 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://www.steckschwein.de/categories/murphy/index.xml" rel="self" type="application/rss+xml"/><item><title>Weird bug in SD card code</title><link>https://www.steckschwein.de/post/weird-bug-in-sd-card-code/</link><pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/weird-bug-in-sd-card-code/</guid><description>Frank van den Hoef, who is adapting the Steckschwein SPI &amp;amp; FAT32 code for his tiny65 machine made me aware of a classic mistake for a 6502 assembly coder to make. Namely in our sdcard driver, when waiting for the &amp;ldquo;proper&amp;rdquo; response from the card (which should have bit 7 cleared). The routine handling this looked like this:
1 sd_cmd_response_wait: 2 ldy #sd_cmd_response_retries 3 @l: dey 4 beq sd_block_cmd_timeout ; y already 0?</description><content>&lt;p>Frank van den Hoef, who is adapting the Steckschwein SPI &amp;amp; FAT32 code for his tiny65 machine made me aware of a classic mistake for a 6502 assembly coder to make. Namely in our sdcard driver, when waiting for the &amp;ldquo;proper&amp;rdquo; response from the card (which should have bit 7 cleared). The routine handling this looked like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>1 sd_cmd_response_wait:
2 ldy #sd_cmd_response_retries
3 @l: dey
4 beq sd_block_cmd_timeout ; y already 0? then invalid response or timeout
5 jsr spi_r_byte
6 bit #80 ; bit 7 clear
7 bne @l ; no, next byte
8 cmp #$00 ; got cmd response, check if $00 to set z flag accordingly
9 rts
10 sd_block_cmd_timeout:
11 debug &amp;#34;sd_block_cmd_timeout&amp;#34;
12 lda #$1f ; make up error code distinct from possible sd card responses to mark timeout
13 rts
&lt;/code>&lt;/pre>&lt;p>Classic. Obviously, line 6 should read:&lt;/p>
&lt;pre tabindex="0">&lt;code> bit #$80 ; bit 7 clear
&lt;/code>&lt;/pre>&lt;p>With that fixed, the sd card init routine now fails, which is odd since we fixed something that was obviously broken.&lt;/p>
&lt;p>&lt;img src="images/sd_fail-e1571229478149.jpg" alt="sd_fail.jpg">&lt;/p>
&lt;p>Ok, now what? Enabling Marko&amp;rsquo;s mighty debugging macros, it becomes apparent that the sd card init fails right after sending CMD0 to the card. This command is the first command of the init sequence and is supposed to put the card into &amp;ldquo;idle mode&amp;rdquo;. Which the card confirms with an answer of $01. Which is what the init code is expecting, and not getting. Instead, we get $3F, which does not make a lot of sense.&lt;/p>
&lt;p>But why did it work before the fix? Assuming that the card did not change it&amp;rsquo;s behaviour at the same time I fixed the code, let&amp;rsquo;s check what actually happened. Before the fix, we were ANDing $3F with 80:&lt;/p>
&lt;p>&lt;code> 00111111 $3f&lt;/code>&lt;br>
&lt;code>01010000 80 (no $, decimal)&lt;/code>&lt;/p>
&lt;p>In this case, the BNE after the BIT #80 would take the branch to @l, causing the next byte being read, until finally the card responds with $01:&lt;/p>
&lt;p>&lt;code> 00000001 $01&lt;/code>&lt;br>
&lt;code>01010000 80 (no $, decimal)&lt;/code>&lt;/p>
&lt;p>Now the BNE does not take the branch, and the routine exits.&lt;/p>
&lt;p>Now, with the fixed code,  ANDing $3F with **$**80, to check if bit 7 is clear, which it is:&lt;/p>
&lt;p>&lt;code> 00111111 $3F&lt;/code>&lt;br>
&lt;code>10000000 $80&lt;/code>&lt;/p>
&lt;p>Alright, exit the loop and return $3f as response of the card. Which isn&amp;rsquo;t $01, so init failed.&lt;/p>
&lt;p>At this point, I have no explanation for the card responding $3F. I assume that the card might be not ready to process commands at this point, so I added code to repeat sending CMD0 until we get $01 or we run out of retries.&lt;/p></content></item><item><title>Logikanalyse II [UPDATE]</title><link>https://www.steckschwein.de/post/logikanalyse-ii/</link><pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/logikanalyse-ii/</guid><description>Inzwischen sind die 74F00 eingetroffen und der 74HCT00 durch einen ebensolchen ersetzt. Das Oszilloskopbild sieht gleich deutlich besser aus:
gelb: /WE, blau: A9
Der Schreibvorgang wird also jetzt zumindest abgeschlossen, bevor sich die Adresse auf dem Adressbus ändert. Das ist schonmal viel sauberer.
Nur leider hat es das Problem nicht gelöst, das Steckschwein läuft mit den &amp;ldquo;richtigen&amp;rdquo; RAMs immer noch instabil, was sich insbesondere bei BASIC-Programmen bemerkbar macht:
Wäre auch zu einfach gewesen.</description><content>&lt;p>Inzwischen sind die 74F00 eingetroffen und der 74HCT00 durch einen ebensolchen ersetzt. Das Oszilloskopbild sieht gleich deutlich besser aus:&lt;/p>
&lt;p>&lt;img src="images/tekway449_3.gif" alt=""> gelb: /WE, blau: A9&lt;/p>
&lt;p>Der Schreibvorgang wird also jetzt zumindest abgeschlossen, bevor sich die Adresse auf dem Adressbus ändert. Das ist schonmal viel sauberer.&lt;/p>
&lt;p>Nur leider hat es das Problem nicht gelöst, das Steckschwein läuft mit den &amp;ldquo;richtigen&amp;rdquo; RAMs immer noch instabil, was sich insbesondere bei BASIC-Programmen bemerkbar macht:&lt;/p>
&lt;p>&lt;img src="images/photo_2017-05-04_19-56-29.jpg" alt="photo_2017-05-04_19-56-29">&lt;/p>
&lt;p>Wäre auch zu einfach gewesen.&lt;/p>
&lt;p>&lt;strong>[UPDATE]&lt;/strong> Ein weiterer Test mit anderen 55ns-SRAMs, nämlich Bausteinen von BSI im TSOP28-Gehäuse auf DIP28-Adaptern, lief problemlos durch. Das BASIC-Programm, mit dem wir testen, lief 2 Tage problemlos durch. Dies ist insofern bemerkenswert, als dass das Steckschwein mit diesen Bausteinen vorher überhaupt nicht lief. Also doch ein Erfolg. Warum die 55ns-Chips von Alliance Memory Probleme machen, müssen wir noch untersuchen.&lt;/p>
&lt;p>&lt;img src="images/photo_2017-05-06_19-57-10.jpg" alt=""> TSOP28-SRAMs auf DIP28 Adapter&lt;/p></content></item><item><title>Logikanalyse</title><link>https://www.steckschwein.de/post/logikanalyse/</link><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/logikanalyse/</guid><description>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.
Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.
Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2.</description><content>&lt;p>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.&lt;/p>
&lt;p>&lt;img src="images/logic_analyzer.jpg" alt=""> Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.&lt;/p>
&lt;p>Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2. Takthälfte für Buszugriffe nutzt. Diese ist nur 62,5ns lang. Von dieser Zeit geht ausserdem noch die Durchlaufzeit der Adressdekodierung und weiterer Glue-Logik ab. Eigens angeschaffte neue SRAMs von Alliance Memory mit 55ns Zugriffszeit sollten also ganz knapp schnell genug sein. Trotzdem treten mit diesen immer wieder merkwürdig zufällige Abstürze auf, die 100ns-Chips laufen dagegen problemlos.&lt;/p>
&lt;p>Also ran an die Maschine. Hierbei zeigte sich auch schon schnell etwas Merkwürdiges:&lt;/p>
&lt;p>&lt;img src="images/we_addr.png" alt=""> Analyse von Adress- und Datenbus sowie Steuersignale&lt;/p>
&lt;p>Es fiel etwas unangenehm auf, dass die steigende Flanke von /WE (Ende des Schreibzugriffs) direkt mit der Änderung des Adressbus zusammenfällt. Idealerweise sollte der Schreibzugriff beendet sein, bevor am Adressbus eine andere Adresse anliegt. Das Datenblatt nennt die Zeitspanne zwischen der steigenden Flanke von /WE und einer Änderung auf dem Adressbus tWR (Write Recovery Time):&lt;/p>
&lt;p>&lt;img src="images/sram_timing.png" alt="sram_timing">&lt;/p>
&lt;p>Laut Diagramm soll also /WE high werden, &lt;strong>bevor&lt;/strong> sich der Adressbus ändert. Im Datenblatt selbst ist die Write Recovery Time mit 0ns angegeben, und zwar bei beiden SRAMs, die 100ns-Typen sowie bei den 55ns-Bausteinen. Das würde bedeutet, dass die steigende Flanke von /WE mit einer Änderung der Adresse zeitlich zusammenfallen darf. Der verwendete Logicanalyzer hat eine Auflösung von 10ns, sodass man eigentlich nur sagen kann, dass sich /WE und der Adressbus im selben Zeitraum von 10ns ändern. Also schauen wir uns /WE und eine zufällige Adressleitung nochmal unterm Oszilloskop an.&lt;/p>
&lt;p>&lt;img src="images/oszi.jpg" alt=""> /WE und A9 unterm Oszilloskop. Gelb: /WE, Blau: A9&lt;/p>
&lt;p>Offenbar ändert sich der Adressbus, &lt;strong>bevor&lt;/strong> mit der steigenden Flanke von /WE der Schreibzugriff endet! Einen ausreichend schnellen Chip vorausgesetzt, könnte der anliegende Schreibzugriff womöglich in die neue Adresse hereingeschleppt werden. Wie dem auch sei, auf jeden Fall etwas, das so nicht sein darf! Wir halten die 0ns Write Recovery Time nicht ein, indem wir sie um ca. 4ns unterschreiten.&lt;/p>
&lt;p>/OE und /WE für die RAMs wird bei uns durch 3 NAND-Gatter in einem 74HCT00 aus der r/W-Leitung und dem Systemtakt erzeugt. Ein 74HCT00 hat eine Durchlaufzeit von ca. 9ns. Als nächstes werden wir also stattdessen einen 74F00 verwenden, der uns mit 3.7ns Durchlaufzeit wieder in den Bereich tWR &amp;gt; 0ns bringen sollte. Sollte es das nicht bringen, werden wir uns etwas grundsätzlichere Gedanken machen müssen.&lt;/p></content></item><item><title>Murphy III - Timing ist alles</title><link>https://www.steckschwein.de/post/murphy-iii-timing-ist-alles/</link><pubDate>Mon, 14 Apr 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/murphy-iii-timing-ist-alles/</guid><description>In den Posts http://8bit-gefriemel.blogspot.de/2014/03/murphy.html und http://8bit-gefriemel.blogspot.de/2014/04/murphy-ii.html sind einige merkwürdige Phänomene und deren Lösungsversuche geschildert. Wie sich heute gezeigt hat, konnten wir gar nicht weiter daneben liegen.
Alles Quatsch. Die Fehlersuche nach dem &amp;ldquo;K&amp;rdquo;-Problem. Stack und so. Alles super. Klar, das mit dem Initialisieren des Stackpointers war natürlich richtig und wichtig, und dass die uart_tx routine besser funktioniert wenn man auf Stack-Operationen verzichtet, hätte uns eigentlich eher stutzig machen sollen. Aber der Reihe nach.</description><content>&lt;p>In den Posts &lt;a href="http://8bit-gefriemel.blogspot.de/2014/03/murphy.html">http://8bit-gefriemel.blogspot.de/2014/03/murphy.html&lt;/a> und &lt;a href="http://8bit-gefriemel.blogspot.de/2014/04/murphy-ii.html">http://8bit-gefriemel.blogspot.de/2014/04/murphy-ii.html&lt;/a> sind einige merkwürdige Phänomene und deren Lösungsversuche geschildert. Wie sich heute gezeigt hat, konnten wir gar nicht weiter daneben liegen.&lt;/p>
&lt;p>Alles Quatsch. Die Fehlersuche nach dem &amp;ldquo;K&amp;rdquo;-Problem. Stack und so. Alles super. Klar, das mit dem Initialisieren des Stackpointers war natürlich richtig und wichtig, und dass die uart_tx routine besser funktioniert wenn man auf Stack-Operationen verzichtet, hätte uns eigentlich eher stutzig machen sollen. Aber der Reihe nach.&lt;/p>
&lt;p>Der alte Rockwell 65c02P4 wurde nämlich derweil durch einen funkelnagelneuen WDC 65c02S6TPG-14 ersetzt. Dieser brauchte zunächst einen Pullup-Widerstand für den BE-Pin, ohne den sich seine Bus-Leitungen im Tri-State-Zustand befunden hätten. Toll, wenn man den Prozessor vom Bus trennen muss, weil er ihn sich z.B. mit einem Grafikchip teilen muss. In unserem Fall aber ist der 65c02 immer der Chef. Also auf high mit dem Pin.&lt;/p>
&lt;p>Relativ unvermittelt und mit keiner zu dem Zeitpunkt offensichtlichen Änderung an der Schaltung traten dann die oben beschriebenen Probleme auf. Die Fehlersuche brachte durchaus einiges zu Tage, wie beispielsweise die bislang nicht vorhandene Initialisierung des Stackpointers, jedoch führte nichts wirklich zu einer Lösung. Die Änderung der uart_tx_routine führte dazu, dass der Upload wieder funktioniert. Bis das Problem nach einem BIOS-Update mit kaum Code-Änderungen wieder auftrat. Diesmal mit einem nicht immer erfolgreich durchlaufenden Speichertest. Das K-Problem war zurück, und hat Verstärkung mitgebracht.&lt;/p>
&lt;p>Es half nichts. Es blieb nur, zu rekapitulieren, welche Änderungen an der Schaltung vorgenommen wurden. In Chris Wards ursprünglichem Design waren die OE-Pins der 62256 SRAMS direkt mit den CS-Pins verbunden. Ein selektierter Chip hatte also automatisch auch seine Daten auf den Bus gelegt. Dies ist möglich, weil die WE-Leitung bei den verwendeten HY62256ALP-10-Bausteine ohnehin immer Vorrang hat. Aus irgendeinem Grund hat mir das nicht gefallen und ich habe die OE-Pins mit dem generierten OE-Signal verbunden, welches auch den OE-Pin des EEPROM steuert. Bislang hat dies auch immer problemlos funktioniert. Interessanterweise traten aber auch auf Markos Schaltung unerklärliche Phänomene auf, nachdem diese Modifikation dort vorgenommen wurde.&lt;/p>
&lt;p>Dann der WDC-Prozessor. Hatte es diese Probleme auch mit dem Rockwell gegeben? Der WDC kann schließlich mit bis zu 14MHz getaktet werden, der Rockwell immerhin mit 4 MHz. Zeit, mal einen Blick ins Datenblatt zu werfen. Schnell fällt auf, dass der Rockwell z.B. eine Address hold time von 30ns hat, der WDC aber nur 10ns. Eigentlich klar, der Chip ist für weit höhere Frequenzen ausgelegt, also sind auch die Timings empfindlicher. Aber dann sollte uns noch eine Sache wie Schuppen von den Augen fallen&amp;hellip;&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Eingehendere Lektüre des WDC-Datenblatts liess uns dann noch auf folgende Perle stoßen:&lt;/p>
&lt;p>&lt;em>An external oscillator is recommended for driving PHI2 and used for the main system clock. All production test timing is based on PHI2. &lt;strong>PHI2O and PHI1O were used in older systems for system timing&lt;/strong> and internal oscillators when an external crystal was used.&lt;/em> Und weiter, als Fußnote zu den Timings:&lt;/p>
&lt;ol>
&lt;li>PHI1O and PHI2O clock delay from PHI2 is no longer specified or tested and WDC recommends using an oscillator for system time base and PHI2 processor input clock.&lt;/li>
&lt;/ol>
&lt;p>Jeder 6502 hat bisher das Systemtiming selbst generiert und am Pin PHI2O bereitgestellt. Von dort aus wurde alles mit Takt versorgt, was einen Takteingang hat. Damit hat WDC nun gebrochen und empfiehlt, den Systemtakt direkt am Oszillator abzugreifen. Das hatten wir beim Austausch Rockwell gegen WDC natürlich nicht berücksichtigt, wer denkt denn an sowas. Unser Rechner hat seinen Takt old-school-like vom PHI2O bezogen. Der Screenshot vom Logic Analyzer zeigt, dass PHI2O manchmal, aber nicht immer einen Versatz.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Dementsprechend war die Lösung des Problems dann denkbar simpel: Die Taktleitungen für den Rest des Systems 2 Pins weiter nach rechts gesteckt.&lt;/p>
&lt;p>Bleibt die Frage, was man denn macht, wenn man einen 65c02 aus einem alten System ersetzen möchte. Der WDC dürfte ohne Anpassungen nicht stabil laufen.&lt;/p></content></item><item><title>Murphy II</title><link>https://www.steckschwein.de/post/murphy-ii/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/murphy-ii/</guid><description>Flugs also ein ROM gebrannt mit der memtest-routine, in die nach der Reset-Routine eingesprungen wird. Gleiches Ergebnis. Beim ersten Auftreten des &amp;ldquo;K statt OK&amp;rdquo;-Fehlers ist erstmal die doch etwas windig anmutende Verdrahtung der Adressleitungen zwischen Prozessor, den RAM-Bausteinen und dem ROM mit &amp;ldquo;richtigen&amp;rdquo; Steckbrettstrippen statt Klingeldraht nachverdrahtet worden. Das war vermutlich etwas voreilig, schließlich hats vorher ja auch schon funktioniert. Schließlich stellt sich heraus, dass sich hier in der Tat ein paar Fehler eingeschlichen haben, die auch beim Durchklingeln der einzelnen Adressleitungen nicht aufgefallen sind: Kurzschlüsse.</description><content>&lt;p>Flugs also ein ROM gebrannt mit der memtest-routine, in die nach der Reset-Routine eingesprungen wird. Gleiches Ergebnis. Beim ersten Auftreten des &amp;ldquo;K statt OK&amp;rdquo;-Fehlers ist erstmal die doch etwas windig anmutende Verdrahtung der Adressleitungen zwischen Prozessor, den RAM-Bausteinen und dem ROM mit &amp;ldquo;richtigen&amp;rdquo; Steckbrettstrippen statt Klingeldraht nachverdrahtet worden. Das war vermutlich etwas voreilig, schließlich hats vorher ja auch schon funktioniert. Schließlich stellt sich heraus, dass sich hier in der Tat ein paar Fehler eingeschlichen haben, die auch beim Durchklingeln der einzelnen Adressleitungen nicht aufgefallen sind: Kurzschlüsse.  Nachdem diese behoben wurden, läuft unser Speichertest auch wieder komplett durch.  Zeit also, sich dem eigentlichen Problem anzunehmen. Wo bleibt das &amp;ldquo;O&amp;rdquo;? Interessanterweise scheint das Empfangen von Daten nicht betroffen zu sein, denn die memtest-Routine funktioniert hochgeladen genauso wie aus dem ROM.  Also schaue ich mir die Routine an, die Daten (bytes) über den UART sendet.&lt;/p>
&lt;p>i_uart_tx         pha -       lda uart1lsr         and #$20         beq - pla         sta uart1rxtx&lt;/p>
&lt;p>rts&lt;/p>
&lt;p>Sieht doch erstmal nicht verkehrt aus. Ich mache trotzdem ein Experiment, und ersetze die Stackoperationen, indem ich stattdessen auf das X-Register ausweiche:&lt;/p>
&lt;p>i_uart_tx         tax -       lda uart1lsr         and #$20         beq - stx uart1rxtx rts Und auf einmal kriege ich mein &amp;ldquo;OK&amp;rdquo;. Schnall ich jetzt nicht. Ist der Stack kaputt? Ich mache mir ein paar grundsätzliche Gedanken und halte die Idee, den Stack Pointer einfach mal zu initialisieren, für gut. Ich packe entsprechenden Code an den Beginn der RESET-Routine, und lösche auch gleich das Dezimal-Flag. ; disable interrupt        sei ; clear decimal flag cld ; init stack pointer ldx #$ff&lt;/p>
&lt;p>txs&lt;/p>
&lt;p>Ich baue die uart_tx-Routine zurück und bekomme wieder nur &amp;ldquo;K&amp;rdquo;. Während also das Initialisieren des Stack-Pointers richtig und wichtig ist, ist unser Problem noch ein anderes. Die uart_tx-Routine sieht jetzt so aus, und bleibt so: i_uart_tx         pha         phx tax -       lda uart1lsr         and #$20         beq - stx uart1rxtx plx         pla&lt;/p>
&lt;p>rts&lt;/p>
&lt;p>Der Stack wird nach einem kurzen Testprogramm für fehlerfrei befunden. Trotzdem funktioniert die serielle Kommunikation noch nicht. Es kommt nicht das an, was gesendet wird. Das hat doch eigentlich schon funktioniert. Die Initialisierung des UART wird nochmal unter die Lupe genommen.&lt;/p>
&lt;p>lda #0        sta uart1fcr    ; FIFO off Das FCR-Register ist das FIFO-Control-Register. Die FIFO schalten wir durch das ablegen von 0 ab, da wir gerade nur Polling nutzen. Das Register bietet auch Bits zum löschen der Empfangs- und Sende-FIFO sowie setzen des &amp;ldquo;Füllstandes&amp;rdquo; bei welchen ein Interrupt ausgelöst werden soll. Laut Datenblatt aktiviert bzw. deaktiviert das Bit 0 dieses Registers die FIFO. Alle anderen Bits werden nur dann berücksichtigt, wenn Bit 0 auf 1 ist. Also vielleicht einfach mal pauschal die FIFOs löschen, und dann abschalten? lda #7            sta uart1fcr         lda #0       sta uart1fcr    ; FIFO off&lt;/p>
&lt;p>Das scheint richtig gewesen zu sein, wir haben wieder eine funktionierende Upload-Routine.&lt;/p>
&lt;p>Da ich mich inzwischen genug über den 16550 geärgert habe, beschließe ich, dass er mir ruhig was Gutes tun könnte, und setze den Baudraten-Divisor auf &amp;ldquo;1&amp;rdquo; und damit eine Baudrate von 115200.&lt;/p>
&lt;p>Die Feststellung, dass das sogar stabil funktioniert versöhnt mich fürs erste wieder und ich gehe zufrieden ins Bett.&lt;/p></content></item><item><title>... kein Spaß - Murphy schlägt zu</title><link>https://www.steckschwein.de/post/kein-spass-murphy-schlaegt-zu/</link><pubDate>Mon, 31 Mar 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/kein-spass-murphy-schlaegt-zu/</guid><description>Neben all den ermutigenden Experimenten gibt es natürlich auch immer mal wieder Rückschläge. Mittlerweile haben wir schon ein durchaus komplexes Gebilde auf dem Steckbrett, welches ja per se nicht die ideale Plattform ist, um so etwas zu bauen.
So wie aktuell gerade mein &amp;ldquo;Steckschwein&amp;rdquo; ein sehr merkwürdiges Verhalten an den Tag legt, ohne dass an der Schaltung etwas geändert worden wäre (Marko ist Zeuge).
Vorab nochmal der Ablauf unserer Upload-Routine, mit der wir das Steckschwein via RS232 mit Code befüttern:</description><content>&lt;p>Neben all den ermutigenden Experimenten gibt es natürlich auch immer mal wieder Rückschläge. Mittlerweile haben wir schon ein durchaus komplexes Gebilde auf dem Steckbrett, welches ja per se nicht die ideale Plattform ist, um so etwas zu bauen.&lt;/p>
&lt;p>So wie aktuell gerade mein &amp;ldquo;Steckschwein&amp;rdquo; ein sehr merkwürdiges Verhalten an den Tag legt, ohne dass an der Schaltung etwas geändert worden wäre (Marko ist Zeuge).&lt;/p>
&lt;p>Vorab nochmal der Ablauf unserer Upload-Routine, mit der wir das Steckschwein via RS232 mit Code befüttern:&lt;/p>
&lt;ol>
&lt;li>Transferprogramm sendet die Ladeaddresse (2 bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;li>Anzeige der Ladeaddresse im LCD&lt;/li>
&lt;li>Transferprogramm übermittelt die Länge der zu sendenden Daten (2 bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;li>Anzeige der Länge in Bytes im LCD&lt;/li>
&lt;li>Upload-Routine addiert Startaddresse + Länge in Bytes und errechnet so die Endadresse&lt;/li>
&lt;li>Anzeige der Endaddresse im LCD&lt;/li>
&lt;li>Transferprogramm sendet den Code (n bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;/ol>
&lt;p>Völlig unprovoziert wird auf einmal das &amp;ldquo;O&amp;rdquo; unterschlagen, sodass wir nur noch ein &amp;ldquo;K&amp;rdquo; erhalten. Dies läßt sich gut mit einem Terminalprogramm nachvollziehen. Um weiter debuggen zu können, passen wir das Transferprogramm an, dass es sich auch mit &amp;ldquo;K&amp;rdquo; zufriedengibt und laden eine echo-Routine, die die empfangenen Zeichen wieder über RS232 zurückschreibt und außerdem auf dem Display ausgibt.&lt;/p>
&lt;p>Wir beobachten, wie einige Zeichen wieder ge-echo-t werden, andere nicht, während sie nebst einigem Müll sowie der Ziffer 0 auf dem Display ausgegeben werden.&lt;/p>
&lt;p>Ein ähnliches Phänomen haben wir schon beim Einbau/Programmierung des UART beobachtet. Damals war der Fehler, dass die FIFO aktiviert war. Da wir den UART aktuell nur mittels Polling betreiben, gab es Probleme, die sich mit der Deaktivierung der FIFO beheben ließen. Das ist hier anders. Und zu allem Überfluss scheint das Phänomen zeitweilig auch wieder zu verschwinden. Will heissen: Ohne unser Zutun kam auch wieder ein &amp;ldquo;OK&amp;rdquo;. Dann wieder nicht mehr. Die zugegeben bis dato etwas windige Verdrahtung der Speicherchips wurde bei der Gelegenheit durch &amp;ldquo;richtige&amp;rdquo; Steckstrippen ersetzt. Die dabei entstandenen Fehler wurden schließlich auch gefunden, sodass wir mit einem Tag Verzug wieder so weit waren, das eigentliche Problem zu erforschen.&lt;/p>
&lt;p>Unsere Mem-Test-Routine läßt sich hochladen, zeigt aber immer denselben Fehler. Da wir nicht sicher sein können, ob die Routine tatsächlich korrekt hochgeladen wurde, macht weiteres Testen nur Sinn, wenn die dazu notwendigen Routinen bereits im ROM liegen.&lt;/p></content></item></channel></rss>