<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gal on</title><link>https://beta.steckschwein.de/categories/gal/</link><description>Recent content in gal on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 08 Mar 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://beta.steckschwein.de/categories/gal/index.xml" rel="self" type="application/rss+xml"/><item><title>Neue CPU-Boards</title><link>https://beta.steckschwein.de/post/neue-cpu-boards/</link><pubDate>Tue, 08 Mar 2016 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/neue-cpu-boards/</guid><description>Wir haben vor, eine neue Revision der Steckschwein-Prototyp-Platinen herzustellen. Den Anfang macht ein neues CPU-Board mit einigen Bugfixes und den in Chiptuning beschriebenen zusätzlichen GAL als Waitstate-Generator, sowie einem geändertem Stromanschluss: In Zukunft wird es möglich sein, das Steckschwein mit nur 5V per USB, über einen Rundstecker oder wie gehabt über einen Pin-Header zu versorgen. Die Layouts sind schon fertig:
Bestückungsseite
Lötseite</description><content>&lt;p>Wir haben vor, eine neue Revision der Steckschwein-Prototyp-Platinen herzustellen. Den Anfang macht ein neues CPU-Board mit einigen Bugfixes und den in &lt;a href="http://www.steckschwein.de/index.php/2016/01/30/chiptuning/">Chiptuning&lt;/a> beschriebenen zusätzlichen GAL als Waitstate-Generator, sowie einem geändertem Stromanschluss: In Zukunft wird es möglich sein, das Steckschwein mit nur 5V per USB, über einen Rundstecker oder wie gehabt über einen Pin-Header zu versorgen. Die Layouts sind schon fertig:&lt;/p>
&lt;p>&lt;img src="images/top.png" alt=""> Bestückungsseite&lt;/p>
&lt;p>&lt;img src="images/bottom.png" alt=""> Lötseite&lt;/p></content></item><item><title>Chiptuning</title><link>https://beta.steckschwein.de/post/chiptuning/</link><pubDate>Sat, 30 Jan 2016 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/chiptuning/</guid><description>An den Heimcomputern von &amp;ldquo;damals&amp;rdquo; gemessen ist das Steckschwein mit 4 MHz durchaus einer der schnelleren 6502-Rechner. Damals waren zumeist Taktraten von 1 MHz üblich. Einige wenige hatten deutlich mehr, wie z.B. der Apple IIgs (65816) mit 2.8 MHz. Einen 4 MHz-65(C)02-Heimcomputer hat es damals nach unserem Informationsstand nicht gegeben.
Nun ist es aber so, dass aktuell erhältliche 65c02-CPUs von WDC offiziell mit bis zu 14MHz getaktet werden können, inoffiziell wurden schon problemlos Taktraten von 20 MHz erreicht.</description><content>&lt;p>An den Heimcomputern von &amp;ldquo;damals&amp;rdquo; gemessen ist das Steckschwein mit 4 MHz durchaus einer der schnelleren 6502-Rechner. Damals waren zumeist Taktraten von 1 MHz üblich. Einige wenige hatten deutlich mehr, wie z.B. der Apple IIgs (65816) mit 2.8 MHz. Einen 4 MHz-65(C)02-Heimcomputer hat es damals nach unserem Informationsstand nicht gegeben.&lt;/p>
&lt;p>Nun ist es aber so, dass aktuell erhältliche 65c02-CPUs von WDC offiziell mit bis zu 14MHz getaktet werden können, inoffiziell wurden schon problemlos Taktraten von 20 MHz erreicht. Da ist also noch Raum für eine Prise Größenwahn. Den Takt des Steckschweins pauschal zu erhöhen funktioniert nicht. Zu viele Bausteine kommen dann nicht mehr mit. Das verwendete Atmel 28c256 EEPROM hat eine Zugriffszeit von 150ns. Im WDC-Datenblatt ist tACC des Prozessors bei 4MHz mit 145ns angegeben. Also ist das stand jetzt schon etwas eng. Schneller takten geht also schon allein deswegen auf keinen Fall. Für den Videochip TMS9929 und den Soundchip gilt ähnliches. Das SRAM hingegen läßt sich problemlos gegen Bausteine von Alliance Memory mit 55ns Zugriffzeit austauschen. Damit sollten Taktraten von um die 10 MHz möglich sein.&lt;/p>
&lt;p>Was wir also brauchen ist eine Möglichkeit, auf RAM und VIA (sofern auch WDC und damit gleich schnell)  mit voller Geschwindigkeit zuzugreifen, währen wir den Prozessor bei Zugriffen auf ROM, Video- und Soundchip für 1-2 Zyklen stoppen. Schließlich ist man geschätzt zu 99% im RAM unterwegs.&lt;/p>
&lt;p>Erste Überlegungen gingen in die Richtung, die Taktfrequenz umschaltbar zu machen, je nachdem, welcher Baustein auf dem Bus von der CPU angesprochen wird. Dieses Prinzip birgt zwei entscheidende Nachteile:&lt;/p>
&lt;ol>
&lt;li>Man darf den Takt nicht einfach so umschalten. Erwischt man einen ungünstigen Moment, kann dies die CPU zum Absturz bringen. Näheres kann in einem &lt;a href="http://www.6502.org/mini-projects/clock-switching/clock-switching.html">entsprechenden Artikel auf 6502.org&lt;/a> nachgelesen werden.&lt;/li>
&lt;li>Die VIA-Timer sind direkt abhängig von der Taktfrequenz. Software, die diese benutzt, könnte sich nicht mehr auf diese verlassen, wenn sich die Taktfrequenz ständig ändert.&lt;/li>
&lt;/ol>
&lt;p>Zum Glück bietet der 6502 auch hier genau das, was wir brauchen: Den RDY-Pin. Wird dieser auf LOW gezogen, &amp;ldquo;friert&amp;rdquo; der 6502 ein. Kehrt RDY wieder auf HIGH zurück, macht die CPU dort weiter, wo sie unterbrochen wurde. Durch geschicktes Ansteuern dieser Leitung können wir den Prozessor also veranlassen, auf langsamere Bausteine zu warten. Dieses Konzept nennt sich Wait States (eben Wartezyklen) und ist bei aktuellen Computern gang und gäbe.&lt;/p>
&lt;p>Im Grunde genommen brauchen wir also einen Zähler, der die Taktfrequenz des Systems herunterteilt, und eine Selektionslogik, über die sich wählen läßt, welcher Ausgang des Zählers die Grundlage für das RDY-Signal bilden soll, und damit die Anzahl der Wait States bestimmt. Dieses Signal bildet invertiert das RDY-Signal.&lt;/p>
&lt;p>&lt;img src="images/tekway331_2.gif" alt=""> Gelb: RDY, Blau: PHI2 (Systemtakt) - 2 Wait States für den Videochip&lt;/p>
&lt;p>Zur folgender Logik haben wir uns vom &lt;a href="http://sbc.rictor.org/parts/wsgen.html">Waitstate-Generator von Daryl Rictor&lt;/a>  stark inspirieren lassen. Im Wesentlichen haben wir die Adressdekoderlogik zugunsten der bereits ausdekodierten /CS_&amp;hellip; Leitungen entfernt, sowie die Syntax von CUPL nach GALasm überführt.&lt;/p>
&lt;p>&lt;img src="images/img_20160130_144611.jpg" alt=""> Waitstate-Generator-Prototyp auf dem Steckbrett&lt;/p>
&lt;p>Folgende Schaltung erzeugt entsprechend 1 oder 2 Waitstates, und versetzt den Ausgangspin in den Tri-State-Zustand, damit auch andere Bausteine Wait-States anfordern können. Sollten einmal mehr Waitstates nötig werden, lassen sich noch 1 oder 2 Zählerstufen hinzufügen, um 4 oder 8 Waitstates zu erzeugen.&lt;/p>
&lt;pre tabindex="0">&lt;code>GAL16V8
RDYGEN
Clock ROM VIA UART VDP SND NC NC Clear GND
/OE RDY W1 W2 NC NC NC Q1 Q0 VCC
W2 = ROM \* VIA \* UART \* SND \* /VDP
+ ROM \* VIA \* UART \* /SND \* VDP
W1 = W2
+ /ROM \* VIA \* UART \* VDP
Q0.R = W1 \* /Q0 \* /Q1 \* Clear
+ W2 \* /Q0 \* /Q1 \* Clear
Q1.R = W2 \* /Q1 \* Q0 \* Clear
RDY.T = /Q0 \* /Q1
RDY.E = W1
&lt;/code>&lt;/pre>&lt;p>DESCRIPTION:
Generation of /RDY line modeled after &lt;a href="http://sbc.rictor.org/parts/wsgen.html">http://sbc.rictor.org/parts/wsgen.html&lt;/a>
and adapted to galasm syntax&lt;/p>
&lt;p>Wir freuen uns jetzt über ein 8MHz-Steckschwein. Das Tolle ist, dass die VIA ebenfalls mit 8 MHz und ohne Waitstates betrieben werden kann, sodass sich die erhöhte Geschwindigkeit 1:1 auf den SPI-Bus auswirkt. Zugriffe auf die SD-Karte sind damit gleich doppelt so schnell.&lt;/p></content></item><item><title>ROM an, ROM aus</title><link>https://beta.steckschwein.de/post/rom-an-rom-aus/</link><pubDate>Sun, 26 Oct 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/rom-an-rom-aus/</guid><description>Nachdem wir also mit dem Adressdecoder durchaus zufrieden sind, müssen wir uns noch einen Weg überlegen, die /ROMOFF-Leitung per Software steuerbar zu machen. Wenn es schon beim BIOS-Update Test äußerst nützlich ist einfach nur eine Brücke umzustecken und damit das ROM zu deaktivieren, wie praktisch muss es erst sein, dies einfach durch Beschreiben einer Speicherstelle zu tun.
Was wir also brauchen, ist ein IO-Pin, der die /ROMOFF-Leitung steuert. Zusätzlich muss dieser Pin beim Einschalten des Systems einen definierten Zustand haben, damit sichergestellt ist, daß zu diesem Zeitpunkt das ROM eingeblendet ist.</description><content>&lt;p>Nachdem wir also mit dem Adressdecoder durchaus zufrieden sind, müssen wir uns noch einen Weg überlegen, die /ROMOFF-Leitung per Software steuerbar zu machen. Wenn es schon beim BIOS-Update Test äußerst nützlich ist einfach nur eine Brücke umzustecken und damit das ROM zu deaktivieren, wie praktisch muss es erst sein, dies einfach durch Beschreiben einer Speicherstelle zu tun.&lt;/p>
&lt;p>Was wir also brauchen, ist ein IO-Pin, der die /ROMOFF-Leitung steuert. Zusätzlich muss dieser Pin beim Einschalten des Systems einen definierten Zustand haben, damit sichergestellt ist, daß zu diesem Zeitpunkt das ROM eingeblendet ist. Passende Pins finden wir an der VIA und am UART. Die Portpins der VIA beispielsweise sind initial als Eingänge geschaltet und per internem Pullup high. Auch die OUT1 und OUT2-Pins des UART sind initial high. Gegen den UART-Ansatz spricht, dass sich diese Pins  nur über ein Write-Only-Register setzen lassen und es keine Möglichkeit gibt, den Zustand dieser Pins über irgendein UART-Register abzufragen.&lt;/p>
&lt;p>Der VIA-Ansatz hat den Nachteil, dass die Pins zwar einen definierten Zustand haben, dies aber nur &amp;ldquo;zufällig&amp;rdquo;, weil die VIA-Pins initial immer als Eingang definiert sind und damit nach &amp;ldquo;außen&amp;rdquo; Hi werden. Außerdem sind die Ports der VIA alle verplant. Port B ist vollständig für SPI vorgesehen, Port A stellt die Joystickports. Sicher wäre es möglich, von Port B einen SPI_SS abzuknapsen, doch so richtig sauber wäre das nicht.&lt;/p>
&lt;p>Besser für eine richtig saubere Lösung wäre also eine dedizierte Schaltung, die folgendes erfüllen soll: - Einen Pin mit definiertem Ausgangszustand - Dieser soll durch Schreiben in eine Speicherstelle verändert werden können - Der Zustand soll durch Lesen der Speicherstelle ermittelt werden können - Es soll kein vorhandener Chip (VIA, UART, ..) missbraucht werden&lt;/p>
&lt;p>Kurz: Wir wollen einen dedizierten Ausgabeport in den Adressraum bzw. IO-Bereich einblenden. Der ideale Baustein hierfür wäre ein 8bit Tri-State Latch mit Reset. Einen Baustein, der all das kann, finden wir nicht. Die nächstbeste Möglichkeit wäre ein 74hct273, einem 8bit-Latch mit Reset, dem wir einen 74hct244-Buffer vorschalten, um ihn vom Bus zu nehmen, wenn er nicht selektiert ist. Leider befindet sich kein 74hct273 in der Bastelkiste, sodass erste Experimente mit einem Flipflop aus einem 74ls74 und einem Tri-State-Buffer im für das SD-Karten-Interface bereits verbauten 74hct125 stattfinden müssen. Sozusagen die kleine Variante mit nur einem Bit.&lt;/p>
&lt;p>&lt;strong>Update:&lt;/strong> Nach reiflicher Überlegung kann auf den Buffer auch verzichtet werden. Das Latch legt ja nur Eingänge auf den Bus, und tut nur etwas, wenn es per /CS eine CLK-Flanke bekommt. Also rationalisieren wir den Buffer weg und sparen einen Chip.&lt;/p>
&lt;p>&lt;img src="images/screen-2bshot-2b2014-10-26-2bat-2b16-33-081.png" alt="screen-2bshot-2b2014-10-26-2bat-2b16-33-081">&lt;/p>
&lt;p>/MEMCTL haben wir den IO-Select-Pin des GAL genannt. Mit dieser Verdrahtung ist es nun möglich, das Flipflop durch Beschreiben einer Speicherstelle zu kippen. Was noch fehlt, ist die Möglichkeit, den Zustand des Ports auslesen zu können.&lt;/p>
&lt;p>Ein Ansatz wäre, den Ausgang des Flipflop über einen weiteren Buffer wieder an den Datenbus zu koppeln und abhängig davon, ob gelesen oder geschrieben wird, den einen oder andere Buffer zu aktivieren. Dies würde aber zusätzliche Logik erfordern. Ein Ansatz mit geringerem Chipcount ist uns lieber. Wie wäre es, wenn wir für Schreibzugriffe an diesen Port nicht nur das Latch, sondern auch das darunterliegende RAM selektieren? Das geschriebene Byte würde somit im RAM gespiegelt. Dann müßte nur noch sichergestellt werden, dass das Latch nur noch bei Schreibzugriffen selektiert wird, sodass Lesezugriffe nur noch im RAM landen. Dies erfordert Anpassungen an der Dekoderlogik im GAL:&lt;/p>
&lt;p>/MEMCTL = /A15*/A14*/A13*/A12 * /A11*/A10*A9*/A8 * A7*A6*A5*A4 * /RW ; $02f0&lt;/p>
&lt;p>Wir legen unsere /MEMCTL-Leitung so weit wie möglich ans Ende des IO-Bereichs, und beziehen RW mit in den Term ein. Der Term für LORAM muss auch angepasst werden, damit $02f0 nicht mehr teil des reinen IO-Blocks ist. Hierzu nehmen wir A7 mit in den Term auf, was den IO-Bereich verkleinert (halbiert), sodass dieser an $027F endet. Mehr IO-Pins haben wir ohnehin nicht. Gleichzeitig haben wir noch Reserven im Adressraum, falls wir doch mal einen Block größer 16 Byte brauchen.&lt;/p>
&lt;p>Vorher CSLORAM = /A14 * /A13 * /A12 * /A11 * /A10 * A9 * /A8 + A15&lt;/p>
&lt;p>Nachher&lt;/p>
&lt;p>CSLORAM = /A14 * /A13 * /A12 * /A11 * /A10 * A9 * /A8 * /A7 + A15&lt;/p>
&lt;p>Hiermit hat sich die Speicherbelegung wie folgt verändert.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Bereich&lt;/th>
&lt;th>Was&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$0000 - $01ff&lt;/td>
&lt;td>RAM (Zeropage und Stack)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0200 - $027f&lt;/td>
&lt;td>IO-Bereich&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0280 - $02ef&lt;/td>
&lt;td>RAM (reserviert)*&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$02f0 - $02ff&lt;/td>
&lt;td>MEMCTL-Register&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0300 - $dfff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$e000 - $ffff&lt;/td>
&lt;td>ROM (ausblendbar)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>* Das RAM an dieser Stelle ist im Grunde nutzbar, da wir aber Stand heute noch nicht wissen, ob dort später nicht doch noch IO-Adressen gemappt werden, deklarieren wir diesen Bereich als &amp;ldquo;reserviert&amp;rdquo;.&lt;/p>
&lt;p>Jetzt fehlen nur noch die &amp;ldquo;richtigen&amp;rdquo; Chips, um das Ganze 8bit breit umzusetzen.&lt;/p>
&lt;p>Von den jetzt noch freien 7 Bit des so entstandenen &amp;ldquo;Memctl-Register&amp;rdquo; (nennen wir es ruhig so) verbinden wir Bit 1 und Bit 2 mit den Adressleitungen A13 und A14 des ROM, die vorher hart auf Masse lagen. Damit haben wir die Möglichkeit, die kompletten 32K des ROM zu nutzen, auch wenn wir aktuell noch nicht genau wissen, wofür :-). Aber so ist dann schonmal nichts verbaut.&lt;/p>
&lt;p>Der kleine Schönheitsfehler dieser Lösung soll nicht verschwiegen werden: Der Inhalt des RAM ist beim Einschalten bekanntlich nicht definiert. Direkt nach dem Einschalten und bevor das erste Mal ins Register geschrieben wurde, lesen wir aus dem Register also alles, nur nicht den Zustand des Latch. Hier werden wir uns etwas Schlaues per Software überlegen müssen.&lt;/p></content></item><item><title>Dekoder, die Dritte</title><link>https://beta.steckschwein.de/post/dekoder-die-dritte/</link><pubDate>Thu, 23 Oct 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/dekoder-die-dritte/</guid><description>Bekanntlich dekodiert unser GAL die oberen 8bit des Adressbus, um den Bereich $8000-$ffff unter RAM, IO-Bereich und ROM einzuteilen. Die unteren 32k werden am Decoder vorbei direkt von der Adressleitung A15 selektiert. Das Memory-Mapping, das sich daraus ergibt, ist - zur Wiederholung - wie folgt:
Bereich Was $0000 - $7fff RAM $8000 - $cfff RAM $d000 - $dfff IO-Bereich $e000 - $ffff ROM Die letzte Änderung am Decoder war, das ROM bei Bedarf ausblendbar zu machen.</description><content>&lt;p>Bekanntlich dekodiert unser GAL die oberen 8bit des Adressbus, um den Bereich $8000-$ffff unter RAM, IO-Bereich und ROM einzuteilen. Die unteren 32k werden am Decoder vorbei direkt von der Adressleitung A15 selektiert. Das Memory-Mapping, das sich daraus ergibt, ist - zur Wiederholung - wie folgt:&lt;/p>
&lt;p> &lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Bereich&lt;/th>
&lt;th>Was&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$0000 - $7fff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$8000 - $cfff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$d000 - $dfff&lt;/td>
&lt;td>IO-Bereich&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$e000 - $ffff&lt;/td>
&lt;td>ROM&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;a href="http://wordpress.steckschwein.de/wordpress/index.php/2014/07/01/noch-schlauerer-decoder/">Die letzte Änderung&lt;/a> am Decoder war, das ROM bei Bedarf ausblendbar zu machen. Dieser Mechanismus hat sich beim Test von BIOS-Updates als pures Gold erwiesen, da man ums neu Brennen des EEPROM herumkommt. Das spart Zeit und schont Material.&lt;/p>
&lt;p>Trotzdem sehen wir noch viel Raum für Verbesserungen. Insbesondere im IO-Bereich hätten wir gerne mehr Granularität. Aktuell verschenken wir ganze 4K, jedes IO-Device bekommt eine ganze 256 byte-Page zugeschustert. Die meisten Chips  in dem Bereich haben gerade mal eine Handvoll Register.&lt;/p>
&lt;p>Würden wir nicht nur die oberen 8, sondern 12 bit des Adressbus dekodieren, hätten wir 16byte-Blöcke für IO-Devices. Wir würden mit einer 256byte-Page mehr als locker auskommen. Der Chip mit den meisten Registern ist unsere 65c22 VIA mit genau 16 Stück. Alle anderen haben weit weniger. Passt also.&lt;/p>
&lt;p>Bei der Gelegenheit bereinigen wir das Pinout des GAL, indem wir die Glue-Logic für das LCD rauswerfen. Dadurch brauchen wir im Decoder auch kein PHI2 mehr, was uns einen freien Eingang zurückgibt, und die /CS-Pins sind alle gleichförmig active low. Die Sonderlocke E_LCD muss jetzt aus /CSIO in einem 7400 extern generiert werden.&lt;/p>
&lt;p>&amp;mdash;&amp;mdash;-___/&amp;mdash;&amp;mdash;-&lt;/p>
&lt;p>A15 |  1           24 | VCC&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A14 |  2           23 | CSIO&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A13 |  3           22 | CSSND&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A12 |  4           21 | CSVDP&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A11 |  5           20 | CSVIA&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A10 |  6           19 | CSUART&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A9 |  7           18 | CSHIRAM&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A8 |  8           17 | CSLORAM&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A7 |  9           16 | CSROM&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A6 | 10           15 | ROMOFF&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A5 | 11           14 | RW&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>GND | 12           13 | A4&lt;/p>
&lt;hr>
&lt;p>Wer genau hinschaut, erkennt, dass /CSHIRAM ein Pendant bekommen hat: /CSLORAM.&lt;/p>
&lt;p>Hintergrund ist, dass wir uns entschieden haben, den IO-Bereich &amp;ldquo;nach unten&amp;rdquo; zu verschieben, und zwar nach $0200, direkt über den Stack. Damit ist das RAM von $0300 bis $dfff komplett nutzbar. Blendet man das ROM aus, lassen sich die kompletten 64k minus 768 bytes für Zeropage, Stack und IO vollständig nutzen. Ein IO-Bereich mittendrin bei $d000 würde da stören.&lt;/p>
&lt;p>Wie eingangs erwähnt wurde der RAM-Baustein für $0000-$7fff direkt über die A15 selektiert. Würde der GAL so den IO-Bereich nach $0200 blenden, wären dort dann der selektierte IO-Baustein und das RAM selektiert, was zumindest bei Lesezugriffen nicht funktionieren kann. Folglich muss der GAL auch das CS für das untere RAM kontrollieren.&lt;/p>
&lt;p>Die Gleichung sieht folgendermaßen aus:&lt;/p>
&lt;p>CSLORAM = /A14 * /A13 * /A12 * /A11 * /A10 * A9 * /A8 + A15&lt;/p>
&lt;p>Als äußerst hilfreich hat sich übrigens die App &lt;a href="https://play.google.com/store/apps/details?id=com.flx.flxkarnaugh&amp;amp;hl=de">FLXKarnaugh&lt;/a> erwiesen. Die neue Memory-Map sieht also so aus:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Bereich&lt;/th>
&lt;th>Was&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$0000 - $01ff&lt;/td>
&lt;td>RAM (Zeropage und Stack)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0200 - $02ff&lt;/td>
&lt;td>IO-Bereich&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0300 - $dfff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$e000 - $ffff&lt;/td>
&lt;td>ROM (ausblendbar)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Für uns fühlt sich das Design jetzt deutlich &amp;ldquo;sauberer&amp;rdquo; an. Der GAL hat die alleinige Kontrolle über den Adressraum, macht dafür aber auch nichts anderes als Adressdekodierung und wird nicht auch noch für Glue-Logic-Aufgaben missbraucht. A propos Glue Logic - die Ausgänge des GAL reichen nur bis Adresse $0240, also demultiplexen wir /CSIO, indem wir es als Enable für ein 74ls139 verwenden, und A4 und A5 dort dekodieren. Damit erhalten wir 3 weitere CS-Pins für IO-Komponenten und haben immer noch Platz im IO-Bereich.&lt;/p>
&lt;p>Als nächstes wollen wir uns einen Weg überlegen, die /ROMOFF-Leitung per Software zu steuern.&lt;/p></content></item><item><title>Noch schlauerer Decoder</title><link>https://beta.steckschwein.de/post/noch-schlauerer-decoder/</link><pubDate>Tue, 01 Jul 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/noch-schlauerer-decoder/</guid><description>Wir sind jetzt also fast in der Lage, das RAM unter dem ROM zu nutzen. Hineinschreiben geht, lesen noch nicht. Da ist das ROM noch im Weg. Wir müssen also einen Weg finden, die GAL-Logik von außen zu beeinflussen. Unser GAL hat noch genügend Eingänge, sodass wir einen Pin zum ROM-Ein-/Ausschalter machen wollen. Lesezugriffe nach $e000-$ffff sollen also nur noch dann im ROM landen, wenn es &amp;ldquo;eingeschaltet&amp;rdquo; ist. Sonst wollen wir ins RAM.</description><content>&lt;p>Wir sind jetzt also fast in der Lage, das RAM unter dem ROM zu nutzen. Hineinschreiben geht, lesen noch nicht. Da ist das ROM noch im Weg. Wir müssen also einen Weg finden, die GAL-Logik von außen zu beeinflussen. Unser GAL hat noch genügend Eingänge, sodass wir einen Pin zum ROM-Ein-/Ausschalter machen wollen. Lesezugriffe nach $e000-$ffff sollen also nur noch dann im ROM landen, wenn es &amp;ldquo;eingeschaltet&amp;rdquo; ist. Sonst wollen wir ins RAM. Die wiederum erweiterte Logik im GAL sieht jetzt so aus:&lt;/p>
&lt;p>/CSHIRAM = G1*/A2                                 + G1*/A1*/A0          + /RW*G1*A2*A1 ; Writes to $e000-$ffff go to the RAM          + /ROMOFF*RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the RAM, IF ROMOFF is Low /CSROM   = ROMOFF*RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the ROM, IF ROMOFF is High ROMOFF haben wir Pin 13 des GAL zugeordnet. Und tatsächlich startet unser Steckschwein nur noch, wenn dieser PIN mittels eines PullUp-Widerstands nach High gezogen wird.  Lassen wir unser Testprogramm aus dem letzten Post nochmal laufen:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Das gewohnte Bild, Lesezugriff geht ins ROM, Schreibzugriff ins RAM. Jetzt ziehen wir ROMOFF auf Masse und schalten damit das ROM aus:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Volltreffer, das ROM wird nicht mehr selektiert, wir landen immer im RAM. ROMOFF müssen wir jetzt nur noch per Software steuerbar machen, und unser nutzbares RAM hat sich um 8k erweitert, sofern wir in Kauf nehmen, dass wir keine ROM-Routinen verwenden können, solange wir dort lesen. Aber das ist beim C64 ja auch nicht anders. Ein konkreter Verwendungszweck der neuen Dekoderlogik drängt sich bereits auch ohne Softwaresteuerung der ROMOFF-Leitung auf: Das Testen neuer Versionen des ROM-Code(BIOS) ohne jedesmal das EEPROM brennen zu müssen. Schon richtig modern. Als abschließendes Experiment verbinden wir ROMOFF mit dem Bit0 von Port A der VIA. Die VIA hat die angenehme Eigenschaft, dass ihre Ports im Urzustand immer als Eingänge geschaltet sind und die Pins durch interne Pullups auf H gezogen werden. Um jetzt aus dem RAM ab $e000 zu lesen, brauchen wir nur Bit 0 von Port A der VIA zu löschen. Folgendes Programm testet, ob das auch so klappt: lda #000001         sta via1porta ; Pin 0 von Port A auf 1 setzen -&amp;gt; ROM ein         sta via1ddra  ; Pin 0 von Port A als Ausgang setzen lda #$00         ldx #$42         stx $e000     ; $42 landet im RAM dec via1porta ; Pin 0 von Port A ist jetzt 0 -&amp;gt; ROM  aus         lda $e000     ; $42 aus dem RAM lesen         inc via1porta ; -&amp;gt; ROM ein jsr lcdhex&lt;/p>
&lt;p>&amp;hellip; und auf dem LCD erscheint die $42. Freude.&lt;/p></content></item><item><title>Schlauer(er) Decoder</title><link>https://beta.steckschwein.de/post/schlauerer-decoder/</link><pubDate>Tue, 01 Jul 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/schlauerer-decoder/</guid><description>Im Rahmen unserer Reihe &amp;ldquo;Kleine Verbesserungen an der Architektur&amp;rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:</description><content>&lt;p>Im Rahmen unserer Reihe &amp;ldquo;Kleine Verbesserungen an der Architektur&amp;rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:&lt;/p>
&lt;p>/CSHIRAM = G1*/A2                          + G1*/A1*/A0 /CSROM   = G1*A2                  Wir machen also die CS-Signale statisch von der anliegen Adresse abhängig. Aber es sollte doch möglich sein, grundsätzlich auch zwischen Reads und Writes auf die entsprechenden Adressen zu unterscheiden, oder? Die /RW-Leitung des Prozessors liegt ohnehin am GAL an. Was spricht dagegen, Lesezugriffe nach $e000-$ffff aus dem ROM zu holen, Schreibzugriffe aber immer ins RAM zu leiten? Der C64 kann das schließlich auch. Schreiben wir ein kleines Testprogramm:&lt;/p>
&lt;p>main ldx #$00 loop lda $e000,x sta $e000,x inx cpx #$ff bne loop jmp main&lt;/p>
&lt;p>Wir lesen also aus dem ROM-Bereich und schreiben gleich wieder zurück. Das Oszilloskop zeigt uns /CSHIRAM (gelb) und /CSROM (blau):&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Die Schreibzugriffe landen erwartungsgemäß nicht im RAM, dieses wird zu keiner Zeit selektiert.&lt;/p>
&lt;p>Jetzt passen wir die Gleichungen für /CSHIRAM und /CSROM an, indem wir die Abhängigkeit von /RW berücksichtigen:&lt;/p>
&lt;p>/CSHIRAM = G1*/A2&lt;/p>
&lt;ul>
&lt;li>
&lt;p>G1*/A1*/A0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/RW*G1*A2*A1 ; Writes to $e000-$ffff go to the RAM&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>/CSROM   = RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the ROM&lt;/p>
&lt;p>Und jetzt lassen wir unser Programm nochmal laufen:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Wir erkennen einen Lesezugriff (/CSROM, LDA $e000,x) und direkt darauf einen Schreibzugriff ins RAM (/CSHIRAM, STA $e000,x).&lt;/p>
&lt;p>Hurra, schreiben wir jetzt &amp;ldquo;ins ROM&amp;rdquo;, landen unsere Schreibzugriffe automatisch im darunterliegenden RAM. Allerdings nützt uns das noch nichts, denn noch können wir aus dem RAM nicht lesen.&lt;/p>
&lt;p>Im nächsten Teil erweitern wir also die GAL-Logik um einen Steuerpin, mit dem wir das ROM vollständig ausblenden und das RAM entsprechend freilegen können.&lt;/p></content></item><item><title>Verfeinerungen am Design</title><link>https://beta.steckschwein.de/post/verfeinerungen-am-design/</link><pubDate>Tue, 24 Jun 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/verfeinerungen-am-design/</guid><description>So langsam geht es weiter mit der Steckschweinentwicklung.
Die Timingprobleme mit dem VDP bedürfen einer eingehenden Prüfung und Messung, um genau zu verstehen, wo was nicht passt. Unsere Ideen mit Puffern und/oder versetzten Taktsignalen, um den VDP früher &amp;ldquo;kommen&amp;rdquo; zu lassen stellen wir zurück, bis wir gesicherte Erkenntnisse haben. Ein Herumdoktern aufgrund von Vermutungen halten wir nicht für zielführend. Vorher ist es auch nicht sinnvoll, irgendwelche Platinen zu löten.
Stattdessen stecken wir ein wenig Hirnschmalz ins aktuelle Design.</description><content>&lt;p>So langsam geht es weiter mit der Steckschweinentwicklung.&lt;/p>
&lt;p>Die Timingprobleme mit dem VDP bedürfen einer eingehenden Prüfung und Messung, um genau zu verstehen, wo was nicht passt. Unsere Ideen mit Puffern und/oder versetzten Taktsignalen, um den VDP früher &amp;ldquo;kommen&amp;rdquo; zu lassen stellen wir zurück, bis wir gesicherte Erkenntnisse haben. Ein Herumdoktern aufgrund von Vermutungen halten wir nicht für zielführend. Vorher ist es auch nicht sinnvoll, irgendwelche Platinen zu löten.&lt;/p>
&lt;p>Stattdessen stecken wir ein wenig Hirnschmalz ins aktuelle Design. Die Anbindung des UART fällt negativ auf. Hier wurde der &lt;a href="http://www.6502.org/users/andre/icaphw/c64ser.html">Ansatz von Andre Fachat&lt;/a> quasi 1:1 kopiert, sodass der GAL die Signale /RD und /WR für den UART abhängig von PHI2 und der angelegten Adresse erzeugt, während PHI2 ausserdem an CS1 des UART anliegt. Das funktioniert, fügt sich aber nicht ganz in unser Design ein.&lt;/p>
&lt;p>Eigentlich sollte es möglich sein, im GAL ein einfaches /CS-Signal für den UART zu erzeugen. Die Aufsplittung von /WR nach /OE und /WE haben wir ja ohnehin schon gemacht, sodass wir diese einfach direkt an /RD und /WR des UART geben können. Dadurch, dass PHI2 und /OE, /WE durch tPROP des 7400 versetzt sind, sollte sich hier dann auch eine Timingfehlerquelle in Luft aufgelöst haben. Als angenehmer Nebeneffekt wird wieder ein Output Pin am GAL frei.&lt;/p>
&lt;p>Erste Tests haben gezeigt, dass nun auch unser &lt;a href="http://8bit-gefriemel.blogspot.de/2014_04_02_archive.html">&amp;ldquo;OK&amp;rdquo;-Problem&lt;/a>, hinter dem wir lange hinterhergesucht haben, nicht mehr auftritt, egal, ob wir das System wie von WDC empfohlen direkt mit dem Oszillator takten oder ob wir 6502-Oldschool den Taktausgang des Prozessors PHI2O benutzen.&lt;/p></content></item><item><title>Das Design wird erweitert</title><link>https://beta.steckschwein.de/post/das-design-wird-erweitert/</link><pubDate>Sun, 16 Mar 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/das-design-wird-erweitert/</guid><description>Sinn der Sache ist ja nicht, etwas 1:1 nachzubauen, sondern ein möglichst eigenes Design. Nachdem wir mit Chris&amp;rsquo; Design - bzw. dessen, was wir davon übernommen haben (Adressdekodierung, ACIA, VIA) - genug herumgespielt hatten, galt es, &amp;ldquo;unser&amp;rdquo; Ding draus zu machen. Der erste Schritt war ein Sprung ins kalte Wasser in die uns bislang noch unbekannte Welt der Programmierbaren Logik. Dazu haben wir zunächst die Adressdekodierung bestehend aus 74ls138/74ls154 sowie etwas glue Logic in VHDL implementiert und auf ein GAL22V10D gebrannt.</description><content>&lt;p>Sinn der Sache ist ja nicht, etwas 1:1 nachzubauen, sondern ein möglichst eigenes Design. Nachdem wir mit Chris&amp;rsquo; Design - bzw. dessen, was wir davon übernommen haben (Adressdekodierung, ACIA, VIA) - genug herumgespielt hatten, galt es, &amp;ldquo;unser&amp;rdquo; Ding draus zu machen. Der erste Schritt war ein Sprung ins kalte Wasser in die uns bislang noch unbekannte Welt der Programmierbaren Logik. Dazu haben wir zunächst die Adressdekodierung bestehend aus 74ls138/74ls154 sowie etwas glue Logic in VHDL implementiert und auf ein GAL22V10D gebrannt. Somit haben wir 3 TTL-ICs durch einen GAL ersetzt und wieder Platz auf dem Steckbrett geschaffen. Und das Beste: Änderungen an der Dekodierungslogik laufen ab sofort minimalinvasiv.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Die erste Erweiterung ist ein /CS-Signal für den 2. 62256-Chip, der sich seinen Adressbereich mit 4k IO-Bereich und 8K ROM teilen darf und uns immerhin noch 20k nutzbares RAM beschert. Anfängliche Pläne, das unter dem ROM und IO liegende RAM nach Vorbild des C64 nutzbar zu machen stellen wir erstmal zurück. Zu viel Aufwand für lumpige 12k.&lt;/p>
&lt;p>Inzwischen gibt es auch eine rs232-Schnittstelle auf Basis einer 65x51 ACIA. Der vorliegende Chip kann mit max. 2MHz getaktet werden, daher ist der diskret aufgebaute 3MHz-Oszillator wieder arbeitslos. An seiner Stelle betaktet ein 2MHz-TTL-Oszillator unseren Rechner.&lt;/p>
&lt;p>Diese Begrenzung auf 2MHz gefällt uns nicht, eigentlich wollten wir den Rechner später so hoch wie möglich takten, auf jeden Fall mit 4MHz. Modernere CPUs sowie VIAs von WDC, die bis zu 14MHz Taktfrequenz vertragen, sind so gut wie geordert. Einzig die ACIA soll komplett durch einen moderneren Chip ersetzt werden, da sie uns nicht nur auf 2MHz, sondern auch auf 19200 baud begrenzt. Ein bisschen zu vintage, darum soll als nächtes die ACIA einem zeitgemäßeren Chip weichen.&lt;/p></content></item><item><title>Doppelt hält besser</title><link>https://beta.steckschwein.de/post/doppelt-haelt-besser/</link><pubDate>Sat, 22 Feb 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/doppelt-haelt-besser/</guid><description>Damit sich ein &amp;ldquo;Steckschwein&amp;rdquo; nicht so einsam fühlt, haben wir das ganze nochmal geklont. Jetzt hat jeder sein eigenes Steckschwein und kann daran rumschrauben oder besser gesagt rumstecken.
Da wir das Tooling &amp;ldquo;leichtgewichtig&amp;rdquo; halten wollen, gabs auch gleich ein kleines Problem zu lösen. Die Dekoder-Logik für den GAL wurde bisher in VHDL definiert und mit dem Hersteller-Produkt http://www.latticesemi.com/ispleverclassic ein entsprechendes JEDEC-File erzeugt. Das war uns dann doch viel zu unhandlich und wir haben uns nach Alternativen umgetan.</description><content>&lt;p>Damit sich ein &amp;ldquo;Steckschwein&amp;rdquo; nicht so einsam fühlt, haben wir das ganze nochmal geklont. Jetzt hat jeder sein eigenes Steckschwein und kann daran rumschrauben oder besser gesagt rumstecken.&lt;/p>
&lt;p>Da wir das Tooling &amp;ldquo;leichtgewichtig&amp;rdquo; halten wollen, gabs auch gleich ein kleines Problem zu lösen. Die Dekoder-Logik für den GAL wurde bisher in VHDL definiert und mit dem Hersteller-Produkt &lt;a href="http://www.latticesemi.com/ispleverclassic">http://www.latticesemi.com/ispleverclassic&lt;/a> ein entsprechendes JEDEC-File erzeugt. Das war uns dann doch viel zu unhandlich und wir haben uns nach Alternativen umgetan. Die Wahl fiel auf &lt;a href="https://github.com/daveho/GALasm">https://github.com/daveho/GALasm&lt;/a>, ein kleines aber feines Tool mit dem aus einigen booleschen Ausdrücken für die Dekoder-Logik genauso gut ein JEDEC-File erzeugt werden kann.&lt;/p>
&lt;pre tabindex="0">&lt;code>GAL22V10    ; first line : used GAL 8Bit Dekoder   
; second line: any text (max. 8 char.)
; PIN assignment
; G1       ; A15 of 6502 (Pin 25)
A2       ; A14 of 6502 (Pin 24)
A1       ; A13 of 6502 (Pin 23)
A0       ; A12 of 6502 (Pin 22)
B0       ; A08 of 6502 (Pin 20)
B1       ; A09 of 6502 (Pin 19)
B2       ; A10 of 6502 (Pin 18)
B3       ; A11 of 6502 (Pin 17)
RW       ; RW of 6502 (Pin 34)
PHI2     ; PHI2 of 6502 (Pin 39)
NC
GND
NC
CSROM    ;CS signal for ROM at $e000-$ffff
OE
WE       ;with PHI2 synchronized WE
CSHIRAM  ;CS for ram between  $8000-$cfff
CSACIA   ;6551 ACIA   at $d000
CSVIA    ;6522 VIA    at $d100
ELCD     ;LCD-Display at $d200
VDPCSR   ;Read VDP at $d400
VDPCSW   ;Write VDP at $d400
CSUART   ;CS for UART at $d300
VCC
;
;  boolean expressions
;
OE       = /RW  ; - output enable (active low, read from adress)
/WE      = /RW * PHI2     ; - write enable, combined with PHI2 (Pin 39) for synchronisation
/CSHIRAM = G1*/A2         ; $8000-$cfff + G1\*/A1\*/A0
/CSROM   = G1*A2*A1*A0   ; $e000-$ffff + G1\*A2\*A1\*/A0
/CSACIA  = G1 * A2*/A1*A0 * /B3*/B2*/B1*/B0  ; $d000
/CSVIA   = G1 * A2*/A1*A0 * /B3*/B2*/B1*B0   ; $d100
ELCD     = PHI2 * G1 * A2*/A1*A0 * /B3*/B2*B1*/B0  ; $d200 - LCD-Display at $d200
/CSUART  = G1 * A2*/A1*A0* /B3*/B2*B1*B0           ; $d300 - UART
&lt;/code>&lt;/pre>&lt;p>Mehr ist&amp;rsquo;s dann auch nicht, ganz oben der Typ des GAL&amp;rsquo;s in dem Fall ein 10-er, d.h. 10-Input, 10-Output-Pins. Darunter das PIN-Assignment, einfach in aufsteigender Reihenfolge deklarieren, also Pin1 - G1, Pin2 A2 usw.. bis VCC Pin 24. Dann noch die Boolschen-Ausdrücke, wobei * ein AND darstellt und + ein logisches OR. Negation mit /. Compiler anwerfen mittels.&lt;/p>
&lt;p>Jetzt noch das ganze auf den GAL brutzeln, am besten mit dem Universal programmer TL866C und schon läuft&amp;rsquo;s.&lt;/p></content></item></channel></rss>