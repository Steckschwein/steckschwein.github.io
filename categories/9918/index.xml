<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>9918 on</title><link>https://beta.steckschwein.de/categories/9918/</link><description>Recent content in 9918 on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 22 Oct 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://beta.steckschwein.de/categories/9918/index.xml" rel="self" type="application/rss+xml"/><item><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface</title><link>https://beta.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</link><pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</guid><description>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</description><content>&lt;p>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.&lt;/p>
&lt;p>as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings&lt;/p>
&lt;ol>
&lt;li>the first 2 bytes send to vdp during a write are always register writes which require a short delay of at least 2µs in between each byte&lt;/li>
&lt;li>the write of the 3rd byte (after the 2nd) requires a delay of 8µs. any further &amp;ldquo;single byte transfer&amp;rdquo; - during a vram write - also requires the 8µs delay. the same is true if we want to initiate a register write direclty after a vram write.&lt;/li>
&lt;li>the 3rd and n-th byte write to port #3 (index register port) during a bulk register write requires only the 2µs between each byte&lt;/li>
&lt;/ol>
&lt;p>With this in mind, we can optimize our library a little bit by using different &amp;ldquo;nop slides&amp;rdquo; for address setup and vram writes.&lt;/p>
&lt;p>We enhance our vdp.inc and built two macros which provide the different delay we need.&lt;/p>
&lt;p>.macro vdp_wait_s
jsr vdp_nopslide_2m ; 2m for 2µs wait
&amp;hellip;&lt;/p>
&lt;p>.macro vdp_wait_l
jsr vdp_nopslide_8m ; 8m for 8µs wait
&amp;hellip;&lt;/p>
&lt;p>steckSchwein is running at 8Mhz, so we also defined some equations and used ca65 macros to build our nop slides.&lt;/p>
&lt;p>.define CLOCK_SPEED_MHZ 8&lt;/p>
&lt;p>; long delay with 6µ+2µs (below)
MAX_NOPS_8M = (6 * 1000 / (1000 / CLOCK_SPEED_MHZ)) / 2
; 8Mhz, 125ns per cycle, wait 6µs = 6000ns
; = 6000ns / 125ns = 48cl / 2 =&amp;gt; 24 NOP&lt;/p>
&lt;p>; short delay with 2µs wait
MAX_NOPS_2M = (2 * 1000 / (1000 / CLOCK_SPEED_MHZ) -12) / 2
; -12 =&amp;gt; jsr/rts = 2 * 6cl = 12cl must be subtract&lt;/p>
&lt;p>.macro m_vdp_nopslide
vdp_nopslide_8m:
; long delay with 6+2 2µs wait
.repeat MAX_NOPS_8M
nop
.endrepeat
vdp_nopslide_2m:
.repeat MAX_NOPS_2M
nop
.endrepeat
rts
.endmacro&lt;/p>
&lt;p>Another interesting thing would be, &amp;ldquo;how does the /WAIT&amp;rdquo; behave in this situation? the assumption here is, that the /WAIT will behave in the way as specified. so /WAIT will be go low at least after 130ns from CSW. so to handover the /RDY handling to the vdp via the /WAIT pin, we have to apply only 1 wait state from our WS-Gen. after one wait state, we can release the /RDY low from our WS so that the vdp /WAIT can drive /RDY as needed.&lt;/p>
&lt;p>Back home, Thomas did the test and changed the waitstate generator firmware for the GAL16V8.&lt;/p>
&lt;p>The equation was&lt;/p>
&lt;p>W2 = ROM * UART * SND * /VDP
W1 = W2
+ /ROM * UART * VDP&lt;/p>
&lt;p>and was changed to&lt;/p>
&lt;p>W2 = /SND
W1 = W2
+ /ROM ; /ROM wait state if ROM is cs
+ /VDP ; /VDP wait state if VDP is cs&lt;/p>
&lt;p>So finally, we only need one wait state from the waitstate generator to access the VDP. If the VDP requires more time - surely - during a video memory access it will drive /WAIT to low as long as needed. So after the explcit 1WS from our wait state generator we now hand over the /RDY control to the VDP. How our /RDY and /WAIT really work together is subject to one of our next sessions where we&amp;rsquo;re going to measure the things with a logic analyzer and oscilloscope. Nevertheless, it works in this way and it works exaclty as specified within the datasheet.&lt;/p></content></item><item><title>V9958 - Es ist vollbracht</title><link>https://beta.steckschwein.de/post/v9958-es-ist-vollbracht/</link><pubDate>Sat, 17 Mar 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/v9958-es-ist-vollbracht/</guid><description>Da ist sie nun, die neuen Videoplatine. Nach einigen Umwegen hat der Packen Boards uns erreicht (die erste Lieferung ist versehentlich in Spanien gelandet, während wir die Platinen des spanischen Bastlers erhalten haben. Inzwischen hat jeder Ersatz erhalten).
Wir haben ja bekanntlich unsere Vorgehensweise geändert, indem wir schneller Platinen anfertigen lassen. Aber zu unserer großen Freude funktionierte die erste Platine nach Bestückung auf Anhieb. Selbstverständlich haben sich aber auch ein paar Patzer eingeschlichen.</description><content>&lt;p>Da ist sie nun, die neuen Videoplatine. Nach einigen Umwegen hat der Packen Boards uns erreicht (die erste Lieferung ist versehentlich in Spanien gelandet, während wir die Platinen des spanischen Bastlers erhalten haben. Inzwischen hat jeder Ersatz erhalten).&lt;/p>
&lt;p>Wir haben ja bekanntlich &lt;a href="http://steckschwein.de/2018/03/01/v9958-vom-steckbrett-zum-prototypen/">unsere Vorgehensweise geändert&lt;/a>, indem wir schneller Platinen anfertigen lassen. Aber zu unserer großen Freude funktionierte die erste Platine nach Bestückung auf Anhieb. Selbstverständlich haben sich aber auch ein paar Patzer eingeschlichen.&lt;/p>
&lt;p>&lt;img src="images/finished_board.jpg" alt="finished_board.jpg"> Die bis auf die Chinch-Buchsen fertig aufgebaute Platine&lt;/p>
&lt;p>Zunächst gabs wohl eine Verwechslung bei den Footprints für die Chinch-Buchsen. Unsere vorhandenen Buchsen passen also nicht, nirgends lassen sich passende Buchsen auftreiben. Wieso hat KiCad Footprints, die zu keinen Komponenten passen? Was nicht passt, wird passend gemacht, also müssen die Buchsen wohl etwas bearbeitet werden.&lt;/p>
&lt;p>&lt;img src="images/cinch_fix-e1520965306532.jpg" alt="cinch_fix.jpg"> Passend gemachte Buchse. Der vordere Pin wurde abgeknipst, und der mittlere Pin etwas nach vorne gebogen.&lt;/p>
&lt;p>Nach erfolgreichem Test hat sich dann ein weiteres Problem offenbart.&lt;/p>
&lt;p>&lt;img src="images/photo_2018-03-17_13-58-35.jpg" alt="photo_2018-03-17_13-58-35"> Irgendwie wirken die Farben vertauscht&lt;/p>
&lt;p>Dadurch, dass der V9958 seine Video-Ausgabepins für die Farbkanäle nicht in der Reihenfolge RGB, sondern GRB angeordnet hat, sind im Schaltplan Rot und Blau verwechselt worden. Glücklicherweise gehen die Farbsignale über Koppelkondensatoren an den CXA2075M, sodass der Fix erstmal darin besteht, C9 und C12 über Kreuz einzulöten.&lt;/p>
&lt;p>&lt;img src="images/fixed_board.jpg" alt="fixed_board"> Das Board mit Cinch-Buchsen und Farb-Fix. Fehlt noch die S-Video-Buchse&lt;/p>
&lt;p>Oh, und es soll nicht unerwähnt bleiben, dass wir uns erstmals getraut haben, mit dem CXA2075M einen SMD-Chip zu verbauen.&lt;/p></content></item><item><title>Es wird wieder gesteckt</title><link>https://beta.steckschwein.de/post/es-wird-wieder-gesteckt/</link><pubDate>Sat, 09 Dec 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/es-wird-wieder-gesteckt/</guid><description>Wir haben uns schon länger ein Upgrade des Videochips des Steckschweins vorgenommen. Der TMS9929 ist ein netter Chip, aber an einem 8MHz-65c02, der dazu noch so coole Hardware-Features hat, fühlt er sich ein bisschen wie die Achillesferse an.
Zum Glück war beim TMS9929 nicht Schluss, denn dieser hat im Laufe der Zeit diverse Nachfolger bekommen, welche von Yamaha hergestellt wurden und in diversen Weiterentwicklungen des MSX-Standards Verwendung fanden.
Der direkte Nachfolger der TMS99xx-Reihe ist der V9938.</description><content>&lt;p>Wir haben uns schon länger ein Upgrade des Videochips des Steckschweins vorgenommen. Der TMS9929 ist ein netter Chip, aber an einem 8MHz-65c02, der dazu noch so coole Hardware-Features hat, fühlt er sich ein bisschen wie die Achillesferse an.&lt;/p>
&lt;p>Zum Glück war beim TMS9929 nicht Schluss, denn dieser hat im Laufe der Zeit diverse Nachfolger bekommen, welche von Yamaha hergestellt wurden und in diversen Weiterentwicklungen des MSX-Standards Verwendung fanden.&lt;/p>
&lt;p>Der direkte Nachfolger der TMS99xx-Reihe ist der &lt;a href="https://en.wikipedia.org/wiki/Yamaha_V9938">V9938&lt;/a>. Dieser kam 1984 raus, also ganze 7 Jahre nachdem der TMS9918/9929 erschienen ist, und hat dementsprechend auch einiges mehr drauf, z.B.:&lt;/p>
&lt;ul>
&lt;li>ein 80x24 Zeichen-Textmodus&lt;/li>
&lt;li>maximale Auflösung von 512 × 212 (16 Farben von 512)&lt;/li>
&lt;li>32 Sprites, davon max. 8 auf einer Rasterzeile&lt;/li>
&lt;li>Hardwarebeschleunigtes Füllen, Linien ziehen, etc.&lt;/li>
&lt;li>Vertikales Scrollregister&lt;/li>
&lt;/ul>
&lt;p>Der Nachfolger des V9938 wiederum ist der &lt;a href="https://en.wikipedia.org/wiki/Yamaha_V9958">V9958&lt;/a> von 1988. Dieser hat gegenüber dem Vorgänger nur einige kleine Verbesserungen erhalten, und zwar unter anderem:&lt;/p>
&lt;ul>
&lt;li>Horizontales Scrollregister&lt;/li>
&lt;li>Hardwarebeschleunigtes Füllen, Linien ziehen, etc. auch in nicht-bitmap-Modi&lt;/li>
&lt;/ul>
&lt;p>Beide Chips können bis zu 192k DRAM adressieren, und zwar max. 128k Video-RAM + 64k Extended RAM. Es werden DRAMs in den Formaten 16Kx1b, 16Kx4b, 64Kx1b und 64Kx4b unterstützt.&lt;/p>
&lt;p>&lt;img src="images/img_3129-e1512817894665.jpg" alt="img_3129.jpg">&lt;/p>
&lt;p>Unser Testaufbau &amp;ldquo;begnügt&amp;rdquo; sich mit 2x 64Kx4b und damit insgesamt 64Kb Video RAM (der TMS9929 kann nur max. 16K). Verglichen mit dem TMS9929 funktioniert das DRAM-Interface des V9958 selbst auf dem Steckbrett so stabil, dass wir auf irgendwelche SRAM-basierten Lösungen verzichten können. Auch der weitere Aufbau ist eher übersichtlich. Da der V9958 direkt RGB liefert, ist keine aufwendige Aufbereitung des Videosignals nötig. Als Ausgangsstufe wird ein Sony CXA2075M eingesetzt, der nebenher auch S-Video und Composite erzeugt. Damit dürfte sich künftig die Zahl der Steckschwein-geeigneten Fernseher/Monitore drastisch erhöhen.&lt;/p>
&lt;p>Jetzt bleiben noch einige Detailfragen des Businterface zu klären. Wie &lt;a href="http://lc64.blogspot.de/2015/04/v9938-with-rgb-output.html">MrFossi1&lt;/a> schon festgestellt hat, lassen sich Datentransfers ins Videoram nicht mehr in hoher Geschwindigkeit durchführen, während der Videochip im Blank ist oder das Display deaktiviert. Beim TMS9929 war das möglich.&lt;/p>
&lt;p>Der V9958 hingegen verfügt allerdings über einen ominösen /WAIT-Pin, dessen Funktion allerdings erst per Software aktiviert werden muss. Das Datenblatt erwähnt die Wait-Funktion nur kurz als Möglichkeit, Zugriffe aufs VRAM zu beschleunigen, schweigt sich dann aber aus. Hier gilt es zu forschen.&lt;/p></content></item><item><title>TMS9929 - Wir wollen was sehen...</title><link>https://beta.steckschwein.de/post/tms9929-wir-wollen-was-sehen/</link><pubDate>Sun, 02 Mar 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/tms9929-wir-wollen-was-sehen/</guid><description>&amp;hellip; und zwar auf einem Bildschirm! Aber wie stellt man sowas an?! Nun, wir schauen uns um, was Ende der 70-er bzw. Anfang der 80-er Jahre Stand der Technik war und was sich mit überschaubarem Aufwand an eine 6502 CPU &amp;ldquo;anschließen&amp;rdquo; lässt. Die Auswahl ist leider überschaubar, denn es sollte irgendwas in DIP maximal noch SDIP sein und dazu noch irgendwie lieferbar - &amp;ldquo;new old stock&amp;rdquo;.
Wir fanden die TMS9918/28/29-Serie und einige Nachfolger wie den TMS9938/58.</description><content>&lt;p>&amp;hellip; und zwar auf einem Bildschirm! Aber wie stellt man sowas an?! Nun, wir schauen uns um, was Ende der 70-er bzw. Anfang der 80-er Jahre Stand der Technik war und was sich mit überschaubarem Aufwand an eine 6502 CPU &amp;ldquo;anschließen&amp;rdquo; lässt. Die Auswahl ist leider überschaubar, denn es sollte irgendwas in DIP maximal noch SDIP sein und dazu noch irgendwie lieferbar - &amp;ldquo;new old stock&amp;rdquo;.&lt;/p>
&lt;p>Wir fanden die TMS9918/28/29-Serie und einige Nachfolger wie den TMS9938/58. Für&amp;rsquo;s erste sollte es ein TMS9929 sein, weil der tatächlich noch zu beschaffen ist und dazu auch noch im DIP-Gehäuse daherkommt. Der -29 ist für den europäischen Markt gebaut worden, um diese an PAL-Fernsehgeräte anschließen zu können. Hier eine kleiner Auszug  der technischen Fähigkeiten, die im &lt;a href="http://msx.hansotten.com/uploads/ffiles/1980%20TMS9918%20Advertisement.jpg">Jahre 1980&lt;/a> wahrscheinlich gigantisch wirkten.&lt;/p>
&lt;p>• 256x192 resolution on TV screen • 15 unique colors plus transparent • General 8-bit bidirectional interface to Central Processor Unit (CPU) • Direct wiring to 4K, 8K, or 16K dynamic RAM memories • Automatic and transparent refresh of dynamic RAMs • Unique planar representation for 3D simulation • Standard 40-pin package • Color difference outputs allow RGB drive - TMS992SA/9929A&lt;/p>
&lt;p>Ok, schauen wir uns mal das &lt;a href="http://www.bitsavers.org/components/ti/TMS9900/TMS9918A_TMS9928A_TMS9929A_Video_Display_Processors_Data_Manual_Nov82.pdf">Datenblatt&lt;/a> an. Aha, oha, soso&amp;hellip;. sieht doch gar nicht so schwierig aus. Jetzt brauchen wir noch passende DRAM&amp;rsquo;s da wird&amp;rsquo;s schon schwieriger. Zum Glück hat der Dommas sowas in seiner Bastelkiste, gleich nen ganzen Sack diverser Typen. Glück gehabt&amp;hellip;. Im Datenblatt steht TMS4116, in der Bastelkiste finde ich NEC416 die sind exakt baugleich von daher pinkompatibel. Die DRAMs an den VDP zu kleben ist im Datenblatt beschrieben, ich lese mir das ganze bestimmt 50 Mal durch, hab nen Knoten im Kopf und verstehe nicht warum man das damals so kompliziert machen musste&amp;hellip; Dazu kommt, dass ich Beschaltung und Funktionsweise von DRAMs das letzte mal vor 14 Jahren gehört habe. Also lese ich mich auch hier nochmal ein.&lt;/p>
&lt;p>Für den TMS9929 brauchen wir 8 16K DRAMs, die 1Bit organisiert sind, ebend genau der 4116 Typ oder baugleich. Ich besorge mir also noch ein paar Steckbretterund jede Menge Steckbrettkabel, um das Gestrüpp herzustellen.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Fertig, ich freu mich, seh zwar noch nix bin aber zuversichtlich&amp;hellip;&lt;/p></content></item></channel></rss>