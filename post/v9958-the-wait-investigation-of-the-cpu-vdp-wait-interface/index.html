<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.ico><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface - Steckschwein</title><meta name=description content="&mldr; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings"><meta name=generator content="Hugo 0.101.0"><link rel=stylesheet href=https://steckschwein.github.io/css/main.css><meta property="og:title" content="V9958 - &#34;The WAIT&#34; - investigation of the CPU/VDP /WAIT interface"><meta property="og:description" content="&mldr; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings"><meta property="og:type" content="article"><meta property="og:url" content="https://steckschwein.github.io/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-10-22T00:00:00+00:00"><meta property="article:modified_time" content="2018-10-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="V9958 - &#34;The WAIT&#34; - investigation of the CPU/VDP /WAIT interface"><meta name=twitter:description content="&mldr; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings"><meta itemprop=name content="V9958 - &#34;The WAIT&#34; - investigation of the CPU/VDP /WAIT interface"><meta itemprop=description content="&mldr; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings"><meta itemprop=datePublished content="2018-10-22T00:00:00+00:00"><meta itemprop=dateModified content="2018-10-22T00:00:00+00:00"><meta itemprop=wordCount content="606"><meta itemprop=keywords content><meta itemprop=name content="V9958 - &#34;The WAIT&#34; - investigation of the CPU/VDP /WAIT interface"><meta itemprop=description content="&mldr; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings"><meta itemprop=datePublished content="2018-10-22T00:00:00+00:00"><meta itemprop=dateModified content="2018-10-22T00:00:00+00:00"><meta itemprop=wordCount content="606"><meta itemprop=keywords content></head><body class="flex relative h-full min-h-screen"><aside class="will-change-transform transform transition-transform -translate-x-full absolute top-0 left-0 md:relative md:translate-x-0 w-3/4 md:w-60 h-full min-h-screen p-3 bg-slate-50 dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 flex flex-col gap-2.5 z-20 sidebar"><p class="font-bold mb-5 flex items-center gap-2"><button aria-label="Close sidebar" class="md:hidden menu-trigger-close p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-6 w-6" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
<a href=https://steckschwein.github.io class=px-2><span>Steckschwein</span></a>
<button aria-label="Toggle dark mode" class="dark-mode-toggle p-2 rounded border dark:border-slate-700 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-4 w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="4"/><path d="M3 12h1m8-9v1m8 8h1m-9 8v1M5.6 5.6l.7.7m12.1-.7-.7.7m0 11.4.7.7M6.3 17.7l-.7.7"/></svg></button></p><ul class="list-none flex flex-col gap-1"><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/home/><span>The Project</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/hardware/><span>Hardware</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/software/><span>Software</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/impressum/><span>Impressum</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/articles/><span>Articles</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/post/><span>Posts</span></a></li></ul><div class=flex-1></div><ul class="list-none flex flex-wrap justify-center gap-1 pt-2 border-t border-slate-200 dark:border-slate-600"></ul></aside><div class="fixed bg-slate-700 bg-opacity-5 transition duration-200 ease-in-out inset-0 z-10 pointer-events-auto md:hidden left-0 top-0 w-full h-full hidden menu-overlay"></div><button aria-label="Toggle Sidebar" class="md:hidden absolute top-3 left-3 z-10 menu-trigger p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-100"><svg class="h-6 w-6" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="18" x2="16" y2="18"/></svg></button><div class=flex-1><main class="h-screen overflow-y-auto"><div class="px-6 py-20 w-full lg:w-[580px] mx-auto prose dark:prose-invert h-fit prose-img:mx-auto"><h1>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface</h1><p class="text-sm text-slate-500 !mb-8">October 22, 2018</p><p>&mldr; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.</p><p>as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</p><ol><li>the first 2 bytes send to vdp during a write are always register writes which require a short delay of at least 2µs in between each byte</li><li>the write of the 3rd byte (after the 2nd) requires a delay of 8µs. any further &ldquo;single byte transfer&rdquo; - during a vram write - also requires the 8µs delay. the same is true if we want to initiate a register write direclty after a vram write.</li><li>the 3rd and n-th byte write to port #3 (index register port) during a bulk register write requires only the 2µs between each byte</li></ol><p>With this in mind, we can optimize our library a little bit by using different &ldquo;nop slides&rdquo; for address setup and vram writes.</p><p>We enhance our vdp.inc and built two macros which provide the different delay we need.</p><p>.macro vdp_wait_s
jsr vdp_nopslide_2m ; 2m for 2µs wait
&mldr;</p><p>.macro vdp_wait_l
jsr vdp_nopslide_8m ; 8m for 8µs wait
&mldr;</p><p>steckSchwein is running at 8Mhz, so we also defined some equations and used ca65 macros to build our nop slides.</p><p>.define CLOCK_SPEED_MHZ 8</p><p>; long delay with 6µ+2µs (below)
MAX_NOPS_8M = (6 * 1000 / (1000 / CLOCK_SPEED_MHZ)) / 2
; 8Mhz, 125ns per cycle, wait 6µs = 6000ns
; = 6000ns / 125ns = 48cl / 2 => 24 NOP</p><p>; short delay with 2µs wait
MAX_NOPS_2M = (2 * 1000 / (1000 / CLOCK_SPEED_MHZ) -12) / 2
; -12 => jsr/rts = 2 * 6cl = 12cl must be subtract</p><p>.macro m_vdp_nopslide
vdp_nopslide_8m:
; long delay with 6+2 2µs wait
.repeat MAX_NOPS_8M
nop
.endrepeat
vdp_nopslide_2m:
.repeat MAX_NOPS_2M
nop
.endrepeat
rts
.endmacro</p><p>Another interesting thing would be, &ldquo;how does the /WAIT&rdquo; behave in this situation? the assumption here is, that the /WAIT will behave in the way as specified. so /WAIT will be go low at least after 130ns from CSW. so to handover the /RDY handling to the vdp via the /WAIT pin, we have to apply only 1 wait state from our WS-Gen. after one wait state, we can release the /RDY low from our WS so that the vdp /WAIT can drive /RDY as needed.</p><p>Back home, Thomas did the test and changed the waitstate generator firmware for the GAL16V8.</p><p>The equation was</p><p>W2 = ROM * UART * SND * /VDP
W1 = W2
+ /ROM * UART * VDP</p><p>and was changed to</p><p>W2 = /SND
W1 = W2
+ /ROM ; /ROM wait state if ROM is cs
+ /VDP ; /VDP wait state if VDP is cs</p><p>So finally, we only need one wait state from the waitstate generator to access the VDP. If the VDP requires more time - surely - during a video memory access it will drive /WAIT to low as long as needed. So after the explcit 1WS from our wait state generator we now hand over the /RDY control to the VDP. How our /RDY and /WAIT really work together is subject to one of our next sessions where we&rsquo;re going to measure the things with a logic analyzer and oscilloscope. Nevertheless, it works in this way and it works exaclty as specified within the datasheet.</p></div></main></div><script type=text/javascript src=/main.js defer></script></body></html>