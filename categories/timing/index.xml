<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>timing on</title><link>https://beta.steckschwein.de/categories/timing/</link><description>Recent content in timing on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 22 Oct 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://beta.steckschwein.de/categories/timing/index.xml" rel="self" type="application/rss+xml"/><item><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface</title><link>https://beta.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</link><pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</guid><description>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</description><content>&lt;p>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.&lt;/p>
&lt;p>as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings&lt;/p>
&lt;ol>
&lt;li>the first 2 bytes send to vdp during a write are always register writes which require a short delay of at least 2µs in between each byte&lt;/li>
&lt;li>the write of the 3rd byte (after the 2nd) requires a delay of 8µs. any further &amp;ldquo;single byte transfer&amp;rdquo; - during a vram write - also requires the 8µs delay. the same is true if we want to initiate a register write direclty after a vram write.&lt;/li>
&lt;li>the 3rd and n-th byte write to port #3 (index register port) during a bulk register write requires only the 2µs between each byte&lt;/li>
&lt;/ol>
&lt;p>With this in mind, we can optimize our library a little bit by using different &amp;ldquo;nop slides&amp;rdquo; for address setup and vram writes.&lt;/p>
&lt;p>We enhance our vdp.inc and built two macros which provide the different delay we need.&lt;/p>
&lt;p>.macro vdp_wait_s
jsr vdp_nopslide_2m ; 2m for 2µs wait
&amp;hellip;&lt;/p>
&lt;p>.macro vdp_wait_l
jsr vdp_nopslide_8m ; 8m for 8µs wait
&amp;hellip;&lt;/p>
&lt;p>steckSchwein is running at 8Mhz, so we also defined some equations and used ca65 macros to build our nop slides.&lt;/p>
&lt;p>.define CLOCK_SPEED_MHZ 8&lt;/p>
&lt;p>; long delay with 6µ+2µs (below)
MAX_NOPS_8M = (6 * 1000 / (1000 / CLOCK_SPEED_MHZ)) / 2
; 8Mhz, 125ns per cycle, wait 6µs = 6000ns
; = 6000ns / 125ns = 48cl / 2 =&amp;gt; 24 NOP&lt;/p>
&lt;p>; short delay with 2µs wait
MAX_NOPS_2M = (2 * 1000 / (1000 / CLOCK_SPEED_MHZ) -12) / 2
; -12 =&amp;gt; jsr/rts = 2 * 6cl = 12cl must be subtract&lt;/p>
&lt;p>.macro m_vdp_nopslide
vdp_nopslide_8m:
; long delay with 6+2 2µs wait
.repeat MAX_NOPS_8M
nop
.endrepeat
vdp_nopslide_2m:
.repeat MAX_NOPS_2M
nop
.endrepeat
rts
.endmacro&lt;/p>
&lt;p>Another interesting thing would be, &amp;ldquo;how does the /WAIT&amp;rdquo; behave in this situation? the assumption here is, that the /WAIT will behave in the way as specified. so /WAIT will be go low at least after 130ns from CSW. so to handover the /RDY handling to the vdp via the /WAIT pin, we have to apply only 1 wait state from our WS-Gen. after one wait state, we can release the /RDY low from our WS so that the vdp /WAIT can drive /RDY as needed.&lt;/p>
&lt;p>Back home, Thomas did the test and changed the waitstate generator firmware for the GAL16V8.&lt;/p>
&lt;p>The equation was&lt;/p>
&lt;p>W2 = ROM * UART * SND * /VDP
W1 = W2
+ /ROM * UART * VDP&lt;/p>
&lt;p>and was changed to&lt;/p>
&lt;p>W2 = /SND
W1 = W2
+ /ROM ; /ROM wait state if ROM is cs
+ /VDP ; /VDP wait state if VDP is cs&lt;/p>
&lt;p>So finally, we only need one wait state from the waitstate generator to access the VDP. If the VDP requires more time - surely - during a video memory access it will drive /WAIT to low as long as needed. So after the explcit 1WS from our wait state generator we now hand over the /RDY control to the VDP. How our /RDY and /WAIT really work together is subject to one of our next sessions where we&amp;rsquo;re going to measure the things with a logic analyzer and oscilloscope. Nevertheless, it works in this way and it works exaclty as specified within the datasheet.&lt;/p></content></item><item><title>Logikanalyse II [UPDATE]</title><link>https://beta.steckschwein.de/post/logikanalyse-ii/</link><pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/logikanalyse-ii/</guid><description>Inzwischen sind die 74F00 eingetroffen und der 74HCT00 durch einen ebensolchen ersetzt. Das Oszilloskopbild sieht gleich deutlich besser aus:
gelb: /WE, blau: A9
Der Schreibvorgang wird also jetzt zumindest abgeschlossen, bevor sich die Adresse auf dem Adressbus ändert. Das ist schonmal viel sauberer.
Nur leider hat es das Problem nicht gelöst, das Steckschwein läuft mit den &amp;ldquo;richtigen&amp;rdquo; RAMs immer noch instabil, was sich insbesondere bei BASIC-Programmen bemerkbar macht:
Wäre auch zu einfach gewesen.</description><content>&lt;p>Inzwischen sind die 74F00 eingetroffen und der 74HCT00 durch einen ebensolchen ersetzt. Das Oszilloskopbild sieht gleich deutlich besser aus:&lt;/p>
&lt;p>&lt;img src="images/tekway449_3.gif" alt=""> gelb: /WE, blau: A9&lt;/p>
&lt;p>Der Schreibvorgang wird also jetzt zumindest abgeschlossen, bevor sich die Adresse auf dem Adressbus ändert. Das ist schonmal viel sauberer.&lt;/p>
&lt;p>Nur leider hat es das Problem nicht gelöst, das Steckschwein läuft mit den &amp;ldquo;richtigen&amp;rdquo; RAMs immer noch instabil, was sich insbesondere bei BASIC-Programmen bemerkbar macht:&lt;/p>
&lt;p>&lt;img src="images/photo_2017-05-04_19-56-29.jpg" alt="photo_2017-05-04_19-56-29">&lt;/p>
&lt;p>Wäre auch zu einfach gewesen.&lt;/p>
&lt;p>&lt;strong>[UPDATE]&lt;/strong> Ein weiterer Test mit anderen 55ns-SRAMs, nämlich Bausteinen von BSI im TSOP28-Gehäuse auf DIP28-Adaptern, lief problemlos durch. Das BASIC-Programm, mit dem wir testen, lief 2 Tage problemlos durch. Dies ist insofern bemerkenswert, als dass das Steckschwein mit diesen Bausteinen vorher überhaupt nicht lief. Also doch ein Erfolg. Warum die 55ns-Chips von Alliance Memory Probleme machen, müssen wir noch untersuchen.&lt;/p>
&lt;p>&lt;img src="images/photo_2017-05-06_19-57-10.jpg" alt=""> TSOP28-SRAMs auf DIP28 Adapter&lt;/p></content></item><item><title>Eine fanTASTische Reise</title><link>https://beta.steckschwein.de/post/eine-fantastische-reise/</link><pubDate>Mon, 15 Dec 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/eine-fantastische-reise/</guid><description>Von unserem Plan, einen AVR-µC als PS/2-Tastaturcontroller als SPI-Slave einzusetzen, haben wir ja schon in der Vergangenheit berichtet. Damals hieß es: &amp;ldquo;Bequemerweise gibt es zahlreiche fertige Lösungen, die z.B. am anderen Ende rs232 sprechen. Wir wollen aber nur wegen einer Tastatur keinen zweiten UART verbauen. Fehlt also nur eine kleine Anpassung auf SPI.&amp;rdquo;
Hiermit sollte das Schicksal seinen Lauf nehmen. Der kühne Griff in die Bastelkiste sollte einen ATtiny2313 zu Tage fördern, welcher der zugedachten Aufgabe durchaus gewachsen zu sein schien.</description><content>&lt;p>Von unserem Plan, einen AVR-µC als PS/2-Tastaturcontroller als SPI-Slave einzusetzen, haben wir ja schon &lt;a href="http://wordpress.steckschwein.de/wordpress/index.php/2014/07/11/tore-zur-welt/">in der Vergangenheit&lt;/a>  berichtet. Damals hieß es: &amp;ldquo;Bequemerweise gibt es zahlreiche fertige Lösungen, die z.B. am anderen Ende rs232 sprechen. Wir wollen aber nur wegen einer Tastatur keinen zweiten UART verbauen. Fehlt also nur eine kleine Anpassung auf SPI.&amp;rdquo;&lt;/p>
&lt;p>Hiermit sollte das Schicksal seinen Lauf nehmen. Der kühne Griff in die Bastelkiste sollte einen ATtiny2313 zu Tage fördern, welcher der zugedachten Aufgabe durchaus gewachsen zu sein schien.&lt;/p>
&lt;p>Als Ausgangsbasis für das Tastaturinterface sollte der Beispielcode aus &lt;a href="http://www.atmel.com/Images/doc1235.pdf">AVR Application Note 313&lt;/a> dienen, der die Scancodes der PS/2-Tastatur nach ASCII umsetzt und per rs232 ausgibt. Dies wäre also die Stelle für die &amp;ldquo;kleine Anpassung auf SPI&amp;rdquo;, leider aber hat der ATtiny2313 anders als ein Controller der ATmega-Reihe keine native SPI-Schnittstelle. Dafür gibt es dort das Universal Serial Interface (USI), mit dem sich auch eine SPI-Schnittstelle nachbilden lassen sollte. Lediglich das SPI-Slave-Select fehlt der USI und muss per Software nachgebaut werden.&lt;/p>
&lt;p>Der PS/2 Controller soll als SPI-Slave genau wie RTC und SD-Karte  angesprochen werden. Hierbei wollen wir den AVR sozusagen als Coprozessor betrachten, der nicht nur das Umsetzen der Scancodes nach ASCII nach einer zu definierenden Keymap übernehmen, sondern auch als Tastaturpuffer dienen soll, sodass das Steckschwein selbst sowas nicht braucht. Das Steckschwein soll bei bei Bedarf also direkt den Controller fragen bzw. warten bis dieser einen Tastendruck liefert.&lt;/p>
&lt;p>Dieser Ansatz brachte nun einige Probleme mit sich. Ein Programm auf dem Steckschwein, dass per SPI den Controller pollte, bekam meist nur Datenmüll zurück. Schrieb man den Puffer voll, und startete dann die Abfrage, kamen diese Daten zumeist korrekt auf dem Steckschwein an.&lt;/p>
&lt;p>Diese Fehlerbild legt nahe, dass das Verarbeiten des CLK-Signals der Tastatur via INT0-Interrupt irgendwie Einfluss auf das Timing der USI hat, zumal das Erhöhen des Taktes des AVR eine kleine Abmilderung bedeutete.&lt;/p>
&lt;p>Was nun folgen sollte war eine mehrwöchige Reihe von frustrierenden Debugging-Sessions, ohne jedoch dass es zu einem schlüssigen Ergebnis kam. Frustrierend insofern, als dass für eine solch trivial anmutende und wenig aufregende Aufgabenstellung max. 2 Tage angesetzt waren.&lt;/p>
&lt;p>Als einzige Erkenntnis blieb zumindest, dass das Erhöhen der Taktfrequenz scheinbar eine leichte Besserung zur Folge hatte. Nur kann der ATtiny &amp;ldquo;nur&amp;rdquo; bis max. 20MHz getaktet werden, und selbst eine leichte Übertaktung auf 22MHz brachte keine vollständige Lösung des Problems. Zudem der Nachgeschmack den der Gedanke auslöste, dass der Tastaturcontroller eines 4MHz Rechners für seine Aufgabe mehr als 5mal so hoch getaktet werden wollte wie der Hauptprozessor.&lt;/p>
&lt;p>Marko und ich verblieben, dass wir das Problem in der nächsten gemeinsamen Session mal geballt betrachten wollten. Ich verkroch mich frustriert im KiCad-Layouteditor.&lt;/p>
&lt;p>Aber: Mir läßt sowas keine Ruhe. Als allerletztes Aufbäumen vor der Kapitulation habe ich beschlossen, den ATtiny in die Bastelkiste zu verbannen, und stattdessen einen ATmega8 mit seinem nativen SPI-Interface auszuprobieren. (Spoiler: Im Post über die RTC sieht man schon den verbauten ATmega8) Schlussendlich schrumpfte so der SPI-Code auf eine Handvoll Zeilen und alle oben beschriebenen Probleme waren schlicht und ergreifend weg! Und das sogar bei einer Taktfrequenz weit unter 22MHz, nämlich genau 4MHz, die nun auch vom internen RC-Oszillator erzeugt werden.&lt;/p>
&lt;p>Was blieb, war etwas Fleißarbeit, um Modifier-Keys wie Ctrl und Alt zu unterstützen und das Tastaturmapping auf deutsches Layout anzupassen. Zusätzlich fängt die Firmware noch Tasten(-kombinationen) wie SysRq und Ctrl-Alt-Del ab, und steuert damit IO-Pins an, sodass man über die Tastatur Reset und NMI auslösen kann.&lt;/p>
&lt;p>Der ATmega8 mutet mit seinen 8k Flash-Speicher natürlich äußerst fett an, aber sicherlich lassen sich diese noch sinnvoll nutzen um etwa mehrere Tastaturmappings unterzubringen. Auch ein PS/2-Mausinterface wäre denkbar.&lt;/p>
&lt;p>Aber aktuell sind wir sehr glücklich, dass wir endlich einen Tastaturcontroller haben, der so funktioniert wie wir das gerne möchten.&lt;/p></content></item><item><title>Verfeinerungen am Design</title><link>https://beta.steckschwein.de/post/verfeinerungen-am-design/</link><pubDate>Tue, 24 Jun 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/verfeinerungen-am-design/</guid><description>So langsam geht es weiter mit der Steckschweinentwicklung.
Die Timingprobleme mit dem VDP bedürfen einer eingehenden Prüfung und Messung, um genau zu verstehen, wo was nicht passt. Unsere Ideen mit Puffern und/oder versetzten Taktsignalen, um den VDP früher &amp;ldquo;kommen&amp;rdquo; zu lassen stellen wir zurück, bis wir gesicherte Erkenntnisse haben. Ein Herumdoktern aufgrund von Vermutungen halten wir nicht für zielführend. Vorher ist es auch nicht sinnvoll, irgendwelche Platinen zu löten.
Stattdessen stecken wir ein wenig Hirnschmalz ins aktuelle Design.</description><content>&lt;p>So langsam geht es weiter mit der Steckschweinentwicklung.&lt;/p>
&lt;p>Die Timingprobleme mit dem VDP bedürfen einer eingehenden Prüfung und Messung, um genau zu verstehen, wo was nicht passt. Unsere Ideen mit Puffern und/oder versetzten Taktsignalen, um den VDP früher &amp;ldquo;kommen&amp;rdquo; zu lassen stellen wir zurück, bis wir gesicherte Erkenntnisse haben. Ein Herumdoktern aufgrund von Vermutungen halten wir nicht für zielführend. Vorher ist es auch nicht sinnvoll, irgendwelche Platinen zu löten.&lt;/p>
&lt;p>Stattdessen stecken wir ein wenig Hirnschmalz ins aktuelle Design. Die Anbindung des UART fällt negativ auf. Hier wurde der &lt;a href="http://www.6502.org/users/andre/icaphw/c64ser.html">Ansatz von Andre Fachat&lt;/a> quasi 1:1 kopiert, sodass der GAL die Signale /RD und /WR für den UART abhängig von PHI2 und der angelegten Adresse erzeugt, während PHI2 ausserdem an CS1 des UART anliegt. Das funktioniert, fügt sich aber nicht ganz in unser Design ein.&lt;/p>
&lt;p>Eigentlich sollte es möglich sein, im GAL ein einfaches /CS-Signal für den UART zu erzeugen. Die Aufsplittung von /WR nach /OE und /WE haben wir ja ohnehin schon gemacht, sodass wir diese einfach direkt an /RD und /WR des UART geben können. Dadurch, dass PHI2 und /OE, /WE durch tPROP des 7400 versetzt sind, sollte sich hier dann auch eine Timingfehlerquelle in Luft aufgelöst haben. Als angenehmer Nebeneffekt wird wieder ein Output Pin am GAL frei.&lt;/p>
&lt;p>Erste Tests haben gezeigt, dass nun auch unser &lt;a href="http://8bit-gefriemel.blogspot.de/2014_04_02_archive.html">&amp;ldquo;OK&amp;rdquo;-Problem&lt;/a>, hinter dem wir lange hinterhergesucht haben, nicht mehr auftritt, egal, ob wir das System wie von WDC empfohlen direkt mit dem Oszillator takten oder ob wir 6502-Oldschool den Taktausgang des Prozessors PHI2O benutzen.&lt;/p></content></item><item><title>Von Hummeln und Puffern</title><link>https://beta.steckschwein.de/post/von-hummeln-und-puffern/</link><pubDate>Mon, 02 Jun 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/von-hummeln-und-puffern/</guid><description>Nach dem VCFe ist erstmal nicht viel aktive Entwicklung passiert. Vielmehr haben wir die Erkenntnis, dass wir ein grundsätzliches Timing-Problem haben (danke nochmal an Udo Möller) ein klein wenig sacken lassen. Im Grunde genommen ist es so, wie es sich aus dem vorletzten Post schon herauslesen läßt. Der WDC 65c02 hat eine Data Hold Time von 10ns, während der TMS9929 30ns braucht, sein Zeug vom Bus zu holen. Die verwendeten 16550er UARTs auch.</description><content>&lt;p>Nach dem VCFe ist erstmal nicht viel aktive Entwicklung passiert. Vielmehr haben wir die Erkenntnis, dass wir ein grundsätzliches Timing-Problem haben (danke nochmal an Udo Möller) ein klein wenig sacken lassen. Im Grunde genommen ist es so, wie es sich aus dem vorletzten Post schon herauslesen läßt. Der WDC 65c02 hat eine Data Hold Time von 10ns, während der TMS9929 30ns braucht, sein Zeug vom Bus zu holen. Die verwendeten 16550er UARTs auch. Eine klassische Hold Time Violation also. Ein bisschen muss man sich da schon wundern, dass das Zeug überhaupt funktioniert und so erklärt sich auch der ein oder andere staunende Blick auf dem VCFe. &lt;a href="http://www.ist-schlau.de/">Simon&lt;/a> schlägt vor, das Projekt &amp;ldquo;Bumblebee&amp;rdquo; zu nennen, da Hummeln bekanntlich rein physikalisch gar nicht fliegen können, es aber dennoch tun, weil ihnen Physik total egal ist.&lt;/p>
&lt;p>Wir treffen 3 Entscheidungen:&lt;/p>
&lt;ol>
&lt;li>Wir halten am WDC-Prozessor fest. Die &amp;ldquo;alten&amp;rdquo; Rockwells haben 30ns Hold Time, damit treten die Timingprobleme mit dem TMS9929 kaum auf und das sogar bei 2MHz. Hingegen sind die WDC-Chips weiterhin neu verfügbar, und daran möchten wir uns orientieren.&lt;/li>
&lt;li>Wir brauchen Platinen. Steckbretter bringen bekanntlich ihre ganz eigenen Fehlerquellen mit sich, und Fehlersuche in dem Gestrüpp gestaltet sich zunehmend schwieriger. Zudem ist der TMS9929 mit seinen DRAMs derart empfindlich, das wir spätestens hier nicht um einen stabilen, gelöteten Aufbau herumkommen. Der aktuelle Stand soll also auf einzelne Lochrasterkarten verteilt werden. Diese verbinden wir mit einem einem 50pol. Flachbandkabel (SCSI-2) als &amp;ldquo;Backplane&amp;rdquo;.&lt;/li>
&lt;li>Wir brauchen Puffer. Wir hoffen, die Hold Times dadurch in den Griff zu bekommen, indem wir den Datenbus und die entsprechenden Steuerleitungen puffern. In der Bastelkiste liegen 74ls245, diese sollten es tun. Sinn der Übung ist es, die Verzögerungen aufzufangen, die durch die Adressdekodierung im GAL entstehen und somit 10-15ns Zeit &amp;ldquo;rauszuholen&amp;rdquo;. Datenleitungen, Steuerleitungen und CS-Signale sollten dann keinen nennenswerten Versatz mehr aufweisen. Schaltpläne folgen.&lt;/li>
&lt;/ol></content></item></channel></rss>