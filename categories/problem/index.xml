<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>problem on</title><link>https://beta.steckschwein.de/categories/problem/</link><description>Recent content in problem on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 01 May 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://beta.steckschwein.de/categories/problem/index.xml" rel="self" type="application/rss+xml"/><item><title>Logikanalyse</title><link>https://beta.steckschwein.de/post/logikanalyse/</link><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/logikanalyse/</guid><description>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.
Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.
Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2.</description><content>&lt;p>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.&lt;/p>
&lt;p>&lt;img src="images/logic_analyzer.jpg" alt=""> Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.&lt;/p>
&lt;p>Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2. Takthälfte für Buszugriffe nutzt. Diese ist nur 62,5ns lang. Von dieser Zeit geht ausserdem noch die Durchlaufzeit der Adressdekodierung und weiterer Glue-Logik ab. Eigens angeschaffte neue SRAMs von Alliance Memory mit 55ns Zugriffszeit sollten also ganz knapp schnell genug sein. Trotzdem treten mit diesen immer wieder merkwürdig zufällige Abstürze auf, die 100ns-Chips laufen dagegen problemlos.&lt;/p>
&lt;p>Also ran an die Maschine. Hierbei zeigte sich auch schon schnell etwas Merkwürdiges:&lt;/p>
&lt;p>&lt;img src="images/we_addr.png" alt=""> Analyse von Adress- und Datenbus sowie Steuersignale&lt;/p>
&lt;p>Es fiel etwas unangenehm auf, dass die steigende Flanke von /WE (Ende des Schreibzugriffs) direkt mit der Änderung des Adressbus zusammenfällt. Idealerweise sollte der Schreibzugriff beendet sein, bevor am Adressbus eine andere Adresse anliegt. Das Datenblatt nennt die Zeitspanne zwischen der steigenden Flanke von /WE und einer Änderung auf dem Adressbus tWR (Write Recovery Time):&lt;/p>
&lt;p>&lt;img src="images/sram_timing.png" alt="sram_timing">&lt;/p>
&lt;p>Laut Diagramm soll also /WE high werden, &lt;strong>bevor&lt;/strong> sich der Adressbus ändert. Im Datenblatt selbst ist die Write Recovery Time mit 0ns angegeben, und zwar bei beiden SRAMs, die 100ns-Typen sowie bei den 55ns-Bausteinen. Das würde bedeutet, dass die steigende Flanke von /WE mit einer Änderung der Adresse zeitlich zusammenfallen darf. Der verwendete Logicanalyzer hat eine Auflösung von 10ns, sodass man eigentlich nur sagen kann, dass sich /WE und der Adressbus im selben Zeitraum von 10ns ändern. Also schauen wir uns /WE und eine zufällige Adressleitung nochmal unterm Oszilloskop an.&lt;/p>
&lt;p>&lt;img src="images/oszi.jpg" alt=""> /WE und A9 unterm Oszilloskop. Gelb: /WE, Blau: A9&lt;/p>
&lt;p>Offenbar ändert sich der Adressbus, &lt;strong>bevor&lt;/strong> mit der steigenden Flanke von /WE der Schreibzugriff endet! Einen ausreichend schnellen Chip vorausgesetzt, könnte der anliegende Schreibzugriff womöglich in die neue Adresse hereingeschleppt werden. Wie dem auch sei, auf jeden Fall etwas, das so nicht sein darf! Wir halten die 0ns Write Recovery Time nicht ein, indem wir sie um ca. 4ns unterschreiten.&lt;/p>
&lt;p>/OE und /WE für die RAMs wird bei uns durch 3 NAND-Gatter in einem 74HCT00 aus der r/W-Leitung und dem Systemtakt erzeugt. Ein 74HCT00 hat eine Durchlaufzeit von ca. 9ns. Als nächstes werden wir also stattdessen einen 74F00 verwenden, der uns mit 3.7ns Durchlaufzeit wieder in den Bereich tWR &amp;gt; 0ns bringen sollte. Sollte es das nicht bringen, werden wir uns etwas grundsätzlichere Gedanken machen müssen.&lt;/p></content></item><item><title>Mehr Karten (UPDATE)</title><link>https://beta.steckschwein.de/post/mehr-karten-update/</link><pubDate>Fri, 24 Jul 2015 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/mehr-karten-update/</guid><description>Unser &amp;ldquo;Standard&amp;rdquo;-Massenspeicher SD-Karte funktioniert zwar an und für sehr gut, Sorgenkind war aber immer die Initialisierungs-Routine. Bisher ließen sich damit nur günstige Class4-Karten initialisieren, bei &amp;ldquo;höherwertigen&amp;rdquo; Karten schlug die Initialisierung immer fehl, sodass nur etwa 3 von 5 Karten nutzbar waren.
Das hat uns schon etwas gewurmt, denn irgendwie hatte dieser Stand ein Geschmäckle von &amp;ldquo;Funktioniert aus Versehen&amp;rdquo;. Also mussten wir da nochmal ran. Der Initialisierungs-Flow entspricht im Wesentlichen dem, was auf der bekannten Seite http://elm-chan.</description><content>&lt;p>Unser &amp;ldquo;Standard&amp;rdquo;-Massenspeicher SD-Karte funktioniert zwar an und für sehr gut, Sorgenkind war aber immer die Initialisierungs-Routine. Bisher ließen sich damit nur günstige Class4-Karten initialisieren, bei &amp;ldquo;höherwertigen&amp;rdquo; Karten schlug die Initialisierung immer fehl, sodass nur etwa 3 von 5 Karten nutzbar waren.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Das hat uns schon etwas gewurmt, denn irgendwie hatte dieser Stand ein Geschmäckle von &amp;ldquo;Funktioniert aus Versehen&amp;rdquo;. Also mussten wir da nochmal ran. Der Initialisierungs-Flow entspricht im Wesentlichen dem, was auf der bekannten Seite &lt;a href="http://elm-chan.org/docs/mmc/mmc_e.html">http://elm-chan.org/docs/mmc/mmc_e.html&lt;/a> dokumentiert ist. In den letzten Tagen haben wir diesen unter die Lupe genommen, und tatsächlich ist etwas aufgefallen. Vor dem Senden eines Kommandos muss sichergestellt werden, dass die Karte bereit ist. Hierzu sendet man solange $ff an die Karte, bis diese auch $ff zurücksendet. Dann ist die Karte bereit, ein Kommando zu empfangen. In unserer Initialisierungsroutine wurde dies zwischen CMD55 und ACMD41 (näheres bitte dem Link entnehmen) schlichtweg nicht gemacht. Plötzlich lassen sich fast alle vorhandenen Karten initialisieren. Dass dies mit den Class4-Karten trotzdem funktionierte, war also gewissermaßen tatsächlich aus Versehen.&lt;/p>
&lt;p>Das nächste Problem war dann, dass von den jetzt nutzbaren Karten über die Shell zwar im Filesystem navigiert und Verzeichnisse aufgelistet werden konnten, das eigentliche Laden von Dateien bzw. Starten von Programmen funktionierte nicht. Die Blockleseroutinen liefen korrekt durch, die geladenen Daten jedoch waren fehlerhaft. Dass die Dateisystemoperationen funktioniert haben, und nur das Einlesen von Dateien Probleme machte, war verdächtig. &lt;a href="http://wordpress.steckschwein.de/wordpress/index.php/2015/05/20/filesystem-und-shell/">Noch im Mai verkündeten wir&lt;/a> u.a. stolz, dass wir zum Dateien lesen schnelle SD-Multiblock-Transfers verwenden. Diese haben den Vorteil, dass man der Karte nur die Adresse des ersten zu lesenden Blocks übermittelt, und dann einfach liest bis der Arzt kommt oder man der Karte sagt, dass man fertig ist. Vorteil ist, dass man die Blockadresse des nächsten Blocks nicht immer selber ausrechnen muss (immerhin eine 32bit-Addition) und auch nicht immer wieder an die Karte schicken muss.&lt;/p>
&lt;p>Gut, also die fat_read-Routine zurückgebaut, und schon ist das Steckschwein mit so ziemlich jeder handelsüblichen SD-Karte kompatibel.&lt;/p>
&lt;p>&lt;strong>[UPDATE:]&lt;/strong> Mittlerweile funktionieren auch wieder Multiblock-Transfers. Der Trick war, beim Lesen von der Karte die MOSI-Leitung nicht auf L, sondern auf H zu setzen, also nicht mehr $00 zu senden, sondern $ff. Die Idee kam, nachdem sämtliche Beispiele, die sich im Web finden lassen, $ff senden. Die Stelle in der SD-Karten-Spezifikation, in der das so spezifiziert ist, ist bis dato nicht gefunden worden.&lt;/p></content></item><item><title>Murphy III - Timing ist alles</title><link>https://beta.steckschwein.de/post/murphy-iii-timing-ist-alles/</link><pubDate>Mon, 14 Apr 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/murphy-iii-timing-ist-alles/</guid><description>In den Posts http://8bit-gefriemel.blogspot.de/2014/03/murphy.html und http://8bit-gefriemel.blogspot.de/2014/04/murphy-ii.html sind einige merkwürdige Phänomene und deren Lösungsversuche geschildert. Wie sich heute gezeigt hat, konnten wir gar nicht weiter daneben liegen.
Alles Quatsch. Die Fehlersuche nach dem &amp;ldquo;K&amp;rdquo;-Problem. Stack und so. Alles super. Klar, das mit dem Initialisieren des Stackpointers war natürlich richtig und wichtig, und dass die uart_tx routine besser funktioniert wenn man auf Stack-Operationen verzichtet, hätte uns eigentlich eher stutzig machen sollen. Aber der Reihe nach.</description><content>&lt;p>In den Posts &lt;a href="http://8bit-gefriemel.blogspot.de/2014/03/murphy.html">http://8bit-gefriemel.blogspot.de/2014/03/murphy.html&lt;/a> und &lt;a href="http://8bit-gefriemel.blogspot.de/2014/04/murphy-ii.html">http://8bit-gefriemel.blogspot.de/2014/04/murphy-ii.html&lt;/a> sind einige merkwürdige Phänomene und deren Lösungsversuche geschildert. Wie sich heute gezeigt hat, konnten wir gar nicht weiter daneben liegen.&lt;/p>
&lt;p>Alles Quatsch. Die Fehlersuche nach dem &amp;ldquo;K&amp;rdquo;-Problem. Stack und so. Alles super. Klar, das mit dem Initialisieren des Stackpointers war natürlich richtig und wichtig, und dass die uart_tx routine besser funktioniert wenn man auf Stack-Operationen verzichtet, hätte uns eigentlich eher stutzig machen sollen. Aber der Reihe nach.&lt;/p>
&lt;p>Der alte Rockwell 65c02P4 wurde nämlich derweil durch einen funkelnagelneuen WDC 65c02S6TPG-14 ersetzt. Dieser brauchte zunächst einen Pullup-Widerstand für den BE-Pin, ohne den sich seine Bus-Leitungen im Tri-State-Zustand befunden hätten. Toll, wenn man den Prozessor vom Bus trennen muss, weil er ihn sich z.B. mit einem Grafikchip teilen muss. In unserem Fall aber ist der 65c02 immer der Chef. Also auf high mit dem Pin.&lt;/p>
&lt;p>Relativ unvermittelt und mit keiner zu dem Zeitpunkt offensichtlichen Änderung an der Schaltung traten dann die oben beschriebenen Probleme auf. Die Fehlersuche brachte durchaus einiges zu Tage, wie beispielsweise die bislang nicht vorhandene Initialisierung des Stackpointers, jedoch führte nichts wirklich zu einer Lösung. Die Änderung der uart_tx_routine führte dazu, dass der Upload wieder funktioniert. Bis das Problem nach einem BIOS-Update mit kaum Code-Änderungen wieder auftrat. Diesmal mit einem nicht immer erfolgreich durchlaufenden Speichertest. Das K-Problem war zurück, und hat Verstärkung mitgebracht.&lt;/p>
&lt;p>Es half nichts. Es blieb nur, zu rekapitulieren, welche Änderungen an der Schaltung vorgenommen wurden. In Chris Wards ursprünglichem Design waren die OE-Pins der 62256 SRAMS direkt mit den CS-Pins verbunden. Ein selektierter Chip hatte also automatisch auch seine Daten auf den Bus gelegt. Dies ist möglich, weil die WE-Leitung bei den verwendeten HY62256ALP-10-Bausteine ohnehin immer Vorrang hat. Aus irgendeinem Grund hat mir das nicht gefallen und ich habe die OE-Pins mit dem generierten OE-Signal verbunden, welches auch den OE-Pin des EEPROM steuert. Bislang hat dies auch immer problemlos funktioniert. Interessanterweise traten aber auch auf Markos Schaltung unerklärliche Phänomene auf, nachdem diese Modifikation dort vorgenommen wurde.&lt;/p>
&lt;p>Dann der WDC-Prozessor. Hatte es diese Probleme auch mit dem Rockwell gegeben? Der WDC kann schließlich mit bis zu 14MHz getaktet werden, der Rockwell immerhin mit 4 MHz. Zeit, mal einen Blick ins Datenblatt zu werfen. Schnell fällt auf, dass der Rockwell z.B. eine Address hold time von 30ns hat, der WDC aber nur 10ns. Eigentlich klar, der Chip ist für weit höhere Frequenzen ausgelegt, also sind auch die Timings empfindlicher. Aber dann sollte uns noch eine Sache wie Schuppen von den Augen fallen&amp;hellip;&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Eingehendere Lektüre des WDC-Datenblatts liess uns dann noch auf folgende Perle stoßen:&lt;/p>
&lt;p>&lt;em>An external oscillator is recommended for driving PHI2 and used for the main system clock. All production test timing is based on PHI2. &lt;strong>PHI2O and PHI1O were used in older systems for system timing&lt;/strong> and internal oscillators when an external crystal was used.&lt;/em> Und weiter, als Fußnote zu den Timings:&lt;/p>
&lt;ol>
&lt;li>PHI1O and PHI2O clock delay from PHI2 is no longer specified or tested and WDC recommends using an oscillator for system time base and PHI2 processor input clock.&lt;/li>
&lt;/ol>
&lt;p>Jeder 6502 hat bisher das Systemtiming selbst generiert und am Pin PHI2O bereitgestellt. Von dort aus wurde alles mit Takt versorgt, was einen Takteingang hat. Damit hat WDC nun gebrochen und empfiehlt, den Systemtakt direkt am Oszillator abzugreifen. Das hatten wir beim Austausch Rockwell gegen WDC natürlich nicht berücksichtigt, wer denkt denn an sowas. Unser Rechner hat seinen Takt old-school-like vom PHI2O bezogen. Der Screenshot vom Logic Analyzer zeigt, dass PHI2O manchmal, aber nicht immer einen Versatz.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Dementsprechend war die Lösung des Problems dann denkbar simpel: Die Taktleitungen für den Rest des Systems 2 Pins weiter nach rechts gesteckt.&lt;/p>
&lt;p>Bleibt die Frage, was man denn macht, wenn man einen 65c02 aus einem alten System ersetzen möchte. Der WDC dürfte ohne Anpassungen nicht stabil laufen.&lt;/p></content></item><item><title>Murphy II</title><link>https://beta.steckschwein.de/post/murphy-ii/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/murphy-ii/</guid><description>Flugs also ein ROM gebrannt mit der memtest-routine, in die nach der Reset-Routine eingesprungen wird. Gleiches Ergebnis. Beim ersten Auftreten des &amp;ldquo;K statt OK&amp;rdquo;-Fehlers ist erstmal die doch etwas windig anmutende Verdrahtung der Adressleitungen zwischen Prozessor, den RAM-Bausteinen und dem ROM mit &amp;ldquo;richtigen&amp;rdquo; Steckbrettstrippen statt Klingeldraht nachverdrahtet worden. Das war vermutlich etwas voreilig, schließlich hats vorher ja auch schon funktioniert. Schließlich stellt sich heraus, dass sich hier in der Tat ein paar Fehler eingeschlichen haben, die auch beim Durchklingeln der einzelnen Adressleitungen nicht aufgefallen sind: Kurzschlüsse.</description><content>&lt;p>Flugs also ein ROM gebrannt mit der memtest-routine, in die nach der Reset-Routine eingesprungen wird. Gleiches Ergebnis. Beim ersten Auftreten des &amp;ldquo;K statt OK&amp;rdquo;-Fehlers ist erstmal die doch etwas windig anmutende Verdrahtung der Adressleitungen zwischen Prozessor, den RAM-Bausteinen und dem ROM mit &amp;ldquo;richtigen&amp;rdquo; Steckbrettstrippen statt Klingeldraht nachverdrahtet worden. Das war vermutlich etwas voreilig, schließlich hats vorher ja auch schon funktioniert. Schließlich stellt sich heraus, dass sich hier in der Tat ein paar Fehler eingeschlichen haben, die auch beim Durchklingeln der einzelnen Adressleitungen nicht aufgefallen sind: Kurzschlüsse.  Nachdem diese behoben wurden, läuft unser Speichertest auch wieder komplett durch.  Zeit also, sich dem eigentlichen Problem anzunehmen. Wo bleibt das &amp;ldquo;O&amp;rdquo;? Interessanterweise scheint das Empfangen von Daten nicht betroffen zu sein, denn die memtest-Routine funktioniert hochgeladen genauso wie aus dem ROM.  Also schaue ich mir die Routine an, die Daten (bytes) über den UART sendet.&lt;/p>
&lt;p>i_uart_tx         pha -       lda uart1lsr         and #$20         beq - pla         sta uart1rxtx&lt;/p>
&lt;p>rts&lt;/p>
&lt;p>Sieht doch erstmal nicht verkehrt aus. Ich mache trotzdem ein Experiment, und ersetze die Stackoperationen, indem ich stattdessen auf das X-Register ausweiche:&lt;/p>
&lt;p>i_uart_tx         tax -       lda uart1lsr         and #$20         beq - stx uart1rxtx rts Und auf einmal kriege ich mein &amp;ldquo;OK&amp;rdquo;. Schnall ich jetzt nicht. Ist der Stack kaputt? Ich mache mir ein paar grundsätzliche Gedanken und halte die Idee, den Stack Pointer einfach mal zu initialisieren, für gut. Ich packe entsprechenden Code an den Beginn der RESET-Routine, und lösche auch gleich das Dezimal-Flag. ; disable interrupt        sei ; clear decimal flag cld ; init stack pointer ldx #$ff&lt;/p>
&lt;p>txs&lt;/p>
&lt;p>Ich baue die uart_tx-Routine zurück und bekomme wieder nur &amp;ldquo;K&amp;rdquo;. Während also das Initialisieren des Stack-Pointers richtig und wichtig ist, ist unser Problem noch ein anderes. Die uart_tx-Routine sieht jetzt so aus, und bleibt so: i_uart_tx         pha         phx tax -       lda uart1lsr         and #$20         beq - stx uart1rxtx plx         pla&lt;/p>
&lt;p>rts&lt;/p>
&lt;p>Der Stack wird nach einem kurzen Testprogramm für fehlerfrei befunden. Trotzdem funktioniert die serielle Kommunikation noch nicht. Es kommt nicht das an, was gesendet wird. Das hat doch eigentlich schon funktioniert. Die Initialisierung des UART wird nochmal unter die Lupe genommen.&lt;/p>
&lt;p>lda #0        sta uart1fcr    ; FIFO off Das FCR-Register ist das FIFO-Control-Register. Die FIFO schalten wir durch das ablegen von 0 ab, da wir gerade nur Polling nutzen. Das Register bietet auch Bits zum löschen der Empfangs- und Sende-FIFO sowie setzen des &amp;ldquo;Füllstandes&amp;rdquo; bei welchen ein Interrupt ausgelöst werden soll. Laut Datenblatt aktiviert bzw. deaktiviert das Bit 0 dieses Registers die FIFO. Alle anderen Bits werden nur dann berücksichtigt, wenn Bit 0 auf 1 ist. Also vielleicht einfach mal pauschal die FIFOs löschen, und dann abschalten? lda #7            sta uart1fcr         lda #0       sta uart1fcr    ; FIFO off&lt;/p>
&lt;p>Das scheint richtig gewesen zu sein, wir haben wieder eine funktionierende Upload-Routine.&lt;/p>
&lt;p>Da ich mich inzwischen genug über den 16550 geärgert habe, beschließe ich, dass er mir ruhig was Gutes tun könnte, und setze den Baudraten-Divisor auf &amp;ldquo;1&amp;rdquo; und damit eine Baudrate von 115200.&lt;/p>
&lt;p>Die Feststellung, dass das sogar stabil funktioniert versöhnt mich fürs erste wieder und ich gehe zufrieden ins Bett.&lt;/p></content></item><item><title>... kein Spaß - Murphy schlägt zu</title><link>https://beta.steckschwein.de/post/kein-spass-murphy-schlaegt-zu/</link><pubDate>Mon, 31 Mar 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/kein-spass-murphy-schlaegt-zu/</guid><description>Neben all den ermutigenden Experimenten gibt es natürlich auch immer mal wieder Rückschläge. Mittlerweile haben wir schon ein durchaus komplexes Gebilde auf dem Steckbrett, welches ja per se nicht die ideale Plattform ist, um so etwas zu bauen.
So wie aktuell gerade mein &amp;ldquo;Steckschwein&amp;rdquo; ein sehr merkwürdiges Verhalten an den Tag legt, ohne dass an der Schaltung etwas geändert worden wäre (Marko ist Zeuge).
Vorab nochmal der Ablauf unserer Upload-Routine, mit der wir das Steckschwein via RS232 mit Code befüttern:</description><content>&lt;p>Neben all den ermutigenden Experimenten gibt es natürlich auch immer mal wieder Rückschläge. Mittlerweile haben wir schon ein durchaus komplexes Gebilde auf dem Steckbrett, welches ja per se nicht die ideale Plattform ist, um so etwas zu bauen.&lt;/p>
&lt;p>So wie aktuell gerade mein &amp;ldquo;Steckschwein&amp;rdquo; ein sehr merkwürdiges Verhalten an den Tag legt, ohne dass an der Schaltung etwas geändert worden wäre (Marko ist Zeuge).&lt;/p>
&lt;p>Vorab nochmal der Ablauf unserer Upload-Routine, mit der wir das Steckschwein via RS232 mit Code befüttern:&lt;/p>
&lt;ol>
&lt;li>Transferprogramm sendet die Ladeaddresse (2 bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;li>Anzeige der Ladeaddresse im LCD&lt;/li>
&lt;li>Transferprogramm übermittelt die Länge der zu sendenden Daten (2 bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;li>Anzeige der Länge in Bytes im LCD&lt;/li>
&lt;li>Upload-Routine addiert Startaddresse + Länge in Bytes und errechnet so die Endadresse&lt;/li>
&lt;li>Anzeige der Endaddresse im LCD&lt;/li>
&lt;li>Transferprogramm sendet den Code (n bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;/ol>
&lt;p>Völlig unprovoziert wird auf einmal das &amp;ldquo;O&amp;rdquo; unterschlagen, sodass wir nur noch ein &amp;ldquo;K&amp;rdquo; erhalten. Dies läßt sich gut mit einem Terminalprogramm nachvollziehen. Um weiter debuggen zu können, passen wir das Transferprogramm an, dass es sich auch mit &amp;ldquo;K&amp;rdquo; zufriedengibt und laden eine echo-Routine, die die empfangenen Zeichen wieder über RS232 zurückschreibt und außerdem auf dem Display ausgibt.&lt;/p>
&lt;p>Wir beobachten, wie einige Zeichen wieder ge-echo-t werden, andere nicht, während sie nebst einigem Müll sowie der Ziffer 0 auf dem Display ausgegeben werden.&lt;/p>
&lt;p>Ein ähnliches Phänomen haben wir schon beim Einbau/Programmierung des UART beobachtet. Damals war der Fehler, dass die FIFO aktiviert war. Da wir den UART aktuell nur mittels Polling betreiben, gab es Probleme, die sich mit der Deaktivierung der FIFO beheben ließen. Das ist hier anders. Und zu allem Überfluss scheint das Phänomen zeitweilig auch wieder zu verschwinden. Will heissen: Ohne unser Zutun kam auch wieder ein &amp;ldquo;OK&amp;rdquo;. Dann wieder nicht mehr. Die zugegeben bis dato etwas windige Verdrahtung der Speicherchips wurde bei der Gelegenheit durch &amp;ldquo;richtige&amp;rdquo; Steckstrippen ersetzt. Die dabei entstandenen Fehler wurden schließlich auch gefunden, sodass wir mit einem Tag Verzug wieder so weit waren, das eigentliche Problem zu erforschen.&lt;/p>
&lt;p>Unsere Mem-Test-Routine läßt sich hochladen, zeigt aber immer denselben Fehler. Da wir nicht sicher sein können, ob die Routine tatsächlich korrekt hochgeladen wurde, macht weiteres Testen nur Sinn, wenn die dazu notwendigen Routinen bereits im ROM liegen.&lt;/p></content></item></channel></rss>