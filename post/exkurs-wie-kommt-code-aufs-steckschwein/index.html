<!doctype html><html lang=en><head><title>Exkurs: Wie kommt Code aufs Steckschwein? :: Steckschwein</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Die Programmierung eines Computers, der nur aus einer gesteckten Schaltung besteht und weder Tastatur noch Speichermöglichkeit hat, ist eine mühsame Angelegenheit. Die allerersten Experimente bekamen ihr Futter auf einem 27128-EPROM serviert. Bekanntlich wollen diese vor dem Beschreiben mit neuem Code mit UV-Licht gelöscht werden. Also wurde für jedes Update ein EPROM mit neuem Code gebrannt, um die EPROMS anschließend in 10er-Packen ins Löschgerät zu schieben. 15 Minuten Kaffeepause.
Überhaupt, Code: Für die ersten Experimente hat es genügt, die reinen Hexcodes in einen Hexeditor zu tippen und die Daten dann zu brennen."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://beta.steckschwein.de/post/exkurs-wie-kommt-code-aufs-steckschwein/><link rel=stylesheet href=https://beta.steckschwein.de/assets/style.css><link rel=stylesheet href=https://beta.steckschwein.de/assets/green.css><link rel=apple-touch-icon href=https://beta.steckschwein.de/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://beta.steckschwein.de/img/favicon/green.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Exkurs: Wie kommt Code aufs Steckschwein?"><meta property="og:description" content="Die Programmierung eines Computers, der nur aus einer gesteckten Schaltung besteht und weder Tastatur noch Speichermöglichkeit hat, ist eine mühsame Angelegenheit. Die allerersten Experimente bekamen ihr Futter auf einem 27128-EPROM serviert. Bekanntlich wollen diese vor dem Beschreiben mit neuem Code mit UV-Licht gelöscht werden. Also wurde für jedes Update ein EPROM mit neuem Code gebrannt, um die EPROMS anschließend in 10er-Packen ins Löschgerät zu schieben. 15 Minuten Kaffeepause.
Überhaupt, Code: Für die ersten Experimente hat es genügt, die reinen Hexcodes in einen Hexeditor zu tippen und die Daten dann zu brennen."><meta property="og:url" content="https://beta.steckschwein.de/post/exkurs-wie-kommt-code-aufs-steckschwein/"><meta property="og:site_name" content="Steckschwein"><meta property="og:image" content="https://beta.steckschwein.de/img/favicon/green.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="acia"><meta property="article:section" content="acme"><meta property="article:section" content="rs232"><meta property="article:section" content="uart"><meta property="article:published_time" content="2014-04-03 00:00:00 +0000 UTC"></head><body class=green><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Steckschwein</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about/>About</a></li><li><a href=/hardware/>Hardware</a></li><li><a href=/software/>Software</a></li><li><a href=/impressum/>Impressum</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about/>About</a></li><li><a href=/hardware/>Hardware</a></li><li><a href=/software/>Software</a></li><li><a href=/impressum/>Impressum</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://beta.steckschwein.de/post/exkurs-wie-kommt-code-aufs-steckschwein/>Exkurs: Wie kommt Code aufs Steckschwein?</a></h1><div class=post-meta><span class=post-date>2014-04-03</span></div><div class=post-content><div><p>Die Programmierung eines Computers, der nur aus einer gesteckten Schaltung besteht und weder Tastatur noch Speichermöglichkeit hat, ist eine mühsame Angelegenheit. Die allerersten Experimente bekamen ihr Futter auf einem 27128-EPROM serviert. Bekanntlich wollen diese vor dem Beschreiben mit neuem Code mit UV-Licht gelöscht werden. Also wurde für jedes Update ein EPROM mit neuem Code gebrannt, um die EPROMS anschließend in 10er-Packen ins Löschgerät zu schieben. 15 Minuten Kaffeepause.</p><p>Überhaupt, Code: Für die ersten Experimente hat es genügt, die reinen Hexcodes in einen Hexeditor zu tippen und die Daten dann zu brennen. Dies war vertretbar, da die ersten Programme etwa so aussahen: EA EA EA EA EA EA EA EA C9 C9 C9 C9 C9 C9 C9 C9 4C 00 0E</p><p>Der Erwerb einiger EEPROMS des Typs 28c256 stellten eine große Erleichterung dar, als das Steckschwein langsam zu einem &ldquo;richtigen&rdquo; Computer und der Testcode damit immer umfangreicher würde. Die UV-Kaffeepausen entfielen, der Chip konnte einfach wieder neu gebrannt werden. Moderne Zeiten.</p><p>Auch der komplexere Code erforderte langsam neue Herangehensweisen. Komplexere Routinen wurden auf dem C64 im Maschinensprachemonitor vorgeschrieben und die Hexcodes dann abgetippt und auf EEPROM gebrannt (ja, echt). Aber auch mühselig. Neues Werkzeug musste her. Und zwar in Form des <a href=https://sourceforge.net/projects/acme-crossass/>ACME-Crossassemblers</a>. Nach kurzer Eingewöhnung (warum haben wir das nicht gleich so gemacht?) konnte nun drauflosgecoded werden dass die Schwarte kracht. Wenn nur dieses leidige Chip Umstecken nicht wäre.</p><p>Unser Steckschwein verfügte inzwischen über eine 65c51 ACIA und damit über eine RS232-Schnittstelle. Das mußte sich doch irgendwie nutzen lassen. Steckschwein-seitig sollte das BIOS nur die Hardware initialisieren, im Falle der ACIA die Verbindungsparameter (Baudrate, Stopbit..) setzen, und dann einfach nur die Schnittstelle pollen und auf Futter warten. Und dieses dann Byte für Byte in den Speicher schreiben und am Ende an diese Adresse springen.</p><p>Auf der anderen Seite des rs232-Kabels entschieden wir uns, ein kleines Python-Programm zu schreiben, welches mittels <a href=http://pyserial.sourceforge.net/>Pyserial</a> die Kommunikation übernehmen sollte. Als rätselhaft schwierig gestaltete es sich, Daten &ldquo;am Stück&rdquo; an das Steckschwein zu senden, die Kommunikation brach nach wenigen Bytes ab. Wir hielten das zunächst für eine Macke der an Macken nicht armen ACIA, und programmierten drum herum. Die Laderoutine auf dem Steckschwein quittierte jedes empfangene Byte mit einem &ldquo;*&rdquo;. Das Python programm schrieb ein Byte, und las ein &ldquo;*&rdquo;. Als &ldquo;Ende-Markierung&rdquo; dienten 5 Null-Bytes am Ende des Programms. Wurde also das fünfte $00 empfangen, nahm die Laderoutine keine Daten mehr entgegen und führte ein JMP $1000 aus, wo der Code auch seine Startadresse zu haben hatte. Diese Methode war auch bei 19200 baud ziemlich lahm, aber tat ihren Job erstmal. Kein elendes Chip umstecken mehr. Den angeblichen ACIA-Macken wurde keine weitere Beachtung mehr geschenkt, sollte die ACIA doch schließlich durch einen 16550 UART abgelöst werden. Vorher den Code nochmal anzufassen wäre nicht sinnvoll.</p><p>Nachdem also besagter 16550 einige Nerven gekostet hatte (hierzu an anderer Stelle mehr), war es Zeit, die Uploadroutine zu überarbeiten. Zum Einen sollte nach einem berechtigen Einwand von Marko die Endmarkierung mit den 5 Nullbytes weg. Sowas kommt nämlich durchaus vor, wenn man mal Zeichensätze oder sowas hochladen will. Zum anderen wäre es praktisch, wenn man die Ladeadresse wählen könnte. Doch zuallererst sollte dieser *-Hack weg. Denn dieser war auch mit dem UART noch nötig. Also sind entweder ACIA und UART beide gleich bescheuert, oder wir machen irgendwas falsch.</p><p>Eigentlich sollte es möglich sein, mittels</p><p>ser.write(code)</p><p>unseren ganzen Code komplett rüberzuschieben, ohne zwischendrin irgendeinen Pseudo-Handshake veranstalten zu müssen. Trotzdem kommen immer nur ein paar Bytes an, dann ist Schluß. Experimentieren mit irgendwelchen Timeout-Parametern von pyserial brachte keine Abhilfe. Nach einigem Probieren ging dann ein Licht an. Wir hatten folgendes probiert:</p><p>ser.write(code) time.sleep(1)</p><p>Und siehe da - der Code wurde komplett übertragen. Anscheinend ist es so, dass in pyserial write nicht blockiert, read nach eingestelltem Timeout aber schon. Jedenfalls ist das auf dem Mac so, zu testen ob sich pyserial auf anderen Systemen anders verhält, haben wir uns erspart.</p><p>Ich schreibe die Uploadroutine so um, dass sie 2 Bytes erwartet, nämlich die Ladeadresse, dies dann mit &ldquo;OK&rdquo; quittiert, dann nochmal 2 Bytes, nämlich die Länge der zu übertragenden Daten, wieder &ldquo;OK&rdquo;, dann die Daten selbst, bis die entsprechende Anzahl Bytes empfangen wurde, dann wieder &ldquo;OK&rdquo;.</p><p>Das Python-Programm macht demnach einfach bytes = ser.write(struct.pack(&rsquo;&lt;h&rsquo;, startaddr))         if ser.read(2) == &lsquo;OK&rsquo;:                 print &ldquo;Start address %d bytes&rdquo; % (bytes, ) bytes = ser.write(struct.pack(&rsquo;&lt;h&rsquo;, length))         if ser.read(2) == &lsquo;OK&rsquo;:                 print &ldquo;Length %d bytes&rdquo; % (bytes, ) bytes = ser.write(content)         if ser.read(2) == &lsquo;OK&rsquo;:                 print &ldquo;Length %d bytes&rdquo; % (bytes, )</p><p>Das war&rsquo;s. Einfacher gehts fast nicht, die Ladeaddresse ist frei wählbar, und wir übertragen den Code dank UART jetzt mit 115200 baud statt mit 19200.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://beta.steckschwein.de/post/schaltplan/><span class=button__icon>←</span>
<span class=button__text>Schaltplan</span></a></span>
<span class="button next"><a href=https://beta.steckschwein.de/post/murphy-ii/><span class=button__text>Murphy II</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://beta.steckschwein.de/assets/main.js></script>
<script src=https://beta.steckschwein.de/assets/prism.js></script></div></body></html>