<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface - Steckschwein</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=Steckschwein rel=home><div class="logo__item logo__text"><div class=logo__title>Steckschwein</div><div class=logo__tagline>An 8bit computer for the 21st century</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Blog</span></a></li><li class=menu__item><a class=menu__link href=/hardware/><span class=menu__text>Hardware</span></a></li><li class=menu__item><a class=menu__link href=/software/><span class=menu__text>Software</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li><li class=menu__item><a class=menu__link href=/impressum/><span class=menu__text>Impressum</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface</h1></header><div class="content post__content clearfix"><p>&mldr; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.</p><p>as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</p><ol><li>the first 2 bytes send to vdp during a write are always register writes which require a short delay of at least 2µs in between each byte</li><li>the write of the 3rd byte (after the 2nd) requires a delay of 8µs. any further &ldquo;single byte transfer&rdquo; - during a vram write - also requires the 8µs delay. the same is true if we want to initiate a register write direclty after a vram write.</li><li>the 3rd and n-th byte write to port #3 (index register port) during a bulk register write requires only the 2µs between each byte</li></ol><p>With this in mind, we can optimize our library a little bit by using different &ldquo;nop slides&rdquo; for address setup and vram writes.</p><p>We enhance our vdp.inc and built two macros which provide the different delay we need.</p><pre tabindex=0><code>.macro vdp_wait_s
  jsr vdp_nopslide_2m ; 2m for 2µs wait
...

.macro vdp_wait_l
  jsr vdp_nopslide_8m ; 8m for 8µs wait
...
</code></pre><p>steckSchwein is running at 8Mhz, so we also defined some equations and used ca65 macros to build our nop slides.</p><pre tabindex=0><code>.define CLOCK_SPEED_MHZ 8

; long delay with 6µ+2µs (below)
MAX_NOPS_8M = (6 * 1000 / (1000 / CLOCK_SPEED_MHZ)) / 2 
; 8Mhz, 125ns per cycle, wait 6µs = 6000ns 
; = 6000ns / 125ns = 48cl / 2 =&gt; 24 NOP 

; short delay with 2µs wait
MAX_NOPS_2M = (2 * 1000 / (1000 / CLOCK_SPEED_MHZ) -12) / 2 
; -12 =&gt; jsr/rts = 2 * 6cl = 12cl must be subtract

.macro m_vdp_nopslide
vdp_nopslide_8m:
   ; long delay with 6+2 2µs wait
   .repeat MAX_NOPS_8M
      nop
   .endrepeat
vdp_nopslide_2m:	
   .repeat MAX_NOPS_2M
      nop
   .endrepeat
   rts
.endmacro
</code></pre><p>Another interesting thing would be, &ldquo;how does the /WAIT&rdquo; behave in this situation? the assumption here is, that the /WAIT will behave in the way as specified. so /WAIT will be go low at least after 130ns from CSW. so to handover the /RDY handling to the vdp via the /WAIT pin, we have to apply only 1 wait state from our WS-Gen. after one wait state, we can release the /RDY low from our WS so that the vdp /WAIT can drive /RDY as needed.</p><p>Back home, Thomas did the test and changed the waitstate generator firmware for the GAL16V8.</p><p>The equation was</p><pre tabindex=0><code>W2 = ROM \* UART \* SND \* /VDP 
W1 = W2 
     + /ROM \* UART \* VDP
</code></pre><p>and was changed to</p><pre tabindex=0><code>W2 = /SND
W1 = W2
     + /ROM 			; /ROM wait state if ROM is cs
     + /VDP			; /VDP wait state if VDP is cs
</code></pre><p>So finally, we only need one wait state from the waitstate generator to access the VDP. If the VDP requires more time - surely - during a video memory access it will drive /WAIT to low as long as needed. So after the explcit 1WS from our wait state generator we now hand over the /RDY control to the VDP. How our /RDY and /WAIT really work together is subject to one of our next sessions where we&rsquo;re going to measure the things with a logic analyzer and oscilloscope. Nevertheless, it works in this way and it works exaclty as specified within the datasheet.</p></div></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2022 Steckschwein.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>