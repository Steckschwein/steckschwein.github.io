<!doctype html><html lang=en><head><title>Fixing PS/2 Keyboard handling (Part I) ::</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:
The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI. The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&amp;rsquo;t the states of the keyboard LEDs."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://beta.steckschwein.de/post/fixing-ps-2-keyboard-handling-part-i/><link rel=stylesheet href=https://beta.steckschwein.de/assets/style.css><link rel=stylesheet href=https://beta.steckschwein.de/assets/green.css><link rel=apple-touch-icon href=https://beta.steckschwein.de/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://beta.steckschwein.de/img/favicon/green.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Fixing PS/2 Keyboard handling (Part I)"><meta property="og:description" content="The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:
The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI. The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&amp;rsquo;t the states of the keyboard LEDs."><meta property="og:url" content="https://beta.steckschwein.de/post/fixing-ps-2-keyboard-handling-part-i/"><meta property="og:site_name" content><meta property="og:image" content="https://beta.steckschwein.de/img/favicon/green.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="allgemein"><meta property="article:published_time" content="2020-11-14 00:00:00 +0000 UTC"></head><body class=green><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Steckschwein</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>The Project</a></li><li><a href=/hardware/>Hardware</a></li><li><a href=/software/>Software</a></li><li><a href=/impressum/>Impressum</a></li><li><a href=/post/>Posts</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>The Project</a></li><li><a href=/hardware/>Hardware</a></li><li><a href=/software/>Software</a></li><li><a href=/impressum/>Impressum</a></li><li><a href=/post/>Posts</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://beta.steckschwein.de/post/fixing-ps-2-keyboard-handling-part-i/>Fixing PS/2 Keyboard handling (Part I)</a></h1><div class=post-meta><span class=post-date>2020-11-14</span></div><div class=post-content><div><p>The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:</p><ul><li>The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI.</li><li>The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&rsquo;t the states of the keyboard LEDs.</li></ul><p>Although mid- to long term, we likely might &ldquo;upgrade&rdquo; to USB anyway, but not without having done PS/2 right first. So, I will talk about integrating IRQ handling, and in a follow up post Marko will talk about how he got the PS/2 controller talking to the keyboard.</p><p>Luckily, during the design of the IO-board, we have been clever enough to hook IO-pins PC0 to PC2 to RESET_TRIG, NMI and IRQ, respectively. So on the hardware-side, we are very much ready.<br>First problem to solve is how to emulate an open collector output on the AVR controller. As it seems, a common way to do that is to disable the internal pullup of the pin, and have it configured as input to be &ldquo;tri state&rdquo;. When active, the pin gets activated as an output, and will pull the IRQ line low.</p><p><code>// pull IRQ line DDRC |= (1 &lt;&lt; IRQ);</code></p><p><code>// release IRQ line DDRC &= ~(1 &lt;&lt; IRQ);</code></p><p>Now that we know how to handle the IRQ-line, we need to figure out, WHEN to pull it. Obviously when a key was hit. And when to release it?</p><p>Finally, we decided to go the most simple way. The PS/2 controller will pull the IRQ line as long as there are more than 0 chars in the buffer. Once the buffer is empty, the IRQ-line will be released. This way, we do not need an interrupt register and hence no time consuming check of the latter, but need to do a little buffering on the steckOS-side.</p><p>This is all the code that&rsquo;s needed on the PS/2 controller side:</p><pre tabindex=0><code>    if (kb_buffcnt &gt; 0)
    {
        DDRC |= (1 &lt;&lt; IRQ);     // pull IRQ line
    }
    else
    {
        DDRC &amp;= ~(1 &lt;&lt; IRQ); // release IRQ line
    }
</code></pre><p>Now, we need to add a little handling code to the steckOS IRQ-handler. Since we do not have an interrupt register, we just check the keyboard last, after every &ldquo;known&rdquo; interrupt source has been handled.<br>To get around having to implement another keyboard buffer, we just use a single memory location, labelled &ldquo;key&rdquo;. The IRQ handler will only fetch a byte from the keyboard when the target location is zero (0), otherwise it will just exit.<br>The system getkey-routine will load the contents from that location into the A register, and overwrite the location with 0 again to enable fetching the next char from the buffer.</p><p>The SPI check code is the last bit in the IRQ-handler routine:</p><pre tabindex=0><code>@check_spi:  
    lda key  
    bne @exit  
    jsr fetchkey  
    bcc @exit  
    sta key  
  
@exit:  
    restore  
    rti
</code></pre><p>That&rsquo;s basically all that&rsquo;s needed. The former getkey-routine has been renamed to fetchkey, and the new getkey routine only handles the ZP buffer location while retaining the old behaviour including setting the carry flag when a byte has been received. This way, existing programs using the keyboard do not have to be modified.</p><p>Now, we finally have a chance of reacting to keystrokes during program execution without having to explicitly poll the keyboard. This enables us to handle Ctrl-C and such much more elegantly. Also, any REPL-like program (like the shell) does not have to constantly poll the SPI bus.</p></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>Â© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://beta.steckschwein.de/assets/main.js></script>
<script src=https://beta.steckschwein.de/assets/prism.js></script></div></body></html>