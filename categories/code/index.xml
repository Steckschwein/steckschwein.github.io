<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>code on</title><link>https://beta.steckschwein.de/categories/code/</link><description>Recent content in code on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 16 Oct 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://beta.steckschwein.de/categories/code/index.xml" rel="self" type="application/rss+xml"/><item><title>Weird bug in SD card code</title><link>https://beta.steckschwein.de/post/weird-bug-in-sd-card-code/</link><pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/weird-bug-in-sd-card-code/</guid><description>Frank van den Hoef, who is adapting the Steckschwein SPI &amp;amp; FAT32 code for his tiny65 machine made me aware of a classic mistake for a 6502 assembly coder to make. Namely in our sdcard driver, when waiting for the &amp;ldquo;proper&amp;rdquo; response from the card (which should have bit 7 cleared). The routine handling this looked like this:
1 sd_cmd_response_wait: 2 ldy #sd_cmd_response_retries 3 @l: dey 4 beq sd_block_cmd_timeout ; y already 0?</description><content>&lt;p>Frank van den Hoef, who is adapting the Steckschwein SPI &amp;amp; FAT32 code for his tiny65 machine made me aware of a classic mistake for a 6502 assembly coder to make. Namely in our sdcard driver, when waiting for the &amp;ldquo;proper&amp;rdquo; response from the card (which should have bit 7 cleared). The routine handling this looked like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>1 sd_cmd_response_wait:
2 ldy #sd_cmd_response_retries
3 @l: dey
4 beq sd_block_cmd_timeout ; y already 0? then invalid response or timeout
5 jsr spi_r_byte
6 bit #80 ; bit 7 clear
7 bne @l ; no, next byte
8 cmp #$00 ; got cmd response, check if $00 to set z flag accordingly
9 rts
10 sd_block_cmd_timeout:
11 debug &amp;#34;sd_block_cmd_timeout&amp;#34;
12 lda #$1f ; make up error code distinct from possible sd card responses to mark timeout
13 rts
&lt;/code>&lt;/pre>&lt;p>Classic. Obviously, line 6 should read:&lt;/p>
&lt;pre tabindex="0">&lt;code> bit #$80 ; bit 7 clear
&lt;/code>&lt;/pre>&lt;p>With that fixed, the sd card init routine now fails, which is odd since we fixed something that was obviously broken.&lt;/p>
&lt;p>&lt;img src="images/sd_fail-e1571229478149.jpg" alt="sd_fail.jpg">&lt;/p>
&lt;p>Ok, now what? Enabling Marko&amp;rsquo;s mighty debugging macros, it becomes apparent that the sd card init fails right after sending CMD0 to the card. This command is the first command of the init sequence and is supposed to put the card into &amp;ldquo;idle mode&amp;rdquo;. Which the card confirms with an answer of $01. Which is what the init code is expecting, and not getting. Instead, we get $3F, which does not make a lot of sense.&lt;/p>
&lt;p>But why did it work before the fix? Assuming that the card did not change it&amp;rsquo;s behaviour at the same time I fixed the code, let&amp;rsquo;s check what actually happened. Before the fix, we were ANDing $3F with 80:&lt;/p>
&lt;p>&lt;code> 00111111 $3f&lt;/code>&lt;br>
&lt;code>01010000 80 (no $, decimal)&lt;/code>&lt;/p>
&lt;p>In this case, the BNE after the BIT #80 would take the branch to @l, causing the next byte being read, until finally the card responds with $01:&lt;/p>
&lt;p>&lt;code> 00000001 $01&lt;/code>&lt;br>
&lt;code>01010000 80 (no $, decimal)&lt;/code>&lt;/p>
&lt;p>Now the BNE does not take the branch, and the routine exits.&lt;/p>
&lt;p>Now, with the fixed code,  ANDing $3F with **$**80, to check if bit 7 is clear, which it is:&lt;/p>
&lt;p>&lt;code> 00111111 $3F&lt;/code>&lt;br>
&lt;code>10000000 $80&lt;/code>&lt;/p>
&lt;p>Alright, exit the loop and return $3f as response of the card. Which isn&amp;rsquo;t $01, so init failed.&lt;/p>
&lt;p>At this point, I have no explanation for the card responding $3F. I assume that the card might be not ready to process commands at this point, so I added code to repeat sending CMD0 until we get $01 or we run out of retries.&lt;/p></content></item><item><title>VCFB 2018 It was great...</title><link>https://beta.steckschwein.de/post/vcfb-2018-its-great/</link><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/vcfb-2018-its-great/</guid><description>VCF 2018 in Berlin was great! We&amp;rsquo;ve met interesting people there. Got a handshake with Scot W. Stevenson who for(th)ced us to use his TaliForth2 ;)
Later on Saturday Daniel Illgen - maintainer of the Adlib Tracker II for Linux - had decided to honor us with his OPL2 knowledge while on the way out. He advised us to keep the OPL2 sound chip on the Steckschwein, because the OPL2 chip is still not outbid.</description><content>&lt;p>VCF 2018 in Berlin was great! We&amp;rsquo;ve met interesting people there. Got a handshake with Scot W. Stevenson who for(th)ced us to use his &lt;a href="https://github.com/scotws/TaliForth2">TaliForth2&lt;/a> ;)&lt;/p>
&lt;p>Later on Saturday &lt;a href="http://www.adlibtracker.net/downloads.php">Daniel Illgen&lt;/a> - maintainer of the Adlib Tracker II for Linux - had decided to honor us with his OPL2 knowledge while on the way out. He advised us to keep the OPL2 sound chip on the Steckschwein, because the OPL2 chip is still not outbid. We hat doubts at first, but then we could listen to OPL2 with so called &amp;ldquo;software low frequency oscillation&amp;rdquo; (soft lfo) and the drums and bass sounds great!&lt;/p>
&lt;p>Beside the VCF there where talks about demos and the history of the demoscene then and now. There where two interesting and awesome talks given by &amp;ldquo;&lt;a href="http://svolli.de/">SvOlli&lt;/a>&amp;rdquo; about the demoscene and demo coding on the Atari VCS (Stella).&lt;/p>
&lt;p>Here are the slides of out talks and Links to the livestream from Saturday 13.10.2018.&lt;/p>
&lt;ul>
&lt;li>Steckschwein - &lt;a href="https://steckschwein.files.wordpress.com/2018/10/the-history.pdf">The history and why it&amp;rsquo;s called &amp;ldquo;Steckschwin&amp;rdquo;&lt;/a>&lt;/li>
&lt;li>Steckschwein - &lt;a href="https://steckschwein.files.wordpress.com/2018/10/asm_tests_ci.pdf">6502 Test Driven Development and Continuous Integration&lt;/a>&lt;/li>
&lt;li>Livestream: &lt;a href="https://media.ccc.de/c/vcfb18">https://vcfb.de/2018/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Many thanks to &lt;a href="http://www.stefan-hoeltgen.de/">Dr. Stefan Höltgen&lt;/a> and his team arround the VCFB which made it possible that we could take a part on that cool event!&lt;/p></content></item><item><title>Euphorie: Jetzt auch RAM!</title><link>https://beta.steckschwein.de/post/euphorie-jetzt-auch-ram/</link><pubDate>Wed, 12 Feb 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/euphorie-jetzt-auch-ram/</guid><description>Die Euphorie ob des Ausgangs des letzten Versuchs nutzend wird jetzt weitergebaut. Immerhin sind wir so nah an einem richtigen Computer. Was fehlt, ist RAM. Leider nichts im Haus.
Eine temporäre Organspende aus einem C64-Easyflash-Cartridge (Cooles Teil: http://skoe.de/easyflash/doku.php?id=start) verschafft uns ein 6264 SRAM. Dieses verdrahten wir analog zum EPROM, allerdings brauche es hier noch einen Hauch von Gatterlogik, um das EEPROM ans obere Ende des Adressraums zu mappen, während das SRAM in den unteren 8k lebt.</description><content>&lt;p>Die Euphorie ob des Ausgangs des letzten Versuchs nutzend wird jetzt weitergebaut. Immerhin sind wir so nah an einem richtigen Computer. Was fehlt, ist RAM. Leider nichts im Haus.&lt;/p>
&lt;p>Eine temporäre Organspende aus einem C64-Easyflash-Cartridge (Cooles Teil: &lt;a href="http://skoe.de/easyflash/doku.php?id=start">http://skoe.de/easyflash/doku.php?id=start&lt;/a>) verschafft uns ein 6264 SRAM. Dieses verdrahten wir analog zum EPROM, allerdings brauche es hier noch einen Hauch von Gatterlogik, um das EEPROM ans obere Ende des Adressraums zu mappen, während das SRAM in den unteren 8k lebt.&lt;/p>
&lt;p>Der Testcode wird um einige JSR und RTS erweitert (Stack!). Eine grüne LED an der RW-Leitung zeigt uns Schreibzugriffe an.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/zjhkhsHbYMg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></content></item><item><title>Mehr Mut: Es werde Code!</title><link>https://beta.steckschwein.de/post/mehr-mut-es-werde-code/</link><pubDate>Wed, 12 Feb 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/mehr-mut-es-werde-code/</guid><description>Nachdem uns nach einiger Zeit dann doch langweilig wurde, den Prozessor beim NOPs ausführen zu beobachten musste der nächste Kick her: Es soll Code ausführen! Also ein wenig Code geschrieben (dieser ist leider nicht überliefert, enthielt lediglich einige NOPs und JMPs, gerade genug also, um uns in blanke Verzückung zu versetzen), auf ein 27128 EPROM gebrannt und an Adress- und Datenbus angeschlossen. /OE und /CS des EPROM wurden einfach auf Masse gelegt.</description><content>&lt;p>Nachdem uns nach einiger Zeit dann doch langweilig wurde, den Prozessor beim NOPs ausführen zu beobachten musste der nächste Kick her: Es soll Code ausführen! Also ein wenig Code geschrieben (dieser ist leider nicht überliefert, enthielt lediglich einige NOPs und JMPs, gerade genug also, um uns in blanke Verzückung zu versetzen), auf ein 27128 EPROM gebrannt und an Adress- und Datenbus angeschlossen. /OE und /CS des EPROM wurden einfach auf Masse gelegt. Adressleitungen A0-A12 des EPROM wurden mit dem Adressbus des Prozessors verbunden, die verbliebenen Adressleitungen des Prozessors blieben frei. Also haben wir nun 8k ROM, die sich innerhalb der 64k Adressraum des 65c02 8 mal wiederholen.&lt;/p>
&lt;p>Um das visuelle Erleben intensiver zu gestalten wurde der Datenbus mit Hilfe eines 74ls245 und 8 roter LEDs ebenfalls sichtbar gemacht. Für den Takt sorgt mittlerweile ein Rechteckgenerator auf NE555-Basis, der beschauliche 500Hz liefert.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/z5xyLgUeEcM" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></content></item></channel></rss>