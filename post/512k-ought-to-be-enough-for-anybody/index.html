<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.ico><title>512k Ought to Be Enough for Anybody - Steckschwein</title><meta name=description content="The biggest limitation of any 8 bit CPU such as our beloved 65C02 is the amount of memory that the CPU can address. With 16 address lines, the addressable memory is maxed out at 64k. All ROM and RAM has to be crammed into there. With the 6502 being a memory mapped architecture, IO devices need their addresses there, too.
In order to expand the amount of usable memory, some trickery is necessary."><meta name=generator content="Hugo 0.101.0"><link rel=stylesheet href=https://steckschwein.github.io/css/main.css><meta property="og:title" content="512k Ought to Be Enough for Anybody"><meta property="og:description" content="The biggest limitation of any 8 bit CPU such as our beloved 65C02 is the amount of memory that the CPU can address. With 16 address lines, the addressable memory is maxed out at 64k. All ROM and RAM has to be crammed into there. With the 6502 being a memory mapped architecture, IO devices need their addresses there, too.
In order to expand the amount of usable memory, some trickery is necessary."><meta property="og:type" content="article"><meta property="og:url" content="https://steckschwein.github.io/post/512k-ought-to-be-enough-for-anybody/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-27T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-27T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="512k Ought to Be Enough for Anybody"><meta name=twitter:description content="The biggest limitation of any 8 bit CPU such as our beloved 65C02 is the amount of memory that the CPU can address. With 16 address lines, the addressable memory is maxed out at 64k. All ROM and RAM has to be crammed into there. With the 6502 being a memory mapped architecture, IO devices need their addresses there, too.
In order to expand the amount of usable memory, some trickery is necessary."><meta itemprop=name content="512k Ought to Be Enough for Anybody"><meta itemprop=description content="The biggest limitation of any 8 bit CPU such as our beloved 65C02 is the amount of memory that the CPU can address. With 16 address lines, the addressable memory is maxed out at 64k. All ROM and RAM has to be crammed into there. With the 6502 being a memory mapped architecture, IO devices need their addresses there, too.
In order to expand the amount of usable memory, some trickery is necessary."><meta itemprop=datePublished content="2022-05-27T00:00:00+00:00"><meta itemprop=dateModified content="2022-05-27T00:00:00+00:00"><meta itemprop=wordCount content="834"><meta itemprop=keywords content><meta itemprop=name content="512k Ought to Be Enough for Anybody"><meta itemprop=description content="The biggest limitation of any 8 bit CPU such as our beloved 65C02 is the amount of memory that the CPU can address. With 16 address lines, the addressable memory is maxed out at 64k. All ROM and RAM has to be crammed into there. With the 6502 being a memory mapped architecture, IO devices need their addresses there, too.
In order to expand the amount of usable memory, some trickery is necessary."><meta itemprop=datePublished content="2022-05-27T00:00:00+00:00"><meta itemprop=dateModified content="2022-05-27T00:00:00+00:00"><meta itemprop=wordCount content="834"><meta itemprop=keywords content></head><body class="flex relative h-full min-h-screen"><aside class="will-change-transform transform transition-transform -translate-x-full absolute top-0 left-0 md:relative md:translate-x-0 w-3/4 md:w-60 h-full min-h-screen p-3 bg-slate-50 dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 flex flex-col gap-2.5 z-20 sidebar"><p class="font-bold mb-5 flex items-center gap-2"><button aria-label="Close sidebar" class="md:hidden menu-trigger-close p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-6 w-6" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
<a href=https://steckschwein.github.io class=px-2><span>Steckschwein</span></a>
<button aria-label="Toggle dark mode" class="dark-mode-toggle p-2 rounded border dark:border-slate-700 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-4 w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="4"/><path d="M3 12h1m8-9v1m8 8h1m-9 8v1M5.6 5.6l.7.7m12.1-.7-.7.7m0 11.4.7.7M6.3 17.7l-.7.7"/></svg></button></p><ul class="list-none flex flex-col gap-1"><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/home/><span>The Project</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/hardware/><span>Hardware</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/software/><span>Software</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/impressum/><span>Impressum</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/articles/><span>Articles</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/post/><span>Posts</span></a></li></ul><div class=flex-1></div><ul class="list-none flex flex-wrap justify-center gap-1 pt-2 border-t border-slate-200 dark:border-slate-600"></ul></aside><div class="fixed bg-slate-700 bg-opacity-5 transition duration-200 ease-in-out inset-0 z-10 pointer-events-auto md:hidden left-0 top-0 w-full h-full hidden menu-overlay"></div><button aria-label="Toggle Sidebar" class="md:hidden absolute top-3 left-3 z-10 menu-trigger p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-100"><svg class="h-6 w-6" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="18" x2="16" y2="18"/></svg></button><div class=flex-1><main class="h-screen overflow-y-auto"><div class="px-6 py-20 w-full lg:w-[580px] mx-auto prose dark:prose-invert h-fit prose-img:mx-auto"><h1>512k Ought to Be Enough for Anybody</h1><p class="text-sm text-slate-500 !mb-8">May 27, 2022</p><p>The biggest limitation of any 8 bit CPU such as our beloved 65C02 is the amount of memory that the CPU can address. With 16 address lines, the addressable memory is maxed out at 64k. All ROM and RAM has to be crammed into there. With the 6502 being a memory mapped architecture, IO devices need their addresses there, too.</p><p>In order to expand the amount of usable memory, some trickery is necessary. For example, the developers of the C64 came up with a rather clever hack to cram 20k of ROM and full 64k of RAM and IO area into 64k address space by introducing a register that enables the programmer to switch off the ROM, giving access to the underlying RAM. When the ROM is enabled, writes to the addresses go into the RAM below.
We decided to mimic this behaviour in our current implementation of the Steckschwein glue logic.</p><p>But it’s time to move on. More sophisticated 8bit machines such as the C128 or the CPC6128 have a more clever banking logic to give the CPU more than 64k to work with. The C128 even has a MMU. The next logical step for the Steckschwein is to have a MMU, too.
We decided to reimplement our glue logic from scratch using a CPLD and expand our memory space in the process.</p><p>We decided to go for 512k RAM. In order to address that much memory, the first thing we need to add are three more address lines. That’s where the CPLD comes in. In order to cut the 512k ram into smaller banks, so we can easier address them, the CPLD does not only provide the address lines A16 – A18, but also doubles the address lines A14-A15. Address lines A0-A15 from the CPU go to the CPLD to be decoded. RAM and ROM only see A0-A13 from the CPU and A14-A18 from the CPLD.
This way we can split the 512k into 32 banks of 16k each. The 64k address space of the Steckschwein is now organized as four “slots” with 16k each.
Four registers in the CPLD, which are mapped into the IO area contain the values for the extra address lines and are used as selectors for which bank is mapped into which slot. Bit 7 will select ROM instead of RAM, so that ROM banks are being handled just like another memory page. Also, this means a departure from our 8k ROM bank size.
We might upgrade the 32k 28C256 EEPROM to a 512k Flash EEPROM in one of the next iterations, giving us 32 RAM and 32 ROM banks. Also, adding another address line is not a big deal, so upgrading to 1MB will be easy.</p><table><thead><tr><th style=text-align:center>Slot</th><th style=text-align:center>Start</th><th style=text-align:center>End</th></tr></thead><tbody><tr><td style=text-align:center>0</td><td style=text-align:center>$0000</td><td style=text-align:center>$3fff</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>$4000</td><td style=text-align:center>$7fff</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>$8000</td><td style=text-align:center>$bfff</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>$c000</td><td style=text-align:center>$ffff</td></tr><tr><td style=text-align:center>The 4 Slots within the 64k address space</td><td></td><td></td></tr></tbody></table><pre tabindex=0><code>Slot 0   Slot 1   Slot 2    Slot3
+--------+
|Bank 81*|
+--------+
|Bank 80*|
+-----------------+
|  ....  |Bank 81 |
+-----------------+
|Bank 4  |  ...   |
+--------------------------+
|Bank 3  |Bank 3  |Bank 81*|
+--------------------------+
|Bank 1  |Bank 2  |Bank 80*|
+-----------------------------------+
|Bank 0  |Bank 1  |Bank 30 |Bank 81*|
+-----------------------------------+
         |Bank 0  |Bank 29 |Bank 80*|
         +--------------------------+
                  |Bank 28 |Bank 30 |
                   -----------------+
                  |Bank 27 |Bank 29 |
                  +-----------------+
                  |Bank 26 |Bank 28 |
                  +-----------------+
                  |Bank 25 |Bank 27 |
                  +-----------------+
                  |  ....  |Bank 26 |
                  +-----------------+
                  |Bank 0  |Bank 25 |
                  +-----------------+
                           |  ....  |
                           +--------+
                           |Bank 0  |
                           +--------+


*=ROM     
</code></pre><p>The above illustration shows how the Slot selection scheme works. It is also possible to map the same bank into all four slots.</p><p>In order to be able to execute the RESET Vector the CPU requires ROM being present in Slot 3 at system start time. So the default bank assignment looks like this:</p><p>Slot 0 Bank 0
Slot 1 Bank 1
Slot 2 Bank 2
Slot 3 Bank 80
Default bank assignment at boot</p><p>We do not need the ROMOFF mechanism anymore, so the loading of steckOS will follow a different procedure:</p><pre><code>System bootup with bank $80 (ROM) in slot 3
Bootloader switches slot 2 to bank 3 (or whatever bank the OS shall be in)
Bootloader writes steckOS to slot 2 ($8000)
Bootloader switches slot 3 to bank 3
Bootloader jumps to steckOS init
</code></pre><p>This memory banking scheme is rather simple, but provides a lot of flexibility in order to use more than 64k of memory. Also, all kinds of memory (ROM, RAM) are being treated the same way, so it’s much more cleaner than the ROMOFF approach. Being able to remap the area containing the zero page and stack will also help implementing some sort of task switching or even multitasking.
On the downside, it’s flexible but pretty dumb as the software has to keep track of what has been put in which bank.
We a really eager to explore this idea, so the VHDL code for the XC9672 CPLD has been written, the board has been designed and waiting to be delivered.</p></div></main></div><script type=text/javascript src=/main.js defer></script></body></html>