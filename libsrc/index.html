<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>- Steckschwein</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content><meta property="og:description" content="Modules fat32 | joystick | keyboard | sdcard | spi | uart | util | vdp |
fat32 fat_chdir | fat_close | fat_find_first | fat_find_next | fat_fopen | fat_fread_byte | fat_get_root_and_pwd | fat_mkdir | fat_mount | fat_opendir | fat_readdir | fat_rmdir | fat_unlink | fat_write_byte |
fat_chdir change current directoryreaddir expects a pointer in A/Y to store the next F32DirEntry structure representing the next FAT32 directory entry in the directory stream pointed of directory X."><meta property="og:type" content="article"><meta property="og:url" content="https://www.steckschwein.de/libsrc/"><meta property="article:section" content><meta itemprop=name content><meta itemprop=description content="Modules fat32 | joystick | keyboard | sdcard | spi | uart | util | vdp |
fat32 fat_chdir | fat_close | fat_find_first | fat_find_next | fat_fopen | fat_fread_byte | fat_get_root_and_pwd | fat_mkdir | fat_mount | fat_opendir | fat_readdir | fat_rmdir | fat_unlink | fat_write_byte |
fat_chdir change current directoryreaddir expects a pointer in A/Y to store the next F32DirEntry structure representing the next FAT32 directory entry in the directory stream pointed of directory X."><meta itemprop=wordCount content="1115"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Modules fat32 | joystick | keyboard | sdcard | spi | uart | util | vdp |
fat32 fat_chdir | fat_close | fat_find_first | fat_find_next | fat_fopen | fat_fread_byte | fat_get_root_and_pwd | fat_mkdir | fat_mount | fat_opendir | fat_readdir | fat_rmdir | fat_unlink | fat_write_byte |
fat_chdir change current directoryreaddir expects a pointer in A/Y to store the next F32DirEntry structure representing the next FAT32 directory entry in the directory stream pointed of directory X."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=Steckschwein rel=home><div class="logo__item logo__text"><div class=logo__title>Steckschwein</div><div class=logo__tagline>An 8bit computer for the 21st century</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li><li class=menu__item><a class=menu__link href=/><span class=menu__text>Blog</span></a></li><li class=menu__item><a class=menu__link href=/hardware/><span class=menu__text>Hardware</span></a></li><li class=menu__item><a class=menu__link href=/software/><span class=menu__text>Software</span></a></li><li class=menu__item><a class=menu__link href=/resources/><span class=menu__text>Resources</span></a></li><li class=menu__item><a class=menu__link href=/impressum/><span class=menu__text>Impressum</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title></h1></header><div class="content post__content clearfix"><h1 id=modules>Modules</h1><p><a href=#fat32>fat32</a> | <a href=#joystick>joystick</a> | <a href=#keyboard>keyboard</a> | <a href=#sdcard>sdcard</a> | <a href=#spi>spi</a> | <a href=#uart>uart</a> | <a href=#util>util</a> | <a href=#vdp>vdp</a> |</p><hr><h2 id=fat32>fat32</h2><p><a href=#fat_chdir>fat_chdir</a> | <a href=#fat_close>fat_close</a> | <a href=#fat_find_first>fat_find_first</a> | <a href=#fat_find_next>fat_find_next</a> | <a href=#fat_fopen>fat_fopen</a> | <a href=#fat_fread_byte>fat_fread_byte</a> | <a href=#fat_get_root_and_pwd>fat_get_root_and_pwd</a> | <a href=#fat_mkdir>fat_mkdir</a> | <a href=#fat_mount>fat_mount</a> | <a href=#fat_opendir>fat_opendir</a> | <a href=#fat_readdir>fat_readdir</a> | <a href=#fat_rmdir>fat_rmdir</a> | <a href=#fat_unlink>fat_unlink</a> | <a href=#fat_write_byte>fat_write_byte</a> |</p><hr><h3 id=fat_chdir>fat_chdir</h3><blockquote><p>change current directoryreaddir expects a pointer in A/Y to store the next F32DirEntry structure representing the next FAT32 directory entry in the directory stream pointed of directory X.</p></blockquote><dl><dt>In</dt><dd>A, low byte of pointer to zero terminated string with the file path<br>X, high byte of pointer to zero terminated string with the file path</dd><dt>Out</dt><dd>C, C=0 on success (A=0), C=1 and A=<error code> otherwise<br>X, index into fd_area of the opened directory (which is FD_INDEX_CURRENT_DIR)</dd></dl><h3 id=fat_close>fat_close</h3><blockquote><p>close file, update dir entry and free file descriptor quietly</p></blockquote><dl><dt>In</dt><dd>X, index into fd_area of the opened file</dd><dt>Out</dt><dd>C, 0 on success, 1 on error<br>A, error code</dd></dl><h3 id=fat_find_first>fat_find_first</h3><blockquote><p>find first dir entry</p></blockquote><dl><dt>In</dt><dd>A, low byte of pointer to zero terminated string with the file path<br>Y, high byte of pointer to zero terminated string with the file path<br>X, file descriptor (index into fd_area) of the directory</dd><dt>Out</dt><dd>Z, 1 on success, 0 on error<br>A, error code<br>C, 0 if found and dirptr is set to the dir entry found (requires Z=1), else 1</dd></dl><h3 id=fat_find_next>fat_find_next</h3><blockquote><p>find next dir entry</p></blockquote><dl><dt>In</dt><dd>X, file descriptor (index into fd_area) of the directory</dd><dt>Out</dt><dd>A, error code<br>C, 0 on success (A=0), C=1 and A=<error code>, else 1</dd></dl><h3 id=fat_fopen>fat_fopen</h3><blockquote><p>open file</p></blockquote><dl><dt>In</dt><dd>A, low byte of pointer to zero terminated string with the file path<br>X, high byte of pointer to zero terminated string with the file path<br>Y, file mode constants O_RDONLY = $01, O_WRONLY = $02, O_RDWR = $03, O_CREAT = $10, O_TRUNC = $20, O_APPEND = $40, O_EXCL = $80</dd><dt>Out</dt><dd>C, 0 on success, 1 on error<br>A, error code<br>X, index into fd_area of the opened file</dd></dl><h3 id=fat_fread_byte>fat_fread_byte</h3><blockquote><p>read byte from file</p></blockquote><dl><dt>In</dt><dd>X, offset into fs area</dd><dt>Out</dt><dd>C, 0 on success, 1 on error<br>A, received byte</dd></dl><h3 id=fat_get_root_and_pwd>fat_get_root_and_pwd</h3><blockquote><p>get current directory</p></blockquote><dl><dt>In</dt><dd>A, low byte of address to write the current work directory string into<br>Y, high byte address to write the current work directory string into<br>X, size of result buffer pointet to by A/X</dd><dt>Out</dt><dd>C, 0 on success, 1 on error<br>A, error code</dd></dl><h3 id=fat_mkdir>fat_mkdir</h3><blockquote><p>create directory denoted by given path in A/X</p></blockquote><dl><dt>In</dt><dd>A, low byte of pointer to directory string<br>X, high byte of pointer to directory string</dd><dt>Out</dt><dd>C, 0 on success, 1 on error<br>A, error code</dd></dl><h3 id=fat_mount>fat_mount</h3><blockquote><p>mount fat32 file system</p></blockquote><dl><dt>Out</dt><dd>C, 0 on success, 1 on error<br>A, error code</dd></dl><h3 id=fat_opendir>fat_opendir</h3><blockquote><p>open directory by given path starting from directory given as file descriptor</p></blockquote><dl><dt>In</dt><dd>A, low byte of pointer to zero terminated string with the file path<br>X, high byte of pointer to zero terminated string with the file path</dd><dt>Out</dt><dd>C, C=0 on success (A=0), C=1 and A=<error code> otherwise<br>X, index into fd_area of the opened directory</dd></dl><h3 id=fat_readdir>fat_readdir</h3><blockquote></blockquote><dl><dt>In</dt><dd>X - file descriptor to fd_area of the directory<br>A/Y - pointer to target buffer which must be .sizeof(F32DirEntry)</dd><dt>Out</dt><dd>C - C = 0 on success (A=0), C = 1 and A = <error code>otherwise</dd></dl><h3 id=fat_rmdir>fat_rmdir</h3><blockquote><p>delete a directory entry denoted by given path in A/X</p></blockquote><dl><dt>In</dt><dd>A, low byte of pointer to directory string<br>X, high byte of pointer to directory string</dd><dt>Out</dt><dd>C, 0 on success, 1 on error<br>A, error code</dd></dl><h3 id=fat_unlink>fat_unlink</h3><blockquote><p>unlink (delete) a file denoted by given path in A/X</p></blockquote><dl><dt>In</dt><dd>A, low byte of pointer to zero terminated string with the file path<br>X, high byte of pointer to zero terminated string with the file path</dd><dt>Out</dt><dd>C, C=0 on success (A=0), C=1 and A=<error code> otherwise</dd></dl><h3 id=fat_write_byte>fat_write_byte</h3><blockquote><p>write byte to file</p></blockquote><dl><dt>In</dt><dd>A, byte to write<br>X, offset into fs area</dd><dt>Out</dt><dd>C, 0 on success, 1 on error</dd></dl><hr><h2 id=joystick>joystick</h2><p><a href=#joystick_detect>joystick_detect</a> | <a href=#joystick_read>joystick_read</a> |</p><hr><h3 id=joystick_detect>joystick_detect</h3><blockquote><p>detect joystick</p></blockquote><dl><dt>Out</dt><dd>Z, Z=1 no joystick detected, Z=0 joystick detected, port in A<br>A, detected joystick port, JOY_PORT1 or JOY_PORT2</dd></dl><h3 id=joystick_read>joystick_read</h3><blockquote><p>read state of specified joystick</p></blockquote><dl><dt>Out</dt><dd>A, joystick button state - bit 0-4</dd></dl><hr><h2 id=keyboard>keyboard</h2><p><a href=#fetchkey>fetchkey</a> | <a href=#getkey>getkey</a> |</p><hr><h3 id=fetchkey>fetchkey</h3><blockquote><p>fetch byte from keyboard controller</p></blockquote><dl><dt>Out</dt><dd>A, fetched key / error code<br>C, 1 - key was fetched, 0 - nothing fetched</dd></dl><h3 id=getkey>getkey</h3><blockquote><p>get byte from keyboard buffer</p></blockquote><dl><dt>Out</dt><dd>A, fetched key<br>C, 1 - key was fetched, 0 - nothing fetched</dd></dl><hr><h2 id=sdcard>sdcard</h2><p><a href=#sd_busy_wait>sd_busy_wait</a> | <a href=#sd_cmd>sd_cmd</a> | <a href=#sd_deselect_card>sd_deselect_card</a> | <a href=#sd_read_block>sd_read_block</a> | <a href=#sd_select_card>sd_select_card</a> | <a href=#sdcard_init>sdcard_init</a> |</p><hr><h3 id=sd_busy_wait>sd_busy_wait</h3><blockquote><p>wait while sd card is busy</p></blockquote><dl><dt>Out</dt><dd>C, C = 0 on success, C = 1 on error (timeout)</dd><dt>Clobbers</dt><dd>A,X,Y</dd></dl><h3 id=sd_cmd>sd_cmd</h3><blockquote><p>send command to sd card</p></blockquote><dl><dt>In</dt><dd>A, command byte<br>sd_cmd_param, command parameters</dd><dt>Out</dt><dd>A, SD Card R1 status byte</dd><dt>Clobbers</dt><dd>A,X,Y</dd></dl><h3 id=sd_deselect_card>sd_deselect_card</h3><blockquote><p>Read block from SD Card</p></blockquote><dl><dt>Out</dt><dd>A, error code<br>C, 0 - success, 1 - error</dd><dt>Clobbers</dt><dd>X</dd></dl><h3 id=sd_read_block>sd_read_block</h3><blockquote><p>Read block from SD Card</p></blockquote><dl><dt>In</dt><dd>lba_addr, LBA address of block<br>sd_blkptr, target adress for the block data to be read</dd><dt>Out</dt><dd>A, error code<br>C, 0 - success, 1 - error</dd><dt>Clobbers</dt><dd>A,X,Y</dd></dl><h3 id=sd_select_card>sd_select_card</h3><blockquote><p>select sd card, pull CS line to low with busy wait</p></blockquote><dl><dt>Out</dt><dd>C, C = 0 on success, C = 1 on error (timeout)</dd><dt>Clobbers</dt><dd>A,X,Y</dd></dl><h3 id=sdcard_init>sdcard_init</h3><blockquote><p>initialize sd card in SPI mode</p></blockquote><dl><dt>Out</dt><dd>Z,1 on success, 0 on error<br>A, error code</dd><dt>Clobbers</dt><dd>A,X,Y</dd></dl><hr><h2 id=spi>spi</h2><p><a href=#spi_r_byte>spi_r_byte</a> | <a href=#spi_rw_byte>spi_rw_byte</a> |</p><hr><h3 id=spi_r_byte>spi_r_byte</h3><blockquote><p>read byte via SPI</p></blockquote><dl><dt>Out</dt><dd>A, received byte</dd><dt>Clobbers</dt><dd>A,X</dd></dl><h3 id=spi_rw_byte>spi_rw_byte</h3><blockquote><p>transmit byte via SPI</p></blockquote><dl><dt>In</dt><dd>A, byte to transmit</dd><dt>Out</dt><dd>A, received byte</dd><dt>Clobbers</dt><dd>A,X,Y</dd></dl><hr><h2 id=uart>uart</h2><p><a href=#uart_init>uart_init</a> | <a href=#uart_rx>uart_rx</a> | <a href=#uart_rx_nowait>uart_rx_nowait</a> | <a href=#uart_tx>uart_tx</a> |</p><hr><h3 id=uart_init>uart_init</h3><blockquote><p>initialize UART with parameters from nvram</p></blockquote><dl><dt>Clobbers</dt><dd>A,X,Y</dd></dl><h3 id=uart_rx>uart_rx</h3><blockquote><p>receive byte</p></blockquote><dl><dt>Out</dt><dd>A, received byte</dd></dl><h3 id=uart_rx_nowait>uart_rx_nowait</h3><blockquote><p>receive byte, no wait</p></blockquote><dl><dt>Out</dt><dd>A, received byte<br>C, 0 - no byte received, 1 - received byte</dd></dl><h3 id=uart_tx>uart_tx</h3><blockquote><p>send byte</p></blockquote><dl><dt>In</dt><dd>A, byte to send</dd></dl><hr><h2 id=util>util</h2><p><a href=#atoi>atoi</a> | <a href=#b2ad>b2ad</a> | <a href=#b2ad2>b2ad2</a> | <a href=#bin2dual>bin2dual</a> | <a href=#hexout>hexout</a> | <a href=#hextodec>hextodec</a> | <a href=#strout>strout</a> |</p><hr><h3 id=atoi>atoi</h3><blockquote><p>convert ascii digit to binary</p></blockquote><dl><dt>In</dt><dd>A, value to convert</dd><dt>Out</dt><dd>A, binary number</dd></dl><h3 id=b2ad>b2ad</h3><blockquote><p>output 8bit value as 2 digit decimal</p></blockquote><dl><dt>In</dt><dd>A, value to output</dd></dl><h3 id=b2ad2>b2ad2</h3><blockquote><p>output 8bit value as 3 digit decimal</p></blockquote><dl><dt>In</dt><dd>A, value to output</dd></dl><h3 id=bin2dual>bin2dual</h3><blockquote><p>output 8bit value as binary string</p></blockquote><dl><dt>In</dt><dd>A, value to output</dd></dl><h3 id=hexout>hexout</h3><blockquote><p>output 8bit value as hex</p></blockquote><dl><dt>In</dt><dd>A, value to convert</dd></dl><h3 id=hextodec>hextodec</h3><blockquote><p>8bit hex to decimal converter</p></blockquote><dl><dt>In</dt><dd>A, value to convert</dd><dt>Out</dt><dd>A, ones<br>X, tens<br>Y, hundreds</dd></dl><h3 id=strout>strout</h3><blockquote><p>Output string on active output device</p></blockquote><dl><dt>In</dt><dd>A, lowbyte of string address<br>X, highbyte of string address</dd></dl><hr><h2 id=vdp>vdp</h2><p><a href=#vdp_wait_cmd>vdp_wait_cmd</a> |</p><hr><h3 id=vdp_wait_cmd>vdp_wait_cmd</h3><blockquote><p>wait until a pending command has been finished</p></blockquote><dl><dt>In</dt><dd><ul><li></li></ul></dd><dt>Out</dt><dd><ul><li></li></ul></dd></dl><hr></div></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2024 Steckschwein.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>