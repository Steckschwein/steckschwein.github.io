<!doctype html><html lang=en><head><title>FanTASTische Reise II :: Steckschwein</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Vor einer Weile haben wir im Beitrag /index.php/2014/12/15/eine-fantastische-reise/ den Weg zu unserem aktuellen Tastaturcontroller beschrieben.
Wer nicht nochmal nachlesen möchte: Ein ATmega8 dient als SPI Slave als Interface zwischen PS/2-Protokoll, Tastaturmapping und Puffer. Als Basis dient eine angepasste Version des Codes aus AVR Application Note 313, die als Ausgabeschnittstelle den USART des ATmega8 vorsieht. Dies haben wir durch das SPI-Interface des AVR ersetzt.
Steckschwein-Seitig haben wir die Tastaturabfrage immer im Blank-Interrupt des Videochips vorgenommen, genauer gesagt, jeden zweiten Blank."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://www.steckschwein.de/post/fantastische-reise-ii/><link rel=stylesheet href=https://www.steckschwein.de/assets/style.css><link rel=stylesheet href=https://www.steckschwein.de/assets/green.css><link rel=apple-touch-icon href=https://www.steckschwein.de/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://www.steckschwein.de/img/favicon/green.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="FanTASTische Reise II"><meta property="og:description" content="Vor einer Weile haben wir im Beitrag /index.php/2014/12/15/eine-fantastische-reise/ den Weg zu unserem aktuellen Tastaturcontroller beschrieben.
Wer nicht nochmal nachlesen möchte: Ein ATmega8 dient als SPI Slave als Interface zwischen PS/2-Protokoll, Tastaturmapping und Puffer. Als Basis dient eine angepasste Version des Codes aus AVR Application Note 313, die als Ausgabeschnittstelle den USART des ATmega8 vorsieht. Dies haben wir durch das SPI-Interface des AVR ersetzt.
Steckschwein-Seitig haben wir die Tastaturabfrage immer im Blank-Interrupt des Videochips vorgenommen, genauer gesagt, jeden zweiten Blank."><meta property="og:url" content="https://www.steckschwein.de/post/fantastische-reise-ii/"><meta property="og:site_name" content="Steckschwein"><meta property="og:image" content="https://www.steckschwein.de/img/favicon/green.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="avr"><meta property="article:section" content="debugging"><meta property="article:section" content="ps-2"><meta property="article:section" content="spi"><meta property="article:section" content="tastatur"><meta property="article:section" content="uart"><meta property="article:published_time" content="2015-09-22 00:00:00 +0000 UTC"></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Steckschwein</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/hardware/>Hardware</a></li><li><a href=/software/>Software</a></li><li><a href=/impressum/>Impressum</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/hardware/>Hardware</a></li><li><a href=/software/>Software</a></li><li><a href=/impressum/>Impressum</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://www.steckschwein.de/post/fantastische-reise-ii/>FanTASTische Reise II</a></h1><div class=post-meta><span class=post-date>2015-09-22</span></div><div class=post-content><div><p>Vor einer Weile haben wir im Beitrag <a href=/index.php/2014/12/15/eine-fantastische-reise/>/index.php/2014/12/15/eine-fantastische-reise/</a> den Weg zu unserem aktuellen Tastaturcontroller beschrieben.</p><p>Wer nicht nochmal nachlesen möchte: Ein ATmega8 dient als SPI Slave als Interface zwischen PS/2-Protokoll, Tastaturmapping und Puffer. Als Basis dient eine angepasste Version des Codes aus AVR Application Note 313, die als Ausgabeschnittstelle den USART des ATmega8 vorsieht. Dies haben wir durch das SPI-Interface des AVR ersetzt.</p><p>Steckschwein-Seitig haben wir die Tastaturabfrage immer im Blank-Interrupt des Videochips vorgenommen, genauer gesagt, jeden zweiten Blank. Damit wurde der AVR auf SPI-Seite relativ wenig gestresst.</p><p>Eigentlich aber wollen wir nur eine Tastaturabfrage durchführen, wenn wir auch tatsächlich etwas vom User erwarten. Also raus mit der Abfrage aus der IRQ-Routine und das SPI-Interface des AVR gepollt, bis es etwas anderes als $00 liefert. Hierbei trat ein altes Problem wieder zutage, nämlich das sporadisch Tastendrücke &ldquo;verlorengehen&rdquo;. Die ATmega8-Firmware bedarf also noch weiterer Betrachtung.</p><p>Der Code aus Appnote 313 funktioniert grob so, dass die CLK-Leitung des PS/2-Interfaces einen Interrupt triggert. Hat diese 11 Bit(Startbit, 8 Datenbits, Paritätsbit, Stopbit) empfangen, wird noch in der ISR-Routine die Decodierung der Scancodes zu einem ASCII-Wert aufgerufen und dieser im Puffer abgelegt. Dieser ASCII-Wert wird gepuffert und über den USART per rs232 ausgegeben. Unser Ansatz war, den USART-Teil durch einen SPI-Slave zu ersetzen. Dies haben wir 1:1 getan, sodass der SPI-Slave immer nur an einer bestimmten Stelle innerhalb der main()-Schleife bedient wurde.</p><p>Erschwerend kommt hinzu, dass der INT0-Interrupt nach erfolgreicher Übertragung eines kompletten Bytes direkt die Dekodierung vorgenommen hat. Diese beinhaltet einen relativ teuren Lookup des Scancodes aus einer Tabelle im NVRAM.</p><p>Zunächst also haben wir dies entkoppelt, indem wir einen weiteren Puffer für die Scancodes implementiert haben. Der INT0-Interrupt nimmt also nur noch die Scancodes der Tastatur entgegen und stopft sie in einen Puffer. Das Dekodieren der Scancodes haben wir in die Hauptschleife verlegt, denn dieser Vorgang ist nicht zeitkritisch und kann problemlos durch Interrupts unterbrochen werden. Das Ergebnis der Dekodierung landet wie gehabt im Tastaturpuffer.</p><p>Nun ist es so, das ein SPI-Slave nicht wissen kann, wann der Master einen Transfer initiiert. Ergo muss der Slave jederzeit übertragungsbereit sein. Durch ein Bedienen des SPI-Datenregisters SPDR und Warten (polling) auf einen Zustandswechsel des SPI-Interrupt-Flags kann diese Anforderung nicht erfüllt werden. Also müssen wie die SPI-Schnittstelle auch über Interrupt bedienen. Die SPI-ISR-Routine holt also jetzt jedesmal das aktuelle Zeichen oder eben &ldquo;0&rdquo; aus dem Puffer und legt den Wert ins SPI-Datenegister.</p><p>Jetzt gehen auch beim direkten Polling keine Tastendrücke mehr verloren. Nach einigen Optimierungen im Code konnte auch die Taktfrequenz des AVR-Controllers von 8MHz auf 4MHz heruntergesetzt werden.</p><p>Als nächstes wollen wir dem Tastaturcontroller beibringen, wie man Daten zu Tastatur sendet, um etwa die Wiederholrate zu konfigurieren oder die LEDs anzusteuern (Num Lock, Caps Lock, etc.).</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://www.steckschwein.de/post/umstaendliche-portierung-von-ehbasic/><span class=button__icon>←</span>
<span class=button__text>Umständliche Portierung von EhBasic</span></a></span>
<span class="button next"><a href=https://www.steckschwein.de/post/ein-spiel-entsteht/><span class=button__text>Ein Spiel entsteht...</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://www.steckschwein.de/assets/main.js></script>
<script src=https://www.steckschwein.de/assets/prism.js></script></div></body></html>