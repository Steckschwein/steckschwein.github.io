<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>experiment on Steckschwein</title><link>https://www.steckschwein.de/categories/experiment/</link><description>Recent content in experiment on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 15 Jan 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://www.steckschwein.de/categories/experiment/index.xml" rel="self" type="application/rss+xml"/><item><title>Connecting SNES Controller to the Steckschwein</title><link>https://www.steckschwein.de/post/connecting-snes-controller-to-the-steckschwein/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/connecting-snes-controller-to-the-steckschwein/</guid><description>Recently, Michael Steil published a blog post about connecting NES and SNES Controller to a 6502-based system showing how to use NES and SNES controllers on a C64 without the need for any special hardware, by just connecting them to the C64&amp;rsquo;s user port.
Why not use his approach and adapt it to the Steckschwein? The Steckschwein has a User Port, too, albeit a very different one as the C64. Basically, the Steckschwein-User-Port consists of the complete Port A of the VIA, plus the /RESET and /IRQ lines.</description><content>&lt;p>Recently, Michael Steil published a &lt;a href="https://www.pagetable.com/?p=1365">blog post about connecting NES and SNES Controller to a 6502-based system&lt;/a> showing how to use NES and SNES controllers on a C64 without the need for any special hardware, by just connecting them to the C64&amp;rsquo;s user port.&lt;/p>
&lt;p>Why not use his approach and adapt it to the Steckschwein? The Steckschwein has a User Port, too, albeit a very different one as the C64. Basically, the Steckschwein-User-Port consists of the complete Port A of the VIA, plus the /RESET and /IRQ lines. Also of course, VCC and GND.&lt;/p>
&lt;pre tabindex="0">&lt;code>User Port:
|---------GND
| |-------PA6
| | |-----PA4
| | | |---PA2 (DATA1)
| | | | |-PA0 (CLK)
o o X o o o o o
o o X o o o o o
| | | | |-PA1 (LATCH)
| | | |---PA3 (DATA2)
| | |-----PA5
| | |-----PA7
|---------VCC
SNES Controller:
/---------------------
| 7 6 5 | 4 3 2 1 |
\\---------------------
Pin Description
1 +5V
2 CLK
3 LATCH
4 DATA
5 –
6 –
7 GND
&lt;/code>&lt;/pre>&lt;p>&lt;img src="images/snes.jpg" alt="snes"> Simple adapter to connect one SNES controller&lt;/p>
&lt;p>As for the code, we use Michael&amp;rsquo;s code with only a few modifications respective to the different pinout, and with a handful of optimizations. Having a 65c02 instead of the 6510 in the C64 gives us the STZ instruction, also using PA0 as clock pin takes just an INC instruction followed by STZ to pulse the clock line.&lt;/p>
&lt;pre tabindex="0">&lt;code>nes_data = via1porta
nes_ddr = via1ddra
; zero page
controller1 = $00 ; 3 bytes
controller2 = $03 ; 3 bytes
bit_clk = %00000001 ; PA0 : CLK (both controllers)
bit_latch = %00000010 ; PA1 : LATCH (both controllers)
bit_data1 = %00000100 ; PA2 : DATA (controller #1)
bit_data2 = %00001000 ; PA3 : DATA (controller #2)
query_controllers:
lda #$ff-bit_data1-bit_data2
sta nes_ddr
lda #$00
sta nes_data
; pulse latch
lda #bit_latch
sta nes_data
;lda #0
;sta nes_data
stz nes_data
; read 3x 8 bits
ldx #0
l2: ldy #8
l1: lda nes_data
cmp #bit_data2
rol controller2,x
and #bit_data1
cmp #bit_data1
rol controller1,x
;lda #bit_clk
;sta nes_data
inc nes_data
;lda #0
;sta nes_data
stz nes_data
dey
bne l1
inx
cpx #3
bne l2
rts
&lt;/code>&lt;/pre>&lt;p>Small test program to output a different character for each button:&lt;/p>
&lt;p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/GgCyrkfQ8-o" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
 &lt;/p>
&lt;p>Also, instead of the original Nintendo SNES controller, I use an &lt;a href="https://www.8bitdo.com/">8bitdo SN30&lt;/a> Bluetooth controller with the SNES receiver. One could say this is the first time a Bluetooth device has been connected to the Steckschwein.&lt;/p>
&lt;p>&lt;img src="images/img_5814.jpg" alt="IMG_5814"> Bluetooth SNES receiver from 8bitdo&lt;/p>
&lt;p>Up next: Patching our games!&lt;/p></content></item><item><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface</title><link>https://www.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</link><pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</guid><description>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</description><content>&lt;p>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.&lt;/p>
&lt;p>as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings&lt;/p>
&lt;ol>
&lt;li>the first 2 bytes send to vdp during a write are always register writes which require a short delay of at least 2µs in between each byte&lt;/li>
&lt;li>the write of the 3rd byte (after the 2nd) requires a delay of 8µs. any further &amp;ldquo;single byte transfer&amp;rdquo; - during a vram write - also requires the 8µs delay. the same is true if we want to initiate a register write direclty after a vram write.&lt;/li>
&lt;li>the 3rd and n-th byte write to port #3 (index register port) during a bulk register write requires only the 2µs between each byte&lt;/li>
&lt;/ol>
&lt;p>With this in mind, we can optimize our library a little bit by using different &amp;ldquo;nop slides&amp;rdquo; for address setup and vram writes.&lt;/p>
&lt;p>We enhance our vdp.inc and built two macros which provide the different delay we need.&lt;/p>
&lt;p>.macro vdp_wait_s
jsr vdp_nopslide_2m ; 2m for 2µs wait
&amp;hellip;&lt;/p>
&lt;p>.macro vdp_wait_l
jsr vdp_nopslide_8m ; 8m for 8µs wait
&amp;hellip;&lt;/p>
&lt;p>steckSchwein is running at 8Mhz, so we also defined some equations and used ca65 macros to build our nop slides.&lt;/p>
&lt;p>.define CLOCK_SPEED_MHZ 8&lt;/p>
&lt;p>; long delay with 6µ+2µs (below)
MAX_NOPS_8M = (6 * 1000 / (1000 / CLOCK_SPEED_MHZ)) / 2
; 8Mhz, 125ns per cycle, wait 6µs = 6000ns
; = 6000ns / 125ns = 48cl / 2 =&amp;gt; 24 NOP&lt;/p>
&lt;p>; short delay with 2µs wait
MAX_NOPS_2M = (2 * 1000 / (1000 / CLOCK_SPEED_MHZ) -12) / 2
; -12 =&amp;gt; jsr/rts = 2 * 6cl = 12cl must be subtract&lt;/p>
&lt;p>.macro m_vdp_nopslide
vdp_nopslide_8m:
; long delay with 6+2 2µs wait
.repeat MAX_NOPS_8M
nop
.endrepeat
vdp_nopslide_2m:
.repeat MAX_NOPS_2M
nop
.endrepeat
rts
.endmacro&lt;/p>
&lt;p>Another interesting thing would be, &amp;ldquo;how does the /WAIT&amp;rdquo; behave in this situation? the assumption here is, that the /WAIT will behave in the way as specified. so /WAIT will be go low at least after 130ns from CSW. so to handover the /RDY handling to the vdp via the /WAIT pin, we have to apply only 1 wait state from our WS-Gen. after one wait state, we can release the /RDY low from our WS so that the vdp /WAIT can drive /RDY as needed.&lt;/p>
&lt;p>Back home, Thomas did the test and changed the waitstate generator firmware for the GAL16V8.&lt;/p>
&lt;p>The equation was&lt;/p>
&lt;p>W2 = ROM * UART * SND * /VDP
W1 = W2
+ /ROM * UART * VDP&lt;/p>
&lt;p>and was changed to&lt;/p>
&lt;p>W2 = /SND
W1 = W2
+ /ROM ; /ROM wait state if ROM is cs
+ /VDP ; /VDP wait state if VDP is cs&lt;/p>
&lt;p>So finally, we only need one wait state from the waitstate generator to access the VDP. If the VDP requires more time - surely - during a video memory access it will drive /WAIT to low as long as needed. So after the explcit 1WS from our wait state generator we now hand over the /RDY control to the VDP. How our /RDY and /WAIT really work together is subject to one of our next sessions where we&amp;rsquo;re going to measure the things with a logic analyzer and oscilloscope. Nevertheless, it works in this way and it works exaclty as specified within the datasheet.&lt;/p></content></item><item><title>WOZMON - a memory monitor in 256 bytes</title><link>https://www.steckschwein.de/post/wozmon-a-memory-monitor-in-256-bytes/</link><pubDate>Sun, 22 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/wozmon-a-memory-monitor-in-256-bytes/</guid><description>The woz monitor, also known as WOZMON, is a pretty simple memory monitor and was the system software located in the 256 byte PROM on the Apple I. Wozmon is used to inspect and modify memory contents or to execute programs already located in memory. Steve Wozniak managed to squeeze all that functionality into 256 bytes. That&amp;rsquo;s right, bytes. Not megabytes, not kilobytes. Bytes.
We already had attempted to get wozmon ported to our Steckschwein, but we did not succeed so far.</description><content>&lt;p>The &lt;a href="https://www.sbprojects.net/projects/apple1/wozmon.php">woz monitor, also known as WOZMON&lt;/a>, is a pretty simple memory monitor and was the system software located in the 256 byte PROM on the Apple I. Wozmon is used to inspect and modify memory contents or to execute programs already located in memory. Steve Wozniak managed to squeeze all that functionality into 256 bytes. That&amp;rsquo;s right, bytes. Not megabytes, not kilobytes. Bytes.&lt;/p>
&lt;p>We already had attempted to get wozmon ported to our Steckschwein, but we did not succeed so far. That might have been because the wozmon-code is a little bit hard to read and makes use of some Apple I specific things, which we did not know they were, since we do not have any expertise about the Apple I.&lt;/p>
&lt;p>Fortunately, we got asked by &lt;a href="http://neil.franklin.ch">Neil Franklin&lt;/a> to proof-read his in-depth &lt;a href="http://neil.franklin.ch/Info_Texts/Apple_1_Hardware_und_Software.html">article about the Apple I and wozmon&lt;/a>, which provided us with the missing background knowledge. So, as a proof of correctness and helpfulness of his article, it was time for a new porting attempt. As it turned out, there had to be 2 bigger changes, one while a char is input, and one while a char is output, and a few smaller but important considerations.&lt;/p>
&lt;p>We started off using &lt;a href="https://github.com/jefftranter/6502/tree/master/asm/wozmon">Jeff Tranter&amp;rsquo;s Version&lt;/a>, because Jeff saved us some grunt work by having adapted the code to ca65 syntax.&lt;/p>
&lt;p>So here is our Version of wozmon adapted to run on top of SteckOS in all it&amp;rsquo;s glory:&lt;/p>
&lt;pre tabindex="0">&lt;code>; The WOZ Monitor for the Apple 1
; Written by Steve Wozniak in 1976
Credit where credit is due!
.include &amp;#34;common.inc&amp;#34;
.include &amp;#34;../kernel/kernel.inc&amp;#34;
.include &amp;#34;../kernel/kernel\_jumptable.inc&amp;#34;
.include &amp;#34;appstart.inc&amp;#34;
appstart $1000
&lt;/code>&lt;/pre>&lt;p>Our Standard SteckOS includes. The appstart macro takes care of creating a commodore style file &amp;ldquo;header&amp;rdquo; with the load address in the first 2 bytes of the file.&lt;/p>
&lt;pre tabindex="0">&lt;code>; Page 0 Variables
XAML = $24 ; Last &amp;#34;opened&amp;#34; location Low
XAMH = $25 ; Last &amp;#34;opened&amp;#34; location High
STL = $26 ; Store address Low
STH = $27 ; Store address High
L = $28 ; Hex value parsing Low
H = $29 ; Hex value parsing High
YSAV = $2A ; Used to see if hex value is given
MODE = $2B ; $00=XAM, $7F=STOR, $AE=BLOCK XAM
&lt;/code>&lt;/pre>&lt;p>Nothing changed here.&lt;/p>
&lt;pre tabindex="0">&lt;code>; Other Variables
IN = $0300 ; Input buffer to $027F
; KBD = $D010 ; PIA.A keyboard input
; KBDCR = $D011 ; PIA.A keyboard control register
; DSP = $D012 ; PIA.B display output register
; DSPCR = $D013 ; PIA.B display control register
; .org $FF00
; .export RESET
&lt;/code>&lt;/pre>&lt;p>We need to put the input buffer from $027F to somewhere else, because $027F collides with our I/O area. $0300 should be fine. We do not use a PIA for i/o, so we can get rid of those labels. Also, the start address is already defined above, and we won&amp;rsquo;t need to export the RESET label.&lt;/p>
&lt;pre tabindex="0">&lt;code>RESET: CLD ; Clear decimal arithmetic mode.
CLI
LDY #$7F ; Mask for DSP data direction register.
; STY DSP ; Set it up.
LDA #$A7 ; KBD and DSP control register mask.
; STA KBDCR ; Enable interrupts, set CA1, CB1, for
; STA DSPCR ; positive edge sense/output mode.
&lt;/code>&lt;/pre>&lt;p>No need to initialize the PIA chip which we don&amp;rsquo;t have, but we still need to initialize the A and Y registers.&lt;/p>
&lt;pre tabindex="0">&lt;code>NOTCR: ; CMP #&amp;#39;_&amp;#39; ; &amp;#34;_&amp;#34;?
CMP #$08 + $80
BEQ BACKSPACE ; Yes.
&lt;/code>&lt;/pre>&lt;p>Backspace is $08 on the Steckschwein, not &amp;ldquo;_&amp;rdquo;.&lt;/p>
&lt;pre tabindex="0">&lt;code> CMP #$9B ; ESC?
BEQ ESCAPE ; Yes.
INY ; Advance text index.
BPL NEXTCHAR ; Auto ESC if &amp;gt; 127.
ESCAPE: LDA #&amp;#39;\&amp;#39; + $80 ; &amp;#34;\&amp;#34;.
JSR ECHO ; Output it.
GETLINE: LDA #$8A ; CR.
JSR ECHO ; Output it.
LDY #$01 ; Initialize text index.
BACKSPACE: DEY ; Back up text index.
BMI GETLINE ; Beyond start of line, reinitialize.
NEXTCHAR:
; LDA KBDCR ; Key ready?
; BPL NEXTCHAR ; Loop until ready.
; LDA KBD ; Load character. B7 should be ‘1’.
keyin
toupper
ORA #$80
&lt;/code>&lt;/pre>&lt;p>Here is our first major code change. Keyboard input is handled using SteckOS means. Then we convert the received character to uppercase, since the Apple I uses uppercase only, hence wozmon does not handle lowercase. Also, and most important, the Apple I keyboard generated ASCII with bit 7 set to &amp;ldquo;1&amp;rdquo;. We need to emulate that. With these modifications, the bulk of the code can remain as is.&lt;/p>
&lt;pre tabindex="0">&lt;code> STA IN,Y ; Add to text buffer.
JSR ECHO ; Display character.
CMP #$8D ; CR?
BNE NOTCR ; No.
LDY #$FF ; Reset text index.
LDA #$00 ; For XAM mode.
TAX ; 0-&amp;gt;X.
SETSTOR: ASL ; Leaves $7B if setting STOR mode.
SETMODE: STA MODE ; $00=XAM $7B=STOR $AE=BLOK XAM
BLSKIP: INY ; Advance text index.
NEXTITEM: LDA IN,Y ; Get character.
CMP #$8D ; CR?
BEQ GETLINE ; Yes, done this line.
CMP #&amp;#39;.&amp;#39; + $80 ; &amp;#34;.&amp;#34;?
BCC BLSKIP ; Skip delimiter.
BEQ SETMODE ; Yes. Set STOR mode.
CMP #&amp;#39;:&amp;#39; + $80 ; &amp;#34;:&amp;#34;?
BEQ SETSTOR ; Yes. Set STOR mode.
CMP #&amp;#39;R&amp;#39; + $80 ; &amp;#34;R&amp;#34;?
BEQ RUN ; Yes. Run user program.
STX L ; $00-&amp;gt; L.
STX H ; and H.
STY YSAV ; Save Y for comparison.
NEXTHEX: LDA IN,Y ; Get character for hex test.
EOR #$B0 ; Map digits to $0-9.
CMP #$0A ; Digit?
BCC DIG ; Yes.
ADC #$88 ; Map letter &amp;#34;A&amp;#34;-&amp;#34;F&amp;#34; to $FA-FF.
CMP #$FA ; Hex letter?
BCC NOTHEX ; No, character not hex.
DIG: ASL
ASL ; Hex digit to MSD of A.
ASL
ASL
LDX #$04 ; Shift count.
HEXSHIFT: ASL ; Hex digit left, MSB to carry.
ROL L ; Rotate into LSD.
ROL H ; Rotate into MSD’s.
DEX ; Done 4 shifts?
BNE HEXSHIFT ; No, loop.
INY ; Advance text index.
BNE NEXTHEX ; Always taken. Check next char for hex.
NOTHEX: CPY YSAV ; Check if L, H empty (no hex digits).
BEQ ESCAPE ; Yes, generate ESC sequence.
BIT MODE ; Test MODE byte.
BVC NOTSTOR ; B6=0 STOR 1 for XAM &amp;amp; BLOCK XAM
LDA L ; LSD’s of hex data.
STA (STL,X) ; Store at current ‘store index’.
INC STL ; Increment store index.
BNE NEXTITEM ; Get next item. (no carry).
INC STH ; Add carry to ‘store index’ high order.
TONEXTITEM: JMP NEXTITEM ; Get next command item.
RUN: JMP (XAML) ; Run at current XAM index.
NOTSTOR: BMI XAMNEXT ; B7=0 for XAM, 1 for BLOCK XAM.
LDX #$02 ; Byte count.
SETADR: LDA L-1,X ; Copy hex data to
STA STL-1,X ; ‘store index’.
STA XAML-1,X ; And to ‘XAM index’.
DEX ; Next of 2 bytes.
BNE SETADR ; Loop unless X=0.
NXTPRNT: BNE PRDATA ; NE means no address to print.
LDA #$8A ; CR.
JSR ECHO ; Output it.
LDA XAMH ; ‘Examine index’ high-order byte.
JSR PRBYTE ; Output it in hex format.
LDA XAML ; Low-order ‘examine index’ byte.
JSR PRBYTE ; Output it in hex format.
LDA #&amp;#39;:&amp;#39; + $80 ; &amp;#34;:&amp;#34;.
JSR ECHO ; Output it.
PRDATA: LDA #$A0 ; Blank.
JSR ECHO ; Output it.
LDA (XAML,X) ; Get data byte at ‘examine index’.
JSR PRBYTE ; Output it in hex format.
XAMNEXT: STX MODE ; 0-&amp;gt;MODE (XAM mode).
LDA XAML
CMP L ; Compare ‘examine index’ to hex data.
LDA XAMH
SBC H
BCS TONEXTITEM ; Not less, so no more data to output.
INC XAML
BNE MOD8CHK ; Increment ‘examine index’.
INC XAMH
MOD8CHK: LDA XAML ; Check low-order ‘examine index’ byte
AND #$07 ; For MOD 8=0
BPL NXTPRNT ; Always taken.
PRBYTE: PHA ; Save A for LSD.
LSR
LSR
LSR ; MSD to LSD position.
LSR
JSR PRHEX ; Output hex digit.
PLA ; Restore A.
PRHEX: AND #$0F ; Mask LSD for hex print.
ORA #&amp;#39;0&amp;#39; + $80 ; Add &amp;#34;0&amp;#34;.
CMP #$BA ; Digit?
BCC ECHO ; Yes, output it.
ADC #$06 ; Add offset for letter.
ECHO:
; BIT DSP ; bit (B7) cleared yet?
; BMI ECHO ; No, wait for display.
; STA DSP ; Output character. Sets DA.
pha
and #$7F
jsr krn\_chrout
pla
RTS ; Return.
&lt;/code>&lt;/pre>&lt;p>Second important change. We got rid of the Apple I specific routine to output characters and use the chrout-routine of the SteckOS-kernel. But in order not to output garbage, we need to unset bit 7. Since all comparisons afterwards still rely on bit 7 being set, we save the A register to the stack and restore it afterwards. A faster way would be to just set bit 7 again by doing a ORA #$80 before the RTS, but what the heck.&lt;/p>
&lt;pre tabindex="0">&lt;code>; BRK ; unused
; BRK ; unused
&lt;/code>&lt;/pre>&lt;p>We don&amp;rsquo;t need those.&lt;/p>
&lt;pre tabindex="0">&lt;code>; Interrupt Vectors
; .WORD $0F00 ; NMI
; .WORD RESET ; RESET
; .WORD $0000 ; BRK/IRQ
&lt;/code>&lt;/pre>&lt;p>We don&amp;rsquo;t need those either since we are not using wozmon as system software. Interrupt handling is still done by the SteckOS kernel.&lt;/p>
&lt;p> &lt;/p>
&lt;p>&lt;img src="images/wozmon.jpg" alt="wozmon"> Tada!&lt;/p></content></item><item><title>Am Anfang war das NOP</title><link>https://www.steckschwein.de/post/am-anfang-war-das-nop/</link><pubDate>Wed, 12 Feb 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/am-anfang-war-das-nop/</guid><description>Wenn man 20 Jahre lang den Jugendtraum mit sich rumträgt, einen 8bit-Rechner selber zu bauen, dann hat man 20 Jahre Zeit, einzurosten. Langsames Rantasten an das große Ziel ist angesagt.
In diesem Fall soll unser 65c02 erstmal nur NOPs ausführen und wir wollen zuschauen, was auf dem Adressbus passiert. Der Datenbus ist hart verdrahtet auf NOP ($EA, 11101010) . Als Reset-Schaltung kommt eine auf Basis des allseits beliebten NE555 zum Einsatz.</description><content>&lt;p>Wenn man 20 Jahre lang den Jugendtraum mit sich rumträgt, einen 8bit-Rechner selber zu bauen, dann hat man 20 Jahre Zeit, einzurosten. Langsames Rantasten an das große Ziel ist angesagt.&lt;/p>
&lt;p>In diesem Fall soll unser 65c02 erstmal nur NOPs ausführen und wir wollen zuschauen, was auf dem Adressbus passiert. Der Datenbus ist hart verdrahtet auf NOP ($EA, 11101010) . Als Reset-Schaltung kommt eine auf Basis des allseits beliebten NE555 zum Einsatz. Die gleiche Schaltung verrichtet auch im legendären Commodore PET ihren Dienst, also eine Chance, eine kleine Hommage mit einzubauen:&lt;/p>
&lt;p>&lt;img src="images/80cba-pet_reset.png" alt="">&lt;/p>
&lt;p>Als Taktgenerator missbrauchen wir den Kalibrierausgang des Oszilloskops, der unsere Computer-Keimzelle mit 1 kHz taktet.&lt;/p>
&lt;p>Am Adressbus sind nun, über 74ls245-Treiber, 16 LEDs angeschlossen, an denen wir erkennen können, welche Adresse anliegt:&lt;/p>
&lt;p> 
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/ZLhVni8Wy5Y" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;/p>
&lt;p>Was wir also spannendes hier sehen ist folgendes:&lt;/p>
&lt;p>Nach dem Reset sprint der 65c02 an seinen Reset-Vektor, nämlich $fffc, liest dort die Adresse $EAEA (der Datenbus ist ja auf $EA hart verdrahtet), springt nach $EAEA, liest die erste Instruktion ein, nämlich ein NOP ($EA) und so weiter. Könnte man sich stundenlang ansehen.&lt;/p></content></item><item><title>Mehr Mut: Es werde Code!</title><link>https://www.steckschwein.de/post/mehr-mut-es-werde-code/</link><pubDate>Wed, 12 Feb 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/mehr-mut-es-werde-code/</guid><description>Nachdem uns nach einiger Zeit dann doch langweilig wurde, den Prozessor beim NOPs ausführen zu beobachten musste der nächste Kick her: Es soll Code ausführen! Also ein wenig Code geschrieben (dieser ist leider nicht überliefert, enthielt lediglich einige NOPs und JMPs, gerade genug also, um uns in blanke Verzückung zu versetzen), auf ein 27128 EPROM gebrannt und an Adress- und Datenbus angeschlossen. /OE und /CS des EPROM wurden einfach auf Masse gelegt.</description><content>&lt;p>Nachdem uns nach einiger Zeit dann doch langweilig wurde, den Prozessor beim NOPs ausführen zu beobachten musste der nächste Kick her: Es soll Code ausführen! Also ein wenig Code geschrieben (dieser ist leider nicht überliefert, enthielt lediglich einige NOPs und JMPs, gerade genug also, um uns in blanke Verzückung zu versetzen), auf ein 27128 EPROM gebrannt und an Adress- und Datenbus angeschlossen. /OE und /CS des EPROM wurden einfach auf Masse gelegt. Adressleitungen A0-A12 des EPROM wurden mit dem Adressbus des Prozessors verbunden, die verbliebenen Adressleitungen des Prozessors blieben frei. Also haben wir nun 8k ROM, die sich innerhalb der 64k Adressraum des 65c02 8 mal wiederholen.&lt;/p>
&lt;p>Um das visuelle Erleben intensiver zu gestalten wurde der Datenbus mit Hilfe eines 74ls245 und 8 roter LEDs ebenfalls sichtbar gemacht. Für den Takt sorgt mittlerweile ein Rechteckgenerator auf NE555-Basis, der beschauliche 500Hz liefert.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/z5xyLgUeEcM" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></content></item></channel></rss>