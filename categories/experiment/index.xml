<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>experiment on Steckschwein</title><link>https://steckschwein.github.io/categories/experiment/</link><description>Recent content in experiment on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 15 Jan 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://steckschwein.github.io/categories/experiment/index.xml" rel="self" type="application/rss+xml"/><item><title>Connecting SNES Controller to the Steckschwein</title><link>https://steckschwein.github.io/post/connecting-snes-controller-to-the-steckschwein/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>https://steckschwein.github.io/post/connecting-snes-controller-to-the-steckschwein/</guid><description>Recently, Michael Steil published a blog post about connecting NES and SNES Controller to a 6502-based system showing how to use NES and SNES controllers on a C64 without the need for any special hardware, by just connecting them to the C64&amp;rsquo;s user port.
Why not use his approach and adapt it to the Steckschwein? The Steckschwein has a User Port, too, albeit a very different one as the C64. Basically, the Steckschwein-User-Port consists of the complete Port A of the VIA, plus the /RESET and /IRQ lines.</description></item><item><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface</title><link>https://steckschwein.github.io/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</link><pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate><guid>https://steckschwein.github.io/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</guid><description>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</description></item><item><title>WOZMON - a memory monitor in 256 bytes</title><link>https://steckschwein.github.io/post/wozmon-a-memory-monitor-in-256-bytes/</link><pubDate>Sun, 22 Jul 2018 00:00:00 +0000</pubDate><guid>https://steckschwein.github.io/post/wozmon-a-memory-monitor-in-256-bytes/</guid><description>The woz monitor, also known as WOZMON, is a pretty simple memory monitor and was the system software located in the 256 byte PROM on the Apple I. Wozmon is used to inspect and modify memory contents or to execute programs already located in memory. Steve Wozniak managed to squeeze all that functionality into 256 bytes. That&amp;rsquo;s right, bytes. Not megabytes, not kilobytes. Bytes.
We already had attempted to get wozmon ported to our Steckschwein, but we did not succeed so far.</description></item><item><title>Am Anfang war das NOP</title><link>https://steckschwein.github.io/post/am-anfang-war-das-nop/</link><pubDate>Wed, 12 Feb 2014 00:00:00 +0000</pubDate><guid>https://steckschwein.github.io/post/am-anfang-war-das-nop/</guid><description>Wenn man 20 Jahre lang den Jugendtraum mit sich rumträgt, einen 8bit-Rechner selber zu bauen, dann hat man 20 Jahre Zeit, einzurosten. Langsames Rantasten an das große Ziel ist angesagt.
In diesem Fall soll unser 65c02 erstmal nur NOPs ausführen und wir wollen zuschauen, was auf dem Adressbus passiert. Der Datenbus ist hart verdrahtet auf NOP ($EA, 11101010) . Als Reset-Schaltung kommt eine auf Basis des allseits beliebten NE555 zum Einsatz.</description></item><item><title>Mehr Mut: Es werde Code!</title><link>https://steckschwein.github.io/post/mehr-mut-es-werde-code/</link><pubDate>Wed, 12 Feb 2014 00:00:00 +0000</pubDate><guid>https://steckschwein.github.io/post/mehr-mut-es-werde-code/</guid><description>Nachdem uns nach einiger Zeit dann doch langweilig wurde, den Prozessor beim NOPs ausführen zu beobachten musste der nächste Kick her: Es soll Code ausführen! Also ein wenig Code geschrieben (dieser ist leider nicht überliefert, enthielt lediglich einige NOPs und JMPs, gerade genug also, um uns in blanke Verzückung zu versetzen), auf ein 27128 EPROM gebrannt und an Adress- und Datenbus angeschlossen. /OE und /CS des EPROM wurden einfach auf Masse gelegt.</description></item></channel></rss>