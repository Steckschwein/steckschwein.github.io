<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Schlauer(er) Decoder - Steckschwein</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Schlauer(er) Decoder"><meta property="og:description" content="Im Rahmen unserer Reihe &ldquo;Kleine Verbesserungen an der Architektur&rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:"><meta property="og:type" content="article"><meta property="og:url" content="https://www.steckschwein.de/post/schlauerer-decoder/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-07-01T00:00:00+00:00"><meta property="article:modified_time" content="2014-07-01T00:00:00+00:00"><meta itemprop=name content="Schlauer(er) Decoder"><meta itemprop=description content="Im Rahmen unserer Reihe &ldquo;Kleine Verbesserungen an der Architektur&rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:"><meta itemprop=datePublished content="2014-07-01T00:00:00+00:00"><meta itemprop=dateModified content="2014-07-01T00:00:00+00:00"><meta itemprop=wordCount content="323"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Schlauer(er) Decoder"><meta name=twitter:description content="Im Rahmen unserer Reihe &ldquo;Kleine Verbesserungen an der Architektur&rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=Steckschwein rel=home><div class="logo__item logo__text"><div class=logo__title>Steckschwein</div><div class=logo__tagline>An 8bit computer for the 21st century</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Blog</span></a></li><li class=menu__item><a class=menu__link href=/hardware/><span class=menu__text>Hardware</span></a></li><li class=menu__item><a class=menu__link href=/software/><span class=menu__text>Software</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li><li class=menu__item><a class=menu__link href=/impressum/><span class=menu__text>Impressum</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Schlauer(er) Decoder</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2014-07-01T00:00:00Z>July 01, 2014</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/adressdekoder/ rel=category>adressdekoder</a>, <a class=meta__link href=/categories/gal/ rel=category>gal</a>, <a class=meta__link href=/categories/ram/ rel=category>ram</a>, <a class=meta__link href=/categories/rom/ rel=category>rom</a></span></div></div></header><div class="content post__content clearfix"><p>Im Rahmen unserer Reihe &ldquo;Kleine Verbesserungen an der Architektur&rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:</p><p>/CSHIRAM = G1*/A2                          + G1*/A1*/A0 /CSROM   = G1*A2                  Wir machen also die CS-Signale statisch von der anliegen Adresse abhängig. Aber es sollte doch möglich sein, grundsätzlich auch zwischen Reads und Writes auf die entsprechenden Adressen zu unterscheiden, oder? Die /RW-Leitung des Prozessors liegt ohnehin am GAL an. Was spricht dagegen, Lesezugriffe nach $e000-$ffff aus dem ROM zu holen, Schreibzugriffe aber immer ins RAM zu leiten? Der C64 kann das schließlich auch. Schreiben wir ein kleines Testprogramm:</p><p>main ldx #$00 loop lda $e000,x sta $e000,x inx cpx #$ff bne loop jmp main</p><p>Wir lesen also aus dem ROM-Bereich und schreiben gleich wieder zurück. Das Oszilloskop zeigt uns /CSHIRAM (gelb) und /CSROM (blau):</p><table style=margin-left:auto;margin-right:auto;text-align:center cellspacing=0 cellpadding=0 align=center><tbody><tr><td style=text-align:center><a style=margin-left:auto;margin-right:auto href=https://steckschwein.files.wordpress.com/2014/07/7a51a-tekway114_1.gif><img src=images/7a51a-tekway114_1.gif width=400 height=240 border=0></a></td></tr><tr><td style=text-align:center><span style="font-family:Times,times new roman,serif;font-size:small;text-align:start">/CSHIRAM (gelb) und /CSROM (blau)</span></td></tr></tbody></table><p>Die Schreibzugriffe landen erwartungsgemäß nicht im RAM, dieses wird zu keiner Zeit selektiert.</p><p>Jetzt passen wir die Gleichungen für /CSHIRAM und /CSROM an, indem wir die Abhängigkeit von /RW berücksichtigen:</p><p>/CSHIRAM = G1*/A2</p><ul><li><p>G1*/A1*/A0</p></li><li><p>/RW*G1*A2*A1 ; Writes to $e000-$ffff go to the RAM</p></li></ul><p>/CSROM   = RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the ROM</p><p>Und jetzt lassen wir unser Programm nochmal laufen:</p><table style=margin-left:auto;margin-right:auto;text-align:center cellspacing=0 cellpadding=0 align=center><tbody><tr><td style=text-align:center><a style=margin-left:auto;margin-right:auto href=https://steckschwein.files.wordpress.com/2014/07/8f301-tekway114_2.gif><img src=images/8f301-tekway114_2.gif width=400 height=240 border=0></a></td></tr><tr><td style=text-align:center><span style="font-family:Times,times new roman,serif;font-size:small;text-align:start">/CSHIRAM (gelb) und /CSROM (blau)</span></td></tr></tbody></table><p>Wir erkennen einen Lesezugriff (/CSROM, LDA $e000,x) und direkt darauf einen Schreibzugriff ins RAM (/CSHIRAM, STA $e000,x).</p><p>Hurra, schreiben wir jetzt &ldquo;ins ROM&rdquo;, landen unsere Schreibzugriffe automatisch im darunterliegenden RAM. Allerdings nützt uns das noch nichts, denn noch können wir aus dem RAM nicht lesen.</p><p>Im nächsten Teil erweitern wir also die GAL-Logik um einen Steuerpin, mit dem wir das ROM vollständig ausblenden und das RAM entsprechend freilegen können.</p></div></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 Steckschwein.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>