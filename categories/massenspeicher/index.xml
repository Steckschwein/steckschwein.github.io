<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>massenspeicher on</title><link>https://beta.steckschwein.de/categories/massenspeicher/</link><description>Recent content in massenspeicher on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 22 Apr 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://beta.steckschwein.de/categories/massenspeicher/index.xml" rel="self" type="application/rss+xml"/><item><title>Das Steckschwein auf dem VCFe 17</title><link>https://beta.steckschwein.de/post/das-steckschwein-auf-dem-vcfe-17/</link><pubDate>Fri, 22 Apr 2016 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/das-steckschwein-auf-dem-vcfe-17/</guid><description>Am Wochenende vom 30. April und 1. Mai 2016 findet zum 17. Mal das Vintage Computer Festival Europe (VCFe) in München statt.
Das Steckschwein ist natürlich wieder dabei. Unter anderem wird es unsere neue CPU-Platine mit integriertem Waitstate-Generator und dadurch möglichen 8MHz Takt gezeigt.
Ausserdem wird es getreu des diesjährigen VCFe-Mottos &amp;ldquo;Irgendwas mit Medien&amp;rdquo; einen Vortrag zum Speichermedium des Steckschweins geben, speziell über dessen FAT32-Unterstützung.</description><content>&lt;p>&lt;img src="images/vcflogo.gif" alt="VCFe 17 Logo">&lt;/p>
&lt;p>Am Wochenende vom 30. April und 1. Mai 2016 findet zum 17. Mal das &lt;a href="http://www.vcfe.org/D/">Vintage Computer Festival Europe (VCFe)&lt;/a> in München statt.&lt;/p>
&lt;p>Das Steckschwein ist natürlich wieder dabei. Unter anderem wird es unsere neue CPU-Platine mit integriertem Waitstate-Generator und dadurch möglichen 8MHz Takt gezeigt.&lt;/p>
&lt;p>Ausserdem wird es getreu des diesjährigen VCFe-Mottos &amp;ldquo;Irgendwas mit Medien&amp;rdquo; einen Vortrag zum Speichermedium des Steckschweins geben, speziell über dessen FAT32-Unterstützung.&lt;/p></content></item><item><title>Mehr Karten (UPDATE)</title><link>https://beta.steckschwein.de/post/mehr-karten-update/</link><pubDate>Fri, 24 Jul 2015 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/mehr-karten-update/</guid><description>Unser &amp;ldquo;Standard&amp;rdquo;-Massenspeicher SD-Karte funktioniert zwar an und für sehr gut, Sorgenkind war aber immer die Initialisierungs-Routine. Bisher ließen sich damit nur günstige Class4-Karten initialisieren, bei &amp;ldquo;höherwertigen&amp;rdquo; Karten schlug die Initialisierung immer fehl, sodass nur etwa 3 von 5 Karten nutzbar waren.
Das hat uns schon etwas gewurmt, denn irgendwie hatte dieser Stand ein Geschmäckle von &amp;ldquo;Funktioniert aus Versehen&amp;rdquo;. Also mussten wir da nochmal ran. Der Initialisierungs-Flow entspricht im Wesentlichen dem, was auf der bekannten Seite http://elm-chan.</description><content>&lt;p>Unser &amp;ldquo;Standard&amp;rdquo;-Massenspeicher SD-Karte funktioniert zwar an und für sehr gut, Sorgenkind war aber immer die Initialisierungs-Routine. Bisher ließen sich damit nur günstige Class4-Karten initialisieren, bei &amp;ldquo;höherwertigen&amp;rdquo; Karten schlug die Initialisierung immer fehl, sodass nur etwa 3 von 5 Karten nutzbar waren.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Das hat uns schon etwas gewurmt, denn irgendwie hatte dieser Stand ein Geschmäckle von &amp;ldquo;Funktioniert aus Versehen&amp;rdquo;. Also mussten wir da nochmal ran. Der Initialisierungs-Flow entspricht im Wesentlichen dem, was auf der bekannten Seite &lt;a href="http://elm-chan.org/docs/mmc/mmc_e.html">http://elm-chan.org/docs/mmc/mmc_e.html&lt;/a> dokumentiert ist. In den letzten Tagen haben wir diesen unter die Lupe genommen, und tatsächlich ist etwas aufgefallen. Vor dem Senden eines Kommandos muss sichergestellt werden, dass die Karte bereit ist. Hierzu sendet man solange $ff an die Karte, bis diese auch $ff zurücksendet. Dann ist die Karte bereit, ein Kommando zu empfangen. In unserer Initialisierungsroutine wurde dies zwischen CMD55 und ACMD41 (näheres bitte dem Link entnehmen) schlichtweg nicht gemacht. Plötzlich lassen sich fast alle vorhandenen Karten initialisieren. Dass dies mit den Class4-Karten trotzdem funktionierte, war also gewissermaßen tatsächlich aus Versehen.&lt;/p>
&lt;p>Das nächste Problem war dann, dass von den jetzt nutzbaren Karten über die Shell zwar im Filesystem navigiert und Verzeichnisse aufgelistet werden konnten, das eigentliche Laden von Dateien bzw. Starten von Programmen funktionierte nicht. Die Blockleseroutinen liefen korrekt durch, die geladenen Daten jedoch waren fehlerhaft. Dass die Dateisystemoperationen funktioniert haben, und nur das Einlesen von Dateien Probleme machte, war verdächtig. &lt;a href="http://wordpress.steckschwein.de/wordpress/index.php/2015/05/20/filesystem-und-shell/">Noch im Mai verkündeten wir&lt;/a> u.a. stolz, dass wir zum Dateien lesen schnelle SD-Multiblock-Transfers verwenden. Diese haben den Vorteil, dass man der Karte nur die Adresse des ersten zu lesenden Blocks übermittelt, und dann einfach liest bis der Arzt kommt oder man der Karte sagt, dass man fertig ist. Vorteil ist, dass man die Blockadresse des nächsten Blocks nicht immer selber ausrechnen muss (immerhin eine 32bit-Addition) und auch nicht immer wieder an die Karte schicken muss.&lt;/p>
&lt;p>Gut, also die fat_read-Routine zurückgebaut, und schon ist das Steckschwein mit so ziemlich jeder handelsüblichen SD-Karte kompatibel.&lt;/p>
&lt;p>&lt;strong>[UPDATE:]&lt;/strong> Mittlerweile funktionieren auch wieder Multiblock-Transfers. Der Trick war, beim Lesen von der Karte die MOSI-Leitung nicht auf L, sondern auf H zu setzen, also nicht mehr $00 zu senden, sondern $ff. Die Idee kam, nachdem sämtliche Beispiele, die sich im Web finden lassen, $ff senden. Die Stelle in der SD-Karten-Spezifikation, in der das so spezifiziert ist, ist bis dato nicht gefunden worden.&lt;/p></content></item><item><title>Filesystem und Shell</title><link>https://beta.steckschwein.de/post/filesystem-und-shell/</link><pubDate>Wed, 20 May 2015 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/filesystem-und-shell/</guid><description>Vor kurzem haben wir ja schon von ersten Gehversuchen einer FAT32-Implementation berichtet, mit der wir in der Lage waren, beim Systemstart eine Datei von SD-Karte zu laden.
Was fehlt, ist eine Möglichkeit, innerhalb eines Filesystems einer SD-Karte zu navigieren, Programme zu laden oder Dateien anzuzeigen. Um diese Lücke zu füllen, ist die SteckShell entstanden. In der aktuellen Version 0.6 unterstützt die Shell folgende Funktionen:
Directory auflisten Directory wechseln Programm laden und starten Datei anzeigen Grafik (TMS9929-Rohdaten) anzeigen Wer auf dem VCFe 16.</description><content>&lt;p>&lt;a href="http://wordpress.steckschwein.de/wordpress/index.php/2015/01/05/bootschwein/">Vor kurzem&lt;/a> haben wir ja schon von ersten Gehversuchen einer FAT32-Implementation berichtet, mit der wir in der Lage waren, beim Systemstart eine Datei von SD-Karte zu laden.&lt;/p>
&lt;p>Was fehlt, ist eine Möglichkeit, innerhalb eines Filesystems einer SD-Karte zu navigieren, Programme zu laden oder Dateien anzuzeigen. Um diese Lücke zu füllen, ist die SteckShell entstanden. In der aktuellen Version 0.6 unterstützt die Shell folgende Funktionen:&lt;/p>
&lt;ul>
&lt;li>Directory auflisten&lt;/li>
&lt;li>Directory wechseln&lt;/li>
&lt;li>Programm laden und starten&lt;/li>
&lt;li>Datei anzeigen&lt;/li>
&lt;li>Grafik (TMS9929-Rohdaten) anzeigen&lt;/li>
&lt;/ul>
&lt;p>Wer auf dem VCFe 16.0 anwesend war konnte diese Shell auch in Aktion erleben.&lt;/p>
&lt;p>Dank Marko unterstützt die Shell inzwischen sogar den 40-Zeichen-Modus des TMS99xx!&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Die Shell liegt nicht im ROM, sondern wird entweder seriell aufs Steckschwein geladen oder mit dem beschriebenen boot-Mechanismus von SD-Karte gestartet.&lt;/p>
&lt;p>Mit ihr fühlt sich das Steckschwein schon wie ein &amp;ldquo;richtiger&amp;rdquo; Computer an, denn jetzt ist eine interaktive Bedienung möglich.&lt;/p>
&lt;p>Die SteckShell dient uns sozusagen als Betriebsystem-Keimzelle, in der u.a. die FAT-Routinen reifen. Hier hat sich seit unserem rudimentären ROM-Bootloader auch einiges getan.&lt;/p>
&lt;p>Die ersten Versuche mit FAT, die auch in den allerersten Versionen der Shell noch Verwendung fanden, bestanden darin, über das Verzeichnis zu iterieren, eine Datei nach Namen oder Attribut zu finden und dann mit ihr etwas zu machen.&lt;/p>
&lt;p>Dieser Ansatz funktioniert jetzt immer noch als ROM-Bootloader, aber für die Shell sind die Anforderungen etwas andere. Man möchte eine Datei vielleicht auch nur erst in den Speicher laden, um dann zu entscheiden, was als nächstes passieren soll. Man möchte evtl. mehrere Dateien geöffnet haben, oder zumindest das aktuelle Verzeichnis und eine Datei geöffnet haben können.&lt;/p>
&lt;p>Ehe man sich versieht, befindet man sich inmitten der gleichen Überlegung, die vor einigen Jahrzehnten schon mal jemand angestellt hat, und sich dann das klassische und bekannte Interface bestehend aus open(), close(), read() usw. ausgedacht hat.&lt;/p>
&lt;p>Also wurde das Ganze in Subroutinen fat_mount, fat_open, etc. aufgedröselt.&lt;/p>
&lt;p>fat_open und fat_close verwalten eine Filedeskriptortabelle.&lt;/p>
&lt;p>fat_open bekommt einen Dateinamen als Argument und sucht diesen im aktuellen Verzeichnis. Der Startcluster und die Größe der gefundenen Datei wird in die Deskriptortabelle geschrieben. Die Adresse dieses Eintrags ist der File-Handle.&lt;/p>
&lt;p>Mit diesem kann nun fat_read die geöffnete Datei in den Speicher einlesen. Dies geschieht bei der Gelegenheit nun per SD-Multiblock-Transfer, sodass ein ganzer Cluster in einem Stück ohne Overhead durch Zwischenberechnungen der Sektornummern eingelesen werden kann.&lt;/p>
&lt;p>Das gesamte &amp;ldquo;Interface&amp;rdquo; hantiert nur mit Clusteradressen, die Berechnung der LBA-Adressen passiert intern.&lt;/p>
&lt;p>Damit haben wir eine für unsere Zwecke erst einmal ausreichende Filesystem-Implementation.&lt;/p>
&lt;p>Aktuell können wir noch keine eigentlichen &amp;ldquo;FAT&amp;rdquo;-Lookups, d.h. wir können nur mit Dateien und Verzeichnissen umgehen, die in einen Cluster passen, was jedoch bei einer Clustergröße von 32k bei einer 4GB-Karte auf einem 8-bit-System keine große Einschränkung darstellt. Spätestens wenn wir so etwas wie seek() und damit sequentiellen Zugriff auf Dateien implementieren werden wir uns auch daran setzen müssen.&lt;/p>
&lt;p>Die Shell verfügt außerdem über die Fähigkeit, die Textkonsole zu scrollen. In diesem Fall allerdings nicht über die Möglichkeiten des VDP, sondern das Textscrolling wird im regulären Arbeitsspeicher durchgeführt und der &amp;ldquo;Bildschirminhalt&amp;rdquo; während des VDP-Blank ins RAM des TMS9929 geschrieben. Dies würde sogar ermöglichen, verschiedene umschaltbare Textkonsolen a la Linux (Alt-F1..n) zu realisieren. Aber über diesen Mechanismus darf sich Marko gerne auslassen.&lt;/p></content></item><item><title>Tore zur Welt</title><link>https://beta.steckschwein.de/post/tore-zur-welt/</link><pubDate>Fri, 11 Jul 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/tore-zur-welt/</guid><description>Um dem Ziel eines &amp;ldquo;richtigen&amp;rdquo; Computers näher zu kommen, brauchen wir nicht nur einen Videochip, wir brauchen auch Eingabegeräte und Massenspeicher.
Zwar soll unser Rechner so retro sein, dass es ihn damals, zur Hochzeit der 8bit-Heimcomputer, durchaus hätte geben können, realistischerweise wollen wir ihn jedoch mit durchaus modernen Schnittstellen ausstatten. Die 8bit-Rechner aus &amp;ldquo;unserer Zeit&amp;rdquo; haben IO-Chips wie den 6526 oder 6522 benutzt, um Tastatur (Matrix), Joysticks und Massenspeicher anzusteuern. Das haben wir auch vor.</description><content>&lt;p>Um dem Ziel eines &amp;ldquo;richtigen&amp;rdquo; Computers näher zu kommen, brauchen wir nicht nur einen Videochip, wir brauchen auch Eingabegeräte und Massenspeicher.&lt;/p>
&lt;p>Zwar soll unser Rechner so retro sein, dass es ihn damals, zur Hochzeit der 8bit-Heimcomputer, durchaus hätte geben können, realistischerweise wollen wir ihn jedoch mit durchaus modernen Schnittstellen ausstatten. Die 8bit-Rechner aus &amp;ldquo;unserer Zeit&amp;rdquo; haben IO-Chips wie den 6526 oder 6522 benutzt, um Tastatur (Matrix), Joysticks und Massenspeicher anzusteuern. Das haben wir auch vor. Nur etwas anders. Wir verwenden eine 65c22 VIA, und machen sie zu einem &lt;a href="http://de.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI&lt;/a> &amp;ldquo;Master&amp;rdquo;. Damit wollen wir einen wesentlichen Teil der Peripherie anbinden.&lt;/p>
&lt;p>SD-Karten unterstützen SPI direkt, sodass unsere angepeilte Massenspeicherlösung quasi schon fertig ist. Damit ersparen wir es uns, einen irgendwie gearteten Laufwerkscontroller ansteuern zu müssen oder gar über einen Haufen TTL eine IDE-Schnittstelle für alte Platten oder CompactFlash-Karten bauen zu müssen. Der einzige Zusatzaufwand, den wir hardwaremäßig noch betreiben müssen, ist eine 3.3V-Spannungsversorgung und eine Anpassung der 5V-Pegel der VIA auf 3.3V für die SD-Karte, denn SD-Karten laufen mit 3.3V und ihre Eingänge sind nicht 5V-tolerant. Der Rest ist Software.&lt;/p>
&lt;p>In Sachen Tastatur setzen wir auch auf eine Standardschnittstelle, nämlich PS/2. Das ist immer noch retro genug, und PS/2-Tastaturen sind immer noch einfacher zu beschaffen als Matrixtastaturen. Als kleiner Stilbruch bietet sich als Tastaturcontroller ein kleiner AVR-Microcontroller an, der die Scancodes der Tastatur in ASCII-Codes wandelt. Bequemerweise gibt es zahlreiche fertige Lösungen, die z.B. am anderen Ende rs232 sprechen. Wir wollen aber nur wegen einer Tastatur keinen zweiten UART verbauen. Fehlt also nur eine kleine Anpassung auf SPI. Aber zunächst mal die SD-Karte.&lt;/p>
&lt;p>Mit SPI hätten wir darüberhinaus noch viel mehr Möglichkeiten, ohne allzu großen Aufwand weitere SPI-fähige Komponenten wie RTCs, EEPROMS oder vielleicht sogar USB-Hosts anzubinden.&lt;/p>
&lt;p>Der Schaltplan zeigt, wie wir aktuell die VIA nutzen, um eine SD-Karte anzusprechen. Port B stellt die Steuerleitungen, wobei die beiden &amp;ldquo;äußeren&amp;rdquo; Bits 0 und 7 für SPICLK und MOSI verwendet werd, weil sie sich durch Inkrementieren, Dekrementieren bzw. Bit-Shifting schnell ansprechen lassen. Die 6 Bit dazwischen dienen als Slave-Select-Leitungen. MISO geht direkt in CB2, dem Eingang des Schieberegisters der VIA, welcher von PB0 an CB1 extern über unsere SPI-Clock getaktet wird. Damit läuft das Schieberegister exakt in dem Modus, der durch den berühmt berüchtigten VIA-Bug betroffen ist. Wir leben gerne gefährlich. Die Alternative wäre gewesen, ein externes Schieberegister zu benutzen, welches dann Port A belegt hätte. So bleibt dieser frei.&lt;/p>
&lt;p>&lt;a href="https://steckschwein.files.wordpress.com/2014/07/fa076-spi.png">&lt;img src="images/fa076-spi.png" alt="">&lt;/a>&lt;/p></content></item></channel></rss>