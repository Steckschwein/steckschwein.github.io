<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cpu on Steckschwein</title><link>https://beta.steckschwein.de/categories/cpu/</link><description>Recent content in cpu on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 22 Oct 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://beta.steckschwein.de/categories/cpu/index.xml" rel="self" type="application/rss+xml"/><item><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface</title><link>https://beta.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</link><pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</guid><description>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</description><content>&lt;p>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.&lt;/p>
&lt;p>as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings&lt;/p>
&lt;ol>
&lt;li>the first 2 bytes send to vdp during a write are always register writes which require a short delay of at least 2µs in between each byte&lt;/li>
&lt;li>the write of the 3rd byte (after the 2nd) requires a delay of 8µs. any further &amp;ldquo;single byte transfer&amp;rdquo; - during a vram write - also requires the 8µs delay. the same is true if we want to initiate a register write direclty after a vram write.&lt;/li>
&lt;li>the 3rd and n-th byte write to port #3 (index register port) during a bulk register write requires only the 2µs between each byte&lt;/li>
&lt;/ol>
&lt;p>With this in mind, we can optimize our library a little bit by using different &amp;ldquo;nop slides&amp;rdquo; for address setup and vram writes.&lt;/p>
&lt;p>We enhance our vdp.inc and built two macros which provide the different delay we need.&lt;/p>
&lt;p>.macro vdp_wait_s
jsr vdp_nopslide_2m ; 2m for 2µs wait
&amp;hellip;&lt;/p>
&lt;p>.macro vdp_wait_l
jsr vdp_nopslide_8m ; 8m for 8µs wait
&amp;hellip;&lt;/p>
&lt;p>steckSchwein is running at 8Mhz, so we also defined some equations and used ca65 macros to build our nop slides.&lt;/p>
&lt;p>.define CLOCK_SPEED_MHZ 8&lt;/p>
&lt;p>; long delay with 6µ+2µs (below)
MAX_NOPS_8M = (6 * 1000 / (1000 / CLOCK_SPEED_MHZ)) / 2
; 8Mhz, 125ns per cycle, wait 6µs = 6000ns
; = 6000ns / 125ns = 48cl / 2 =&amp;gt; 24 NOP&lt;/p>
&lt;p>; short delay with 2µs wait
MAX_NOPS_2M = (2 * 1000 / (1000 / CLOCK_SPEED_MHZ) -12) / 2
; -12 =&amp;gt; jsr/rts = 2 * 6cl = 12cl must be subtract&lt;/p>
&lt;p>.macro m_vdp_nopslide
vdp_nopslide_8m:
; long delay with 6+2 2µs wait
.repeat MAX_NOPS_8M
nop
.endrepeat
vdp_nopslide_2m:
.repeat MAX_NOPS_2M
nop
.endrepeat
rts
.endmacro&lt;/p>
&lt;p>Another interesting thing would be, &amp;ldquo;how does the /WAIT&amp;rdquo; behave in this situation? the assumption here is, that the /WAIT will behave in the way as specified. so /WAIT will be go low at least after 130ns from CSW. so to handover the /RDY handling to the vdp via the /WAIT pin, we have to apply only 1 wait state from our WS-Gen. after one wait state, we can release the /RDY low from our WS so that the vdp /WAIT can drive /RDY as needed.&lt;/p>
&lt;p>Back home, Thomas did the test and changed the waitstate generator firmware for the GAL16V8.&lt;/p>
&lt;p>The equation was&lt;/p>
&lt;p>W2 = ROM * UART * SND * /VDP
W1 = W2
+ /ROM * UART * VDP&lt;/p>
&lt;p>and was changed to&lt;/p>
&lt;p>W2 = /SND
W1 = W2
+ /ROM ; /ROM wait state if ROM is cs
+ /VDP ; /VDP wait state if VDP is cs&lt;/p>
&lt;p>So finally, we only need one wait state from the waitstate generator to access the VDP. If the VDP requires more time - surely - during a video memory access it will drive /WAIT to low as long as needed. So after the explcit 1WS from our wait state generator we now hand over the /RDY control to the VDP. How our /RDY and /WAIT really work together is subject to one of our next sessions where we&amp;rsquo;re going to measure the things with a logic analyzer and oscilloscope. Nevertheless, it works in this way and it works exaclty as specified within the datasheet.&lt;/p></content></item><item><title>VCFB 2018 It was great...</title><link>https://beta.steckschwein.de/post/vcfb-2018-its-great/</link><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/vcfb-2018-its-great/</guid><description>VCF 2018 in Berlin was great! We&amp;rsquo;ve met interesting people there. Got a handshake with Scot W. Stevenson who for(th)ced us to use his TaliForth2 ;)
Later on Saturday Daniel Illgen - maintainer of the Adlib Tracker II for Linux - had decided to honor us with his OPL2 knowledge while on the way out. He advised us to keep the OPL2 sound chip on the Steckschwein, because the OPL2 chip is still not outbid.</description><content>&lt;p>VCF 2018 in Berlin was great! We&amp;rsquo;ve met interesting people there. Got a handshake with Scot W. Stevenson who for(th)ced us to use his &lt;a href="https://github.com/scotws/TaliForth2">TaliForth2&lt;/a> ;)&lt;/p>
&lt;p>Later on Saturday &lt;a href="http://www.adlibtracker.net/downloads.php">Daniel Illgen&lt;/a> - maintainer of the Adlib Tracker II for Linux - had decided to honor us with his OPL2 knowledge while on the way out. He advised us to keep the OPL2 sound chip on the Steckschwein, because the OPL2 chip is still not outbid. We hat doubts at first, but then we could listen to OPL2 with so called &amp;ldquo;software low frequency oscillation&amp;rdquo; (soft lfo) and the drums and bass sounds great!&lt;/p>
&lt;p>Beside the VCF there where talks about demos and the history of the demoscene then and now. There where two interesting and awesome talks given by &amp;ldquo;&lt;a href="http://svolli.de/">SvOlli&lt;/a>&amp;rdquo; about the demoscene and demo coding on the Atari VCS (Stella).&lt;/p>
&lt;p>Here are the slides of out talks and Links to the livestream from Saturday 13.10.2018.&lt;/p>
&lt;ul>
&lt;li>Steckschwein - &lt;a href="https://steckschwein.files.wordpress.com/2018/10/the-history.pdf">The history and why it&amp;rsquo;s called &amp;ldquo;Steckschwin&amp;rdquo;&lt;/a>&lt;/li>
&lt;li>Steckschwein - &lt;a href="https://steckschwein.files.wordpress.com/2018/10/asm_tests_ci.pdf">6502 Test Driven Development and Continuous Integration&lt;/a>&lt;/li>
&lt;li>Livestream: &lt;a href="https://media.ccc.de/c/vcfb18">https://vcfb.de/2018/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Many thanks to &lt;a href="http://www.stefan-hoeltgen.de/">Dr. Stefan Höltgen&lt;/a> and his team arround the VCFB which made it possible that we could take a part on that cool event!&lt;/p></content></item><item><title>Meltdown / Spectre</title><link>https://beta.steckschwein.de/post/meltdown-spectre/</link><pubDate>Fri, 05 Jan 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/meltdown-spectre/</guid><description>Aufgrund der verwendeten überlegenen Prozessortechnologie ist das Steckschwein nicht von den aktuellen Prozessor-Sicherheitslücken Meltdown bzw. Spectre betroffen.</description><content>&lt;p>Aufgrund der verwendeten überlegenen Prozessortechnologie ist das Steckschwein nicht von den aktuellen Prozessor-Sicherheitslücken Meltdown bzw. Spectre betroffen.&lt;/p></content></item><item><title>Logikanalyse II [UPDATE]</title><link>https://beta.steckschwein.de/post/logikanalyse-ii/</link><pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/logikanalyse-ii/</guid><description>Inzwischen sind die 74F00 eingetroffen und der 74HCT00 durch einen ebensolchen ersetzt. Das Oszilloskopbild sieht gleich deutlich besser aus:
gelb: /WE, blau: A9
Der Schreibvorgang wird also jetzt zumindest abgeschlossen, bevor sich die Adresse auf dem Adressbus ändert. Das ist schonmal viel sauberer.
Nur leider hat es das Problem nicht gelöst, das Steckschwein läuft mit den &amp;ldquo;richtigen&amp;rdquo; RAMs immer noch instabil, was sich insbesondere bei BASIC-Programmen bemerkbar macht:
Wäre auch zu einfach gewesen.</description><content>&lt;p>Inzwischen sind die 74F00 eingetroffen und der 74HCT00 durch einen ebensolchen ersetzt. Das Oszilloskopbild sieht gleich deutlich besser aus:&lt;/p>
&lt;p>&lt;img src="images/tekway449_3.gif" alt=""> gelb: /WE, blau: A9&lt;/p>
&lt;p>Der Schreibvorgang wird also jetzt zumindest abgeschlossen, bevor sich die Adresse auf dem Adressbus ändert. Das ist schonmal viel sauberer.&lt;/p>
&lt;p>Nur leider hat es das Problem nicht gelöst, das Steckschwein läuft mit den &amp;ldquo;richtigen&amp;rdquo; RAMs immer noch instabil, was sich insbesondere bei BASIC-Programmen bemerkbar macht:&lt;/p>
&lt;p>&lt;img src="images/photo_2017-05-04_19-56-29.jpg" alt="photo_2017-05-04_19-56-29">&lt;/p>
&lt;p>Wäre auch zu einfach gewesen.&lt;/p>
&lt;p>&lt;strong>[UPDATE]&lt;/strong> Ein weiterer Test mit anderen 55ns-SRAMs, nämlich Bausteinen von BSI im TSOP28-Gehäuse auf DIP28-Adaptern, lief problemlos durch. Das BASIC-Programm, mit dem wir testen, lief 2 Tage problemlos durch. Dies ist insofern bemerkenswert, als dass das Steckschwein mit diesen Bausteinen vorher überhaupt nicht lief. Also doch ein Erfolg. Warum die 55ns-Chips von Alliance Memory Probleme machen, müssen wir noch untersuchen.&lt;/p>
&lt;p>&lt;img src="images/photo_2017-05-06_19-57-10.jpg" alt=""> TSOP28-SRAMs auf DIP28 Adapter&lt;/p></content></item><item><title>Logikanalyse</title><link>https://beta.steckschwein.de/post/logikanalyse/</link><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/logikanalyse/</guid><description>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.
Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.
Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2.</description><content>&lt;p>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.&lt;/p>
&lt;p>&lt;img src="images/logic_analyzer.jpg" alt=""> Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.&lt;/p>
&lt;p>Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2. Takthälfte für Buszugriffe nutzt. Diese ist nur 62,5ns lang. Von dieser Zeit geht ausserdem noch die Durchlaufzeit der Adressdekodierung und weiterer Glue-Logik ab. Eigens angeschaffte neue SRAMs von Alliance Memory mit 55ns Zugriffszeit sollten also ganz knapp schnell genug sein. Trotzdem treten mit diesen immer wieder merkwürdig zufällige Abstürze auf, die 100ns-Chips laufen dagegen problemlos.&lt;/p>
&lt;p>Also ran an die Maschine. Hierbei zeigte sich auch schon schnell etwas Merkwürdiges:&lt;/p>
&lt;p>&lt;img src="images/we_addr.png" alt=""> Analyse von Adress- und Datenbus sowie Steuersignale&lt;/p>
&lt;p>Es fiel etwas unangenehm auf, dass die steigende Flanke von /WE (Ende des Schreibzugriffs) direkt mit der Änderung des Adressbus zusammenfällt. Idealerweise sollte der Schreibzugriff beendet sein, bevor am Adressbus eine andere Adresse anliegt. Das Datenblatt nennt die Zeitspanne zwischen der steigenden Flanke von /WE und einer Änderung auf dem Adressbus tWR (Write Recovery Time):&lt;/p>
&lt;p>&lt;img src="images/sram_timing.png" alt="sram_timing">&lt;/p>
&lt;p>Laut Diagramm soll also /WE high werden, &lt;strong>bevor&lt;/strong> sich der Adressbus ändert. Im Datenblatt selbst ist die Write Recovery Time mit 0ns angegeben, und zwar bei beiden SRAMs, die 100ns-Typen sowie bei den 55ns-Bausteinen. Das würde bedeutet, dass die steigende Flanke von /WE mit einer Änderung der Adresse zeitlich zusammenfallen darf. Der verwendete Logicanalyzer hat eine Auflösung von 10ns, sodass man eigentlich nur sagen kann, dass sich /WE und der Adressbus im selben Zeitraum von 10ns ändern. Also schauen wir uns /WE und eine zufällige Adressleitung nochmal unterm Oszilloskop an.&lt;/p>
&lt;p>&lt;img src="images/oszi.jpg" alt=""> /WE und A9 unterm Oszilloskop. Gelb: /WE, Blau: A9&lt;/p>
&lt;p>Offenbar ändert sich der Adressbus, &lt;strong>bevor&lt;/strong> mit der steigenden Flanke von /WE der Schreibzugriff endet! Einen ausreichend schnellen Chip vorausgesetzt, könnte der anliegende Schreibzugriff womöglich in die neue Adresse hereingeschleppt werden. Wie dem auch sei, auf jeden Fall etwas, das so nicht sein darf! Wir halten die 0ns Write Recovery Time nicht ein, indem wir sie um ca. 4ns unterschreiten.&lt;/p>
&lt;p>/OE und /WE für die RAMs wird bei uns durch 3 NAND-Gatter in einem 74HCT00 aus der r/W-Leitung und dem Systemtakt erzeugt. Ein 74HCT00 hat eine Durchlaufzeit von ca. 9ns. Als nächstes werden wir also stattdessen einen 74F00 verwenden, der uns mit 3.7ns Durchlaufzeit wieder in den Bereich tWR &amp;gt; 0ns bringen sollte. Sollte es das nicht bringen, werden wir uns etwas grundsätzlichere Gedanken machen müssen.&lt;/p></content></item><item><title>Neue CPU-Boards</title><link>https://beta.steckschwein.de/post/neue-cpu-boards/</link><pubDate>Tue, 08 Mar 2016 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/neue-cpu-boards/</guid><description>Wir haben vor, eine neue Revision der Steckschwein-Prototyp-Platinen herzustellen. Den Anfang macht ein neues CPU-Board mit einigen Bugfixes und den in Chiptuning beschriebenen zusätzlichen GAL als Waitstate-Generator, sowie einem geändertem Stromanschluss: In Zukunft wird es möglich sein, das Steckschwein mit nur 5V per USB, über einen Rundstecker oder wie gehabt über einen Pin-Header zu versorgen. Die Layouts sind schon fertig:
Bestückungsseite
Lötseite</description><content>&lt;p>Wir haben vor, eine neue Revision der Steckschwein-Prototyp-Platinen herzustellen. Den Anfang macht ein neues CPU-Board mit einigen Bugfixes und den in &lt;a href="http://www.steckschwein.de/index.php/2016/01/30/chiptuning/">Chiptuning&lt;/a> beschriebenen zusätzlichen GAL als Waitstate-Generator, sowie einem geändertem Stromanschluss: In Zukunft wird es möglich sein, das Steckschwein mit nur 5V per USB, über einen Rundstecker oder wie gehabt über einen Pin-Header zu versorgen. Die Layouts sind schon fertig:&lt;/p>
&lt;p>&lt;img src="images/top.png" alt=""> Bestückungsseite&lt;/p>
&lt;p>&lt;img src="images/bottom.png" alt=""> Lötseite&lt;/p></content></item><item><title>Chiptuning</title><link>https://beta.steckschwein.de/post/chiptuning/</link><pubDate>Sat, 30 Jan 2016 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/chiptuning/</guid><description>An den Heimcomputern von &amp;ldquo;damals&amp;rdquo; gemessen ist das Steckschwein mit 4 MHz durchaus einer der schnelleren 6502-Rechner. Damals waren zumeist Taktraten von 1 MHz üblich. Einige wenige hatten deutlich mehr, wie z.B. der Apple IIgs (65816) mit 2.8 MHz. Einen 4 MHz-65(C)02-Heimcomputer hat es damals nach unserem Informationsstand nicht gegeben.
Nun ist es aber so, dass aktuell erhältliche 65c02-CPUs von WDC offiziell mit bis zu 14MHz getaktet werden können, inoffiziell wurden schon problemlos Taktraten von 20 MHz erreicht.</description><content>&lt;p>An den Heimcomputern von &amp;ldquo;damals&amp;rdquo; gemessen ist das Steckschwein mit 4 MHz durchaus einer der schnelleren 6502-Rechner. Damals waren zumeist Taktraten von 1 MHz üblich. Einige wenige hatten deutlich mehr, wie z.B. der Apple IIgs (65816) mit 2.8 MHz. Einen 4 MHz-65(C)02-Heimcomputer hat es damals nach unserem Informationsstand nicht gegeben.&lt;/p>
&lt;p>Nun ist es aber so, dass aktuell erhältliche 65c02-CPUs von WDC offiziell mit bis zu 14MHz getaktet werden können, inoffiziell wurden schon problemlos Taktraten von 20 MHz erreicht. Da ist also noch Raum für eine Prise Größenwahn. Den Takt des Steckschweins pauschal zu erhöhen funktioniert nicht. Zu viele Bausteine kommen dann nicht mehr mit. Das verwendete Atmel 28c256 EEPROM hat eine Zugriffszeit von 150ns. Im WDC-Datenblatt ist tACC des Prozessors bei 4MHz mit 145ns angegeben. Also ist das stand jetzt schon etwas eng. Schneller takten geht also schon allein deswegen auf keinen Fall. Für den Videochip TMS9929 und den Soundchip gilt ähnliches. Das SRAM hingegen läßt sich problemlos gegen Bausteine von Alliance Memory mit 55ns Zugriffzeit austauschen. Damit sollten Taktraten von um die 10 MHz möglich sein.&lt;/p>
&lt;p>Was wir also brauchen ist eine Möglichkeit, auf RAM und VIA (sofern auch WDC und damit gleich schnell)  mit voller Geschwindigkeit zuzugreifen, währen wir den Prozessor bei Zugriffen auf ROM, Video- und Soundchip für 1-2 Zyklen stoppen. Schließlich ist man geschätzt zu 99% im RAM unterwegs.&lt;/p>
&lt;p>Erste Überlegungen gingen in die Richtung, die Taktfrequenz umschaltbar zu machen, je nachdem, welcher Baustein auf dem Bus von der CPU angesprochen wird. Dieses Prinzip birgt zwei entscheidende Nachteile:&lt;/p>
&lt;ol>
&lt;li>Man darf den Takt nicht einfach so umschalten. Erwischt man einen ungünstigen Moment, kann dies die CPU zum Absturz bringen. Näheres kann in einem &lt;a href="http://www.6502.org/mini-projects/clock-switching/clock-switching.html">entsprechenden Artikel auf 6502.org&lt;/a> nachgelesen werden.&lt;/li>
&lt;li>Die VIA-Timer sind direkt abhängig von der Taktfrequenz. Software, die diese benutzt, könnte sich nicht mehr auf diese verlassen, wenn sich die Taktfrequenz ständig ändert.&lt;/li>
&lt;/ol>
&lt;p>Zum Glück bietet der 6502 auch hier genau das, was wir brauchen: Den RDY-Pin. Wird dieser auf LOW gezogen, &amp;ldquo;friert&amp;rdquo; der 6502 ein. Kehrt RDY wieder auf HIGH zurück, macht die CPU dort weiter, wo sie unterbrochen wurde. Durch geschicktes Ansteuern dieser Leitung können wir den Prozessor also veranlassen, auf langsamere Bausteine zu warten. Dieses Konzept nennt sich Wait States (eben Wartezyklen) und ist bei aktuellen Computern gang und gäbe.&lt;/p>
&lt;p>Im Grunde genommen brauchen wir also einen Zähler, der die Taktfrequenz des Systems herunterteilt, und eine Selektionslogik, über die sich wählen läßt, welcher Ausgang des Zählers die Grundlage für das RDY-Signal bilden soll, und damit die Anzahl der Wait States bestimmt. Dieses Signal bildet invertiert das RDY-Signal.&lt;/p>
&lt;p>&lt;img src="images/tekway331_2.gif" alt=""> Gelb: RDY, Blau: PHI2 (Systemtakt) - 2 Wait States für den Videochip&lt;/p>
&lt;p>Zur folgender Logik haben wir uns vom &lt;a href="http://sbc.rictor.org/parts/wsgen.html">Waitstate-Generator von Daryl Rictor&lt;/a>  stark inspirieren lassen. Im Wesentlichen haben wir die Adressdekoderlogik zugunsten der bereits ausdekodierten /CS_&amp;hellip; Leitungen entfernt, sowie die Syntax von CUPL nach GALasm überführt.&lt;/p>
&lt;p>&lt;img src="images/img_20160130_144611.jpg" alt=""> Waitstate-Generator-Prototyp auf dem Steckbrett&lt;/p>
&lt;p>Folgende Schaltung erzeugt entsprechend 1 oder 2 Waitstates, und versetzt den Ausgangspin in den Tri-State-Zustand, damit auch andere Bausteine Wait-States anfordern können. Sollten einmal mehr Waitstates nötig werden, lassen sich noch 1 oder 2 Zählerstufen hinzufügen, um 4 oder 8 Waitstates zu erzeugen.&lt;/p>
&lt;pre tabindex="0">&lt;code>GAL16V8
RDYGEN
Clock ROM VIA UART VDP SND NC NC Clear GND
/OE RDY W1 W2 NC NC NC Q1 Q0 VCC
W2 = ROM \* VIA \* UART \* SND \* /VDP
+ ROM \* VIA \* UART \* /SND \* VDP
W1 = W2
+ /ROM \* VIA \* UART \* VDP
Q0.R = W1 \* /Q0 \* /Q1 \* Clear
+ W2 \* /Q0 \* /Q1 \* Clear
Q1.R = W2 \* /Q1 \* Q0 \* Clear
RDY.T = /Q0 \* /Q1
RDY.E = W1
&lt;/code>&lt;/pre>&lt;p>DESCRIPTION:
Generation of /RDY line modeled after &lt;a href="http://sbc.rictor.org/parts/wsgen.html">http://sbc.rictor.org/parts/wsgen.html&lt;/a>
and adapted to galasm syntax&lt;/p>
&lt;p>Wir freuen uns jetzt über ein 8MHz-Steckschwein. Das Tolle ist, dass die VIA ebenfalls mit 8 MHz und ohne Waitstates betrieben werden kann, sodass sich die erhöhte Geschwindigkeit 1:1 auf den SPI-Bus auswirkt. Zugriffe auf die SD-Karte sind damit gleich doppelt so schnell.&lt;/p></content></item><item><title>Schaltplan</title><link>https://beta.steckschwein.de/post/schaltplan/</link><pubDate>Sat, 05 Apr 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/schaltplan/</guid><description>Damit Klarheit darüber herrscht, worum es überhaupt geht, haben wir den Schaltplan in die einzelnen Gruppen (Prozessor+ Freunde, Speicher, UART) zerlegt.
Die aktuelle Stückliste liest sich laut Eagle folgendermaßen:
Part Value Device C1 100n C5/3 C3 1n C-EU025-025X050 C4 10n C-EU025-025X050 C5 10µF CPOL-EUE2,5-6E C6 100n C5/3 C7 100n C5/3 C8 100n C5/3 C12 1µF CPOL-EUE2,5-6E C13 100n C5/3 C14 100n C5/3 C15 100n C5/3 C16 1µF CPOL-EUE2,5-6E C17 1µF CPOL-EUE2,5-6E C18 1µF CPOL-EUE2,5-6E C19 1µF CPOL-EUE2,5-6E IC1 CY62256LL-PC CY62256LL-PC IC3 CY62256LL-PC CY62256LL-PC IC4 NE555 NE555 IC5 28c64 2864 IC6 16550 UART XR-16C550P IC8 74LS06N 74LS06N IC9 GAL22V10 22V10 IC10 MAX232 MAX232 QG1 2MHz XO-14 QG2 1.</description><content>&lt;p>Damit Klarheit darüber herrscht, worum es überhaupt geht, haben wir den Schaltplan in die einzelnen Gruppen (Prozessor+ Freunde, Speicher, UART) zerlegt.&lt;/p>
&lt;p>Die aktuelle Stückliste liest sich laut Eagle folgendermaßen:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Part    &lt;/th>
&lt;th>Value          &lt;/th>
&lt;th>Device&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>C1      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C3      &lt;/td>
&lt;td>1n            &lt;/td>
&lt;td>C-EU025-025X050&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C4      &lt;/td>
&lt;td>10n            &lt;/td>
&lt;td>C-EU025-025X050&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C5      &lt;/td>
&lt;td>10µF          &lt;/td>
&lt;td>CPOL-EUE2,5-6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C6      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C7      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C8      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C12      &lt;/td>
&lt;td>1µF            &lt;/td>
&lt;td>CPOL-EUE2,5-6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C13      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C14      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C15      &lt;/td>
&lt;td>100n          &lt;/td>
&lt;td>C5/3           &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C16      &lt;/td>
&lt;td>1µF            &lt;/td>
&lt;td>CPOL-EUE2,5-6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C17      &lt;/td>
&lt;td>1µF            &lt;/td>
&lt;td>CPOL-EUE2,5-6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C18      &lt;/td>
&lt;td>1µF            &lt;/td>
&lt;td>CPOL-EUE2,5-6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C19      &lt;/td>
&lt;td>1µF            &lt;/td>
&lt;td>CPOL-EUE2,5-6E&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC1      &lt;/td>
&lt;td>CY62256LL-PC  &lt;/td>
&lt;td>CY62256LL-PC  &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC3      &lt;/td>
&lt;td>CY62256LL-PC  &lt;/td>
&lt;td>CY62256LL-PC  &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC4      &lt;/td>
&lt;td>NE555          &lt;/td>
&lt;td>NE555        &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC5      &lt;/td>
&lt;td>28c64          &lt;/td>
&lt;td>2864          &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC6      &lt;/td>
&lt;td>16550 UART    &lt;/td>
&lt;td>XR-16C550P    &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC8      &lt;/td>
&lt;td>74LS06N        &lt;/td>
&lt;td>74LS06N      &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC9      &lt;/td>
&lt;td>GAL22V10      &lt;/td>
&lt;td>22V10        &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IC10    &lt;/td>
&lt;td>MAX232        &lt;/td>
&lt;td>MAX232         &lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>QG1      &lt;/td>
&lt;td>2MHz          &lt;/td>
&lt;td>XO-14&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>QG2      &lt;/td>
&lt;td>1.8432MHz      &lt;/td>
&lt;td>XO-14&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R2      &lt;/td>
&lt;td>3.3k          &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R3      &lt;/td>
&lt;td>1M            &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R4      &lt;/td>
&lt;td>1M            &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R5      &lt;/td>
&lt;td>3.3k          &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R6      &lt;/td>
&lt;td>3.3k          &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R7      &lt;/td>
&lt;td>3.3k          &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R8      &lt;/td>
&lt;td>3.3k          &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R9      &lt;/td>
&lt;td>4.7k          &lt;/td>
&lt;td>R-EU_0204/7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S1      &lt;/td>
&lt;td>DTE6          &lt;/td>
&lt;td>DTE6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>U1      &lt;/td>
&lt;td>65c02          &lt;/td>
&lt;td>G65SC02P&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>U3      &lt;/td>
&lt;td>65c22          &lt;/td>
&lt;td>G65SC22P&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>V1      &lt;/td>
&lt;td>74138N        &lt;/td>
&lt;td>74138N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>V2      &lt;/td>
&lt;td>74LS00N        &lt;/td>
&lt;td>74LS00N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>X2      &lt;/td>
&lt;td>RS232          &lt;/td>
&lt;td>F09HP&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;img src="images/28878-cpu.png" alt="CPU">
Der 65c02-Prozessor nebst Oszillator und RESET-Schaltung, welche aus dem Commodore-PET übernommen wurde und dem GAL, der zu Dekodierung des Adressbereichs von $8000 bis $ffff dient. Nicht zu sehen ist der Pull-Up-Widerstand für die BE (Bus Enable)-Leitung der WDC-Variante des 65x02, ohne den der Prozessor in einen Tri-State-Zustand geht und sich vom Bus abkoppelt.&lt;/p>
&lt;p>&lt;img src="images/e4c5e-romram.png" alt="ROMRAM">
Das EEPROM und die beiden 32k SRAM-Bausteine. Etwas schwer zu erkennen: die Adressleitung A15 des Prozessors dient den &amp;ldquo;unteren&amp;rdquo; 32k (IC1) als CS-Signal. Das CS_HIRAM-Signal hingegen erzeugt der GAL (siehe oben). Der Schaltplan unterschlägt, dass wir in Wirklichkeit ein 28c256-EEPROM verwendet haben, welches wir durch auf Masse legen von A14 und A13 auf 8k &amp;ldquo;kastriert&amp;rdquo; haben.&lt;/p>
&lt;p>&lt;img src="images/e0273-uart.png" alt="UART">
Der UART + Glue Logic, um dessen Bus-Interface an das des 65c02 anzupassen. Die Invertierung von RESET und INT(IRQ) übernimmt ein 74ls06. Beim RESET-Signal ist aufgrund dessen Open Collector-Treibers noch ein Pull-Up-Widerstand nötig.&lt;/p>
&lt;p>&lt;img src="images/b3061-rs232.png" alt="rs232">
Der Vollständigkeit halber.&lt;/p>
&lt;p>&lt;img src="images/9ee9c-via.png" alt="VIA"> Die Anbindung der 65x22 VIA gestaltet sich trivial und erweitert unseren kleinen Rechner um vielseitige IO-Möglichkeiten.&lt;/p></content></item></channel></rss>