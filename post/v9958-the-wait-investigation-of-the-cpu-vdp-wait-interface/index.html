<!doctype html><html lang=en><head><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface :: Steckschwein</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://beta.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/><link rel=stylesheet href=https://beta.steckschwein.de/assets/style.css><link rel=stylesheet href=https://beta.steckschwein.de/assets/green.css><link rel=apple-touch-icon href=https://beta.steckschwein.de/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://beta.steckschwein.de><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="V9958 - &#34;The WAIT&#34; - investigation of the CPU/VDP /WAIT interface"><meta property="og:description" content="&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings"><meta property="og:url" content="https://beta.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/"><meta property="og:site_name" content="Steckschwein"><meta property="og:image" content="https://beta.steckschwein.de"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="64k"><meta property="article:section" content="6502"><meta property="article:section" content="65c02"><meta property="article:section" content="9918"><meta property="article:section" content="allgemein"><meta property="article:section" content="assembly"><meta property="article:section" content="cpu"><meta property="article:section" content="experiment"><meta property="article:section" content="nop"><meta property="article:section" content="steckschwein"><meta property="article:section" content="timing"><meta property="article:section" content="tms9929"><meta property="article:section" content="v9958"><meta property="article:section" content="vdp"><meta property="article:section" content="video"><meta property="article:section" content="video-chip"><meta property="article:section" content="waitstate"><meta property="article:published_time" content="2018-10-22 00:00:00 +0000 UTC"></head><body class=green><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Steckschwein</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/home/>The Project</a></li><li><a href=/hardware/>Hardware</a></li><li><a href=/software/>Software</a></li><li><a href=/impressum/>Impressum</a></li><li><a href=/post/>Posts</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/home/>The Project</a></li><li><a href=/hardware/>Hardware</a></li><li><a href=/software/>Software</a></li><li><a href=/impressum/>Impressum</a></li><li><a href=/post/>Posts</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://beta.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/>V9958 - &ldquo;The WAIT&rdquo; - investigation of the CPU/VDP /WAIT interface</a></h1><div class=post-meta><span class=post-date>2018-10-22</span></div><div class=post-content><div><p>&mldr; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.</p><p>as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</p><ol><li>the first 2 bytes send to vdp during a write are always register writes which require a short delay of at least 2µs in between each byte</li><li>the write of the 3rd byte (after the 2nd) requires a delay of 8µs. any further &ldquo;single byte transfer&rdquo; - during a vram write - also requires the 8µs delay. the same is true if we want to initiate a register write direclty after a vram write.</li><li>the 3rd and n-th byte write to port #3 (index register port) during a bulk register write requires only the 2µs between each byte</li></ol><p>With this in mind, we can optimize our library a little bit by using different &ldquo;nop slides&rdquo; for address setup and vram writes.</p><p>We enhance our vdp.inc and built two macros which provide the different delay we need.</p><p>.macro vdp_wait_s
jsr vdp_nopslide_2m ; 2m for 2µs wait
&mldr;</p><p>.macro vdp_wait_l
jsr vdp_nopslide_8m ; 8m for 8µs wait
&mldr;</p><p>steckSchwein is running at 8Mhz, so we also defined some equations and used ca65 macros to build our nop slides.</p><p>.define CLOCK_SPEED_MHZ 8</p><p>; long delay with 6µ+2µs (below)
MAX_NOPS_8M = (6 * 1000 / (1000 / CLOCK_SPEED_MHZ)) / 2
; 8Mhz, 125ns per cycle, wait 6µs = 6000ns
; = 6000ns / 125ns = 48cl / 2 => 24 NOP</p><p>; short delay with 2µs wait
MAX_NOPS_2M = (2 * 1000 / (1000 / CLOCK_SPEED_MHZ) -12) / 2
; -12 => jsr/rts = 2 * 6cl = 12cl must be subtract</p><p>.macro m_vdp_nopslide
vdp_nopslide_8m:
; long delay with 6+2 2µs wait
.repeat MAX_NOPS_8M
nop
.endrepeat
vdp_nopslide_2m:
.repeat MAX_NOPS_2M
nop
.endrepeat
rts
.endmacro</p><p>Another interesting thing would be, &ldquo;how does the /WAIT&rdquo; behave in this situation? the assumption here is, that the /WAIT will behave in the way as specified. so /WAIT will be go low at least after 130ns from CSW. so to handover the /RDY handling to the vdp via the /WAIT pin, we have to apply only 1 wait state from our WS-Gen. after one wait state, we can release the /RDY low from our WS so that the vdp /WAIT can drive /RDY as needed.</p><p>Back home, Thomas did the test and changed the waitstate generator firmware for the GAL16V8.</p><p>The equation was</p><p>W2 = ROM * UART * SND * /VDP
W1 = W2
+ /ROM * UART * VDP</p><p>and was changed to</p><p>W2 = /SND
W1 = W2
+ /ROM ; /ROM wait state if ROM is cs
+ /VDP ; /VDP wait state if VDP is cs</p><p>So finally, we only need one wait state from the waitstate generator to access the VDP. If the VDP requires more time - surely - during a video memory access it will drive /WAIT to low as long as needed. So after the explcit 1WS from our wait state generator we now hand over the /RDY control to the VDP. How our /RDY and /WAIT really work together is subject to one of our next sessions where we&rsquo;re going to measure the things with a logic analyzer and oscilloscope. Nevertheless, it works in this way and it works exaclty as specified within the datasheet.</p></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://beta.steckschwein.de/assets/main.js></script>
<script src=https://beta.steckschwein.de/assets/prism.js></script></div></body></html>