<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ttl on Steckschwein</title><link>https://beta.steckschwein.de/categories/ttl/</link><description>Recent content in ttl on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 01 May 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://beta.steckschwein.de/categories/ttl/index.xml" rel="self" type="application/rss+xml"/><item><title>Logikanalyse</title><link>https://beta.steckschwein.de/post/logikanalyse/</link><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/logikanalyse/</guid><description>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.
Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.
Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2.</description><content>&lt;p>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.&lt;/p>
&lt;p>&lt;img src="images/logic_analyzer.jpg" alt=""> Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.&lt;/p>
&lt;p>Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2. Takthälfte für Buszugriffe nutzt. Diese ist nur 62,5ns lang. Von dieser Zeit geht ausserdem noch die Durchlaufzeit der Adressdekodierung und weiterer Glue-Logik ab. Eigens angeschaffte neue SRAMs von Alliance Memory mit 55ns Zugriffszeit sollten also ganz knapp schnell genug sein. Trotzdem treten mit diesen immer wieder merkwürdig zufällige Abstürze auf, die 100ns-Chips laufen dagegen problemlos.&lt;/p>
&lt;p>Also ran an die Maschine. Hierbei zeigte sich auch schon schnell etwas Merkwürdiges:&lt;/p>
&lt;p>&lt;img src="images/we_addr.png" alt=""> Analyse von Adress- und Datenbus sowie Steuersignale&lt;/p>
&lt;p>Es fiel etwas unangenehm auf, dass die steigende Flanke von /WE (Ende des Schreibzugriffs) direkt mit der Änderung des Adressbus zusammenfällt. Idealerweise sollte der Schreibzugriff beendet sein, bevor am Adressbus eine andere Adresse anliegt. Das Datenblatt nennt die Zeitspanne zwischen der steigenden Flanke von /WE und einer Änderung auf dem Adressbus tWR (Write Recovery Time):&lt;/p>
&lt;p>&lt;img src="images/sram_timing.png" alt="sram_timing">&lt;/p>
&lt;p>Laut Diagramm soll also /WE high werden, &lt;strong>bevor&lt;/strong> sich der Adressbus ändert. Im Datenblatt selbst ist die Write Recovery Time mit 0ns angegeben, und zwar bei beiden SRAMs, die 100ns-Typen sowie bei den 55ns-Bausteinen. Das würde bedeutet, dass die steigende Flanke von /WE mit einer Änderung der Adresse zeitlich zusammenfallen darf. Der verwendete Logicanalyzer hat eine Auflösung von 10ns, sodass man eigentlich nur sagen kann, dass sich /WE und der Adressbus im selben Zeitraum von 10ns ändern. Also schauen wir uns /WE und eine zufällige Adressleitung nochmal unterm Oszilloskop an.&lt;/p>
&lt;p>&lt;img src="images/oszi.jpg" alt=""> /WE und A9 unterm Oszilloskop. Gelb: /WE, Blau: A9&lt;/p>
&lt;p>Offenbar ändert sich der Adressbus, &lt;strong>bevor&lt;/strong> mit der steigenden Flanke von /WE der Schreibzugriff endet! Einen ausreichend schnellen Chip vorausgesetzt, könnte der anliegende Schreibzugriff womöglich in die neue Adresse hereingeschleppt werden. Wie dem auch sei, auf jeden Fall etwas, das so nicht sein darf! Wir halten die 0ns Write Recovery Time nicht ein, indem wir sie um ca. 4ns unterschreiten.&lt;/p>
&lt;p>/OE und /WE für die RAMs wird bei uns durch 3 NAND-Gatter in einem 74HCT00 aus der r/W-Leitung und dem Systemtakt erzeugt. Ein 74HCT00 hat eine Durchlaufzeit von ca. 9ns. Als nächstes werden wir also stattdessen einen 74F00 verwenden, der uns mit 3.7ns Durchlaufzeit wieder in den Bereich tWR &amp;gt; 0ns bringen sollte. Sollte es das nicht bringen, werden wir uns etwas grundsätzlichere Gedanken machen müssen.&lt;/p></content></item><item><title>WDC und kein Ende</title><link>https://beta.steckschwein.de/post/wdc-und-kein-ende/</link><pubDate>Fri, 26 Jun 2015 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/wdc-und-kein-ende/</guid><description>In der letzten Zeit war es hier etwas still ums Steckschwein, was aber nicht als Indiz für Untätigkeit gelten soll. Hauptsächlich haben wir uns auf das Schreiben von Code konzentriert, die Shell wurde weiterentwickelt, etc. Darüberhinaus gab es erste Experimente mit CPLDs. Auf dieser Basis sollen ja zukünftige Verbesserungen der Hardware entstehen, begonnen bei einem eigenständigen SPI-Controller bis hin zur Zusammenfassung der bestehenden Glue-Logik rund um die Adressdekodierung. Da ich mir zu diesem Zweck testhalber solche CPLD-Entwicklungsplatinchen auf Basis des XilinX XC9572XL habe kommen lassen, stellte sich also als erstes die Frage, wie sich dessen 3.</description><content>&lt;p>In der letzten Zeit war es hier etwas still ums Steckschwein, was aber nicht als Indiz für Untätigkeit gelten soll. Hauptsächlich haben wir uns auf das Schreiben von Code konzentriert, die Shell wurde weiterentwickelt, etc. Darüberhinaus gab es erste Experimente mit CPLDs. Auf dieser Basis sollen ja zukünftige Verbesserungen der Hardware entstehen, begonnen bei einem eigenständigen SPI-Controller bis hin zur Zusammenfassung der bestehenden Glue-Logik rund um die Adressdekodierung. Da ich mir zu diesem Zweck testhalber solche &lt;a href="http://www.seeedstudio.com/depot/xc9572xl-cpld-development-board-p-799.html">CPLD-Entwicklungsplatinchen auf Basis des XilinX XC9572XL&lt;/a> habe kommen lassen, stellte sich also als erstes die Frage, wie sich dessen 3.3V-basierte Logik mit dem 5V-Steckschwein vertragen würde. Zum CPLD hin wären ja keine Probleme zu erwarten, denn die IO-Pins des XC9572XL sind 5V-tolerant. Die Richtung vom CPLD zum Steckschwein bedarf also besonderer Betrachtung, denn es muss sichergestellt werden, dass alle Bausteine am Bus, die mit dem CPLD verbunden sind, dessen 3.3V-Logikpegel zuverlässig erkennen. Als einzige wirklich problematische Komponente stellte sich hier - &lt;a href="https://beta.steckschwein.de/post/murphy-iii-timing-ist-alles/">wieder mal&lt;/a> - der auf meinem Steckschwein eingesetzte (Marko nutzt einen 65c02 von Rockwell) WDC 65c02 heraus. Das Datenblatt gibt als &amp;ldquo;Input High Voltage&amp;rdquo;, also die Spannung, ab der auf der entsprechenden Leitung (BE, D0 -D7, RDY, /SO, /IRQ, /NMI, PHI2, /RES) eine logische 1 erkannt wird, mit &amp;ldquo;VDD*0.7&amp;rdquo; an. Bei einer Betriebsspannung von 5V also 3,5V. Mit 3.3V-Pegeln also schonmal nicht kompatibel. Geschweige denn mit TTL-Pegeln. Die leider so ziemlich alle auf dem Datenbus liegenden Bausteine verwenden, mit Ausnahme der WDC 65c22 VIA.  Alle anderen Bausteine geben im Datenblatt als &amp;ldquo;High Level Output Voltage&amp;rdquo; Werte von 2.4-2.7V an.  Kann also gar nicht passen. Dass das Steckschwein trotzdem mit dem WDC funktioniert ist ganz offenbar Glück bzw. der Tatsache geschuldet, dass der Chip dann doch toleranter ist als das Datenblatt uns glauben machen will.  Trotzdem nicht sauber. In zukünftigen Revisionen müssen wir also zwischen CPU und Datenbus einen 74HCT245-Buffer eindesignen, der durch TTL-kompatible Eingänge und CMOS-Ausgänge die Pegelunterschiede ausbügelt. Gleiches gilt auch für weitere Experimente mit dem 3.3V-CPLD. Oder auch mit dessen 5V-Vorgänger XC9572.  Zusammenfassend also noch einmal die Besonderheiten des 65c02 von WDC:&lt;/p>
&lt;ol>
&lt;li>Unterschiede im Pinout Pin1 beim WDC ist nicht mehr GND, sondern der Ausgang /VP (Vector Pull), der low wird, wenn die CPU an einen Vektor springt (IRQ, NMI, RESET) Pin 36 ist nur bei WDC /BE, sonst N.C. Dieser muss auf High liegen, sonst ist die CPU vom Bus abgekoppelt. Statt Takt an PHI0 anzulegen und den Rest des Systems mit PHI2 zu takten, wird bei WDC vorgeschrieben, CPU und restliches System mit dem an PHI0 angeschlossenen Oszillator zu takten&lt;/li>
&lt;li>Strafferes Timing Die wesentlich schnelleren WDC-Chips haben wesentlich kürzere Setup/Hold-Zeiten (10ns statt 30ns bei Rockwell)&lt;/li>
&lt;li>Nicht TTL-kompatibel Der WDC 65c02 erwartet wesentlich höhere Signalpegel, die entschieden über den TTL-Pegeln liegen. Dies hat auch &lt;a href="http://lc64.blogspot.de/2015/04/problems-with-wdc-w65c02.html">MrVossi bei der Entwicklung seines LC64&lt;/a> schon festgestellt. Bei ihm hat es sich allerdings deutlicher geäußert.&lt;/li>
&lt;/ol>
&lt;p>Die aktuelle Steckschwein-Revision ist somit trotz aller Bemühungen (Jumper für Takteingang, /BE, /VP) immer noch nicht mit dem WDC 65c02 kompatibel.  Im &lt;a href="https://beta.steckschwein.de/post/murphy-iii-timing-ist-alles/">Beitrag über das erste WDC-Abenteuer&lt;/a> hatte ich abschließend die Frage gestellt, wie man dann einen 65(c)02 in einem vorhandenen alten System mit einem WDC 65c02 ersetzen soll. Die wäre damit dann zumindest beantwortet: &lt;strong>überhaupt nicht!&lt;/strong>&lt;/p></content></item></channel></rss>