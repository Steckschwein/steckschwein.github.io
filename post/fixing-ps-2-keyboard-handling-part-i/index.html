<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Fixing PS/2 Keyboard handling (Part I) - Steckschwein</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Fixing PS/2 Keyboard handling (Part I)"><meta property="og:description" content="The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:
The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI. The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&rsquo;t the states of the keyboard LEDs."><meta property="og:type" content="article"><meta property="og:url" content="https://www.steckschwein.de/post/fixing-ps-2-keyboard-handling-part-i/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-11-14T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-14T00:00:00+00:00"><meta property="og:site_name" content="Steckschwein"><meta itemprop=name content="Fixing PS/2 Keyboard handling (Part I)"><meta itemprop=description content="The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:
The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI. The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&rsquo;t the states of the keyboard LEDs."><meta itemprop=datePublished content="2020-11-14T00:00:00+00:00"><meta itemprop=dateModified content="2020-11-14T00:00:00+00:00"><meta itemprop=wordCount content="609"><meta itemprop=keywords content="ps2,keyboard,spi,avr,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Fixing PS/2 Keyboard handling (Part I)"><meta name=twitter:description content="The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:
The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI. The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&rsquo;t the states of the keyboard LEDs."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=Steckschwein rel=home><div class="logo__item logo__text"><div class=logo__title>Steckschwein</div><div class=logo__tagline>An 8bit computer for the 21st century</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Blog</span></a></li><li class=menu__item><a class=menu__link href=/hardware/><span class=menu__text>Hardware</span></a></li><li class=menu__item><a class=menu__link href=/software/><span class=menu__text>Software</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li><li class=menu__item><a class=menu__link href=/impressum/><span class=menu__text>Impressum</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Fixing PS/2 Keyboard handling (Part I)</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-11-14T00:00:00Z>November 14, 2020</time></div></div></header><div class="content post__content clearfix"><p>The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:</p><ul><li>The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI.</li><li>The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&rsquo;t the states of the keyboard LEDs.</li></ul><p>Although mid- to long term, we likely might &ldquo;upgrade&rdquo; to USB anyway, but not without having done PS/2 right first. So, I will talk about integrating IRQ handling, and in a follow up post Marko will talk about how he got the PS/2 controller talking to the keyboard.</p><p>Luckily, during the design of the IO-board, we have been clever enough to hook IO-pins PC0 to PC2 to RESET_TRIG, NMI and IRQ, respectively. So on the hardware-side, we are very much ready.<br>First problem to solve is how to emulate an open collector output on the AVR controller. As it seems, a common way to do that is to disable the internal pullup of the pin, and have it configured as input to be &ldquo;tri state&rdquo;. When active, the pin gets activated as an output, and will pull the IRQ line low.</p><p><code>// pull IRQ line DDRC |= (1 &lt;&lt; IRQ);</code></p><p><code>// release IRQ line DDRC &= ~(1 &lt;&lt; IRQ);</code></p><p>Now that we know how to handle the IRQ-line, we need to figure out, WHEN to pull it. Obviously when a key was hit. And when to release it?</p><p>Finally, we decided to go the most simple way. The PS/2 controller will pull the IRQ line as long as there are more than 0 chars in the buffer. Once the buffer is empty, the IRQ-line will be released. This way, we do not need an interrupt register and hence no time consuming check of the latter, but need to do a little buffering on the steckOS-side.</p><p>This is all the code that&rsquo;s needed on the PS/2 controller side:</p><pre tabindex=0><code>    if (kb_buffcnt &gt; 0)
    {
        DDRC |= (1 &lt;&lt; IRQ);     // pull IRQ line
    }
    else
    {
        DDRC &amp;= ~(1 &lt;&lt; IRQ); // release IRQ line
    }
</code></pre><p>Now, we need to add a little handling code to the steckOS IRQ-handler. Since we do not have an interrupt register, we just check the keyboard last, after every &ldquo;known&rdquo; interrupt source has been handled.<br>To get around having to implement another keyboard buffer, we just use a single memory location, labelled &ldquo;key&rdquo;. The IRQ handler will only fetch a byte from the keyboard when the target location is zero (0), otherwise it will just exit.<br>The system getkey-routine will load the contents from that location into the A register, and overwrite the location with 0 again to enable fetching the next char from the buffer.</p><p>The SPI check code is the last bit in the IRQ-handler routine:</p><pre tabindex=0><code>@check_spi:  
    lda key  
    bne @exit  
    jsr fetchkey  
    bcc @exit  
    sta key  
  
@exit:  
    restore  
    rti
</code></pre><p>That&rsquo;s basically all that&rsquo;s needed. The former getkey-routine has been renamed to fetchkey, and the new getkey routine only handles the ZP buffer location while retaining the old behaviour including setting the carry flag when a byte has been received. This way, existing programs using the keyboard do not have to be modified.</p><p>Now, we finally have a chance of reacting to keystrokes during program execution without having to explicitly poll the keyboard. This enables us to handle Ctrl-C and such much more elegantly. Also, any REPL-like program (like the shell) does not have to constantly poll the SPI bus.</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/ps2/ rel=tag>ps2</a></li><li class=tags__item><a class="tags__link btn" href=/tags/keyboard/ rel=tag>keyboard</a></li><li class=tags__item><a class="tags__link btn" href=/tags/spi/ rel=tag>spi</a></li><li class=tags__item><a class="tags__link btn" href=/tags/avr/ rel=tag>avr</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2022 Steckschwein.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>