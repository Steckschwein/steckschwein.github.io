<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sound on Steckschwein</title><link>https://beta.steckschwein.de/categories/sound/</link><description>Recent content in sound on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 15 Dec 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://beta.steckschwein.de/categories/sound/index.xml" rel="self" type="application/rss+xml"/><item><title>V9958+OPL2-Boards are there</title><link>https://beta.steckschwein.de/post/v9958opl2-boards-are-there/</link><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/v9958opl2-boards-are-there/</guid><description>The newly made boards made their way from China to Munich. Starting now, the multi board version of the Steckschwein is made up of 3 Boards: CPU/Memory, IO/UART and V9958-OPL2.</description><content>&lt;p>The newly made boards made their way from China to Munich. Starting now, the multi board version of the Steckschwein is made up of 3 Boards: CPU/Memory, IO/UART and V9958-OPL2.&lt;/p>
&lt;p>&lt;img src="images/board.jpg" alt="">
&lt;img src="images/board_done.jpg" alt="">
&lt;img src="images/board_working.jpg" alt="">&lt;/p></content></item><item><title>New V9958-Board with integrated OPL2</title><link>https://beta.steckschwein.de/post/new-v9958-board-with-integrated-opl2/</link><pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/new-v9958-board-with-integrated-opl2/</guid><description>It&amp;rsquo;s time for another hardware upgrade. Since we really want to get our single board Steckschwein done, we are going for higher integration of our multiboard prototype. After integrating the UART to the IO-Board, we integrate the OPL2 sound part onto the V9958 video board, so the current Steckschwein multi board incarnations are reduced to three boards. We did postpone our plan to upgrade sound to OPL3 because Daniel Illgen, which we met at VCFb, convinced us with some awesome OPL2 tunes that OPL2 is still cool.</description><content>&lt;p>It&amp;rsquo;s time for another hardware upgrade. Since we really want to get our single board Steckschwein done, we are going for higher integration of our multiboard prototype. After integrating the UART to the IO-Board, we integrate the OPL2 sound part onto the V9958 video board, so the current Steckschwein multi board incarnations are reduced to three boards. We did postpone our plan to upgrade sound to OPL3 because Daniel Illgen, which we met at VCFb, convinced us with some awesome OPL2 tunes that OPL2 is still cool. Also, we save the extra oscillator, since the OPL2 can be clocked using the CPUCLK-Pin from the V9958, which happens to provide 3.58MHz.&lt;/p>
&lt;p>We did upgrade however the video ram. The first prototype had Bank 0 and Bank 1, maxing out vram at 128k. We decided to include the Extended memory bank, too, this time, giving the V9958 extra 64k, which can be accessed using the blitter command functions. Why not?&lt;/p>
&lt;p>&lt;img src="images/v9958-e1544277948324.png" alt=""> KiCad 3D rendering of the new board&lt;/p>
&lt;p>Also, to make the connector side more compact, we decided to not use RCA jacks for RGB anymore, but an 8pin DIN jack, which also carries the audio signal. So hooking up a 1084 Monitor or TV will only require a single cable. We use the same DIN jack and &lt;a href="https://gamesx.com/avpinouts/neoav.htm">pinout as the NeoGeo&lt;/a> uses, so there are even &lt;a href="https://www.retrogamingcables.co.uk/snk-neo-geo-aes-rgb-scart-cable-stereo-sound">ready made cables available&lt;/a>.&lt;/p></content></item><item><title>Musik</title><link>https://beta.steckschwein.de/post/musik/</link><pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/musik/</guid><description>Das Programmieren von Soundchips ist nicht trivial. Das habe ich damals auf dem C64 schon nicht kapiert. Mit dem Yamaha YM3812 oder auch OPL2 hat das Steckschwein einen weit komplexeren Chip als den SID, denn OPL2 kennt gleich ganze 9 Stimmen statt drei, und jede ist über eine Unzahl Parameter konfigurierbar.
Wie funktioniert der YM3812? Wie kriegt man also einen Ton aus diesem Monstrum? Die beste Quelle zum Thema OPL2 ist wohl &amp;ldquo;Programming the AdLib/Sound Blaster FM Music Chips&amp;rdquo; von Jeffrey S.</description><content>&lt;p>Das Programmieren von Soundchips ist nicht trivial. Das habe ich damals auf dem C64 schon nicht kapiert. Mit dem Yamaha YM3812 oder auch OPL2 hat das Steckschwein einen weit komplexeren Chip als den SID, denn OPL2 kennt gleich ganze 9 Stimmen statt drei, und jede ist über eine Unzahl Parameter konfigurierbar.&lt;/p>
&lt;h2 id="wie-funktioniert-der-ym3812">Wie funktioniert der YM3812?&lt;/h2>
&lt;p>Wie kriegt man also einen Ton aus diesem Monstrum? Die beste Quelle zum Thema OPL2 ist wohl &amp;ldquo;&lt;a href="http://www.shipbrook.net/jeff/sb.html">Programming the AdLib/Sound Blaster FM Music Chips&lt;/a>&amp;rdquo; von Jeffrey S. Lee. Zumindest wird einem hier schnell klar, was auf einen zukommt, will man auch nur einen einfachen Ton ausgeben. So hat der OPL2-Chip insgesamt 244 Register, die neben den Stimmen auch die integrierten Timer konfigurieren, und belegt 2 Portadressen. Konkret bedeutet das, dass man in Adresse 1 die Nummer des gewünschen Registers schreibt. Nach 3.3µs liegt an Adresse 2 das gewählte Register zum Beschreiben an. Lesen läßt sich nur das Statusregister. Hat man also das gewählte Register beschrieben, ist der Chip dann 23µs nicht ansprechbar.&lt;/p>
&lt;p>Zunächst müssen wir also dafür sorgen, dass der Soundchip seine Daten mit dem richtigen Timing bekommt. Der Einfachheit halber machen wir das nicht über Timer, sondern mit NOPs. Die Länge der Nopslides zu berechnen, überlassen wir dem Assembler. Um Platz zu sparen, nutzen wir eine Nopslide mit zwei Einsprüngen.&lt;/p>
&lt;p>opl2_data_delay_time = 25000
opl2_reg_delay_time = 5000&lt;/p>
&lt;p>opl2_data_delay = ((opl2_data_delay_time - opl2_reg_delay_time) / (1000/clockspeed)) / 2 -12
opl2_reg_delay = (opl2_reg_delay_time / (1000/clockspeed)) / 2 -12&lt;/p>
&lt;p>Und die entsprechenden Subroutinen. Die je 6 Zyklen für JSR und RTS sind ja oben schon abgezogen:&lt;/p>
&lt;p>opl2_delay_data: ; 23000ns / 0
.repeat opl2_data_delay
nop
.endrepeat&lt;/p>
&lt;p>opl2_delay_register: ; 3300 ns
.repeat opl2_reg_delay
nop
.endrepeat
rts&lt;/p>
&lt;p>Das wäre also geklärt.&lt;/p>
&lt;h2 id="futter-für-den-soundchip">Futter für den Soundchip&lt;/h2>
&lt;p>Nachdem also schonmal klar ist, auf welch umständliche Weise der Chip mit Daten betankt werden will, bleibt nur noch die Frage: Betanken womit? FM-Synthese ist ein zu weites Feld, als dass wir dort jetzt tief einsteigen wollen. Viel naheliegender wäre ein Player für eingängige Musikfiles. Erste &lt;a href="http://steckschwein.de/2015/01/04/das-schwein-kann-singen/">Experimente von Marko mit den von DosBox erzeugten DRO Files&lt;/a> waren schon recht vielversprechend. Leider ist es etwas umständlich, mit DosBox neue Musikstücke zu konvertieren, und auch die Trefferquote für lauffähige Stücke ist nicht besonders hoch. Zudem ist der von uns verwendete Player ein ziemlicher Hack mit per NOP grob hingefummelten Timings. Dieser war ursprünglich mal für ein OPL2-Modul für den C64 geschrieben worden. Was es nicht alles gibt. MIDI-Files wollen wir uns auch noch nicht antun, weil wir hier eine Umsetzung der verwendeten MIDI-Instrumente in OPL2-Parameter hätten bauen müssen. Ideal wäre ein Dateiformat, das die OPL2-Registerwerte bereits enthält.&lt;/p>
&lt;p>Zum Glück hat sich damals id-Software zu Zeiten der Commander Keen-Spiele etwas entsprechendes ausgedacht: Das &lt;a href="http://www.shikadi.net/moddingwiki/IMF_Format">IMF-Format&lt;/a>. Dieses Format wurde für eine Reihe früher id-Software-Spiele und deren Ableger verwendet, von Commander Keen 4-6 über Duke Nukem II bis hin zu Wolfenstein 3D. Dementsprechend groß ist die Anzahl der verfügbaren Musikstücke.&lt;/p>
&lt;p>IMF-Dateien sind äußerst simpel aufgebaut, jede Datei ist im Prinzip eine Abfolge von 4byte-Paketen, die Registernummer, Registerwert und die Dauer der Pause bis zum nächsten Wert enthalten:&lt;/p>
&lt;p>Register (8bit) | Wert (8bit) | Pause (16bit)&lt;/p>
&lt;p>Die &amp;ldquo;Pause&amp;rdquo; ist in &amp;ldquo;Ticks&amp;rdquo; angegeben, welche sich auf die Abspielfrequenz des jeweiligen Stückes bezieht. Diese ist meist entweder 560Hz oder 700Hz. Hier kommt dann ein Timer-Interrupt zum Einsatz, der 560 oder 700mal in der Sekunde ausgeführt wird. Hierzu verwenden wir Timer 1 des 6522 VIA. Der OPL2 Chip hat zwar auch Timer, aber diese basieren auf festen Intervallen von 80µs bzw 320µs, was in unserem Fall nicht so richtig aufgeht.&lt;/p>
&lt;p>Der Plan ist folgender: Das IMF-File wird komplett in den Speicher geladen. Dann positionieren wir einen Zeiger auf den Anfang der im Speicher befindlichen Daten.&lt;/p>
&lt;p>In der Zeropage benutzen wir 2 Bytes als unseren Delay-Zähler. Diesen setzen wir inital auf 0. In der Interrupt-Routine prüfen wir als erstes, ob der Delay-Zähler 0 ist. Wenn nicht, dekrementieren wir ihn und verlassen die Routine wieder. Ist der Zähler 0, setzen wir das Datenbyte aus unseren IMF-Daten in das vorgesehene Register. Dann rücken wir den Datenzeiger um 4 Bytes weiter, setzen den Delay-Zähler neu, und verlassen den Interrupt.&lt;/p>
&lt;p>player_isr:
pha
phy&lt;/p>
&lt;p>bit via1ifr ; Interrupt from VIA?
bpl @isr_end&lt;/p>
&lt;p>bit via1t1cl ; Acknowledge timer interrupt by reading channel low&lt;/p>
&lt;p>; delay counter zero?
lda delayh
clc
adc delayl
beq @l1&lt;/p>
&lt;p>; if no, 16bit decrement and exit routine
dec16 delayh&lt;/p>
&lt;p>bra @isr_end
@l1:&lt;/p>
&lt;p>ldy #$00
lda (imf_ptr),y
sta opl_stat&lt;/p>
&lt;p>iny
lda (imf_ptr),y&lt;/p>
&lt;p>jsr opl2_delay_register&lt;/p>
&lt;p>sta opl_data&lt;/p>
&lt;p>iny
lda (imf_ptr),y
sta delayh&lt;/p>
&lt;p>iny
lda (imf_ptr),y
sta delayl&lt;/p>
&lt;p>; song data end reached? then set state to 80 so loop will terminate
lda imf_ptr_h
cmp imf_end+1
bne @l3
lda imf_ptr
cmp imf_end+0
bne @l3&lt;/p>
&lt;p>lda #$80
sta state&lt;/p>
&lt;p>bra @isr_end
@l3:&lt;/p>
&lt;p>;advance pointer by 4 bytes
clc
lda #$04
adc imf_ptr
sta imf_ptr
bcc @isr_end
inc imf_ptr_h
@isr_end:
; jump to kernel isr
ply
pla
jmp (old_isr)&lt;/p>
&lt;p>&lt;a href="https://bitbucket.org/steckschwein/steckschwein-code/src/074d9f378daeedeb45166a346cafd39907be22c9/imfplayer/?at=default">Der vollständige Player&lt;/a> ist in unserem &lt;a href="https://bitbucket.org/steckschwein/steckschwein-code">Bitbucket-Repository&lt;/a> zu finden. Wir gehen jetzt den Wolfenstein 3D-Soundtrack hören.&lt;/p></content></item><item><title>Das Schwein kann singen...</title><link>https://beta.steckschwein.de/post/das-schwein-kann-singen/</link><pubDate>Sun, 04 Jan 2015 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/das-schwein-kann-singen/</guid><description>Das Steckschwein hat nun fast alle notwendigen Komponenten, um mit der Außenwelt zu kommunizieren, aber auch nur fast. Bisher ist es noch stumm, aber das sollte sich heute ändern. Wir haben hier noch ein paar YM3812 Schippse nebst benötigter DAC (YM3014B) rumliegen, also haben wir überlegt dem Schwein einfach das singen beizubringen. Wir wollen Musik und Sounds haben.
Der YM3812 ist ein sehr verbreiteter Chip, der sich auf OPL2 beschränkt, für unsere Zwecke aber völlig ausreichend ist.</description><content>&lt;p>Das Steckschwein hat nun fast alle notwendigen Komponenten, um mit der Außenwelt zu kommunizieren, aber auch nur fast. Bisher ist es noch stumm, aber das sollte sich heute ändern. Wir haben hier noch ein paar YM3812 Schippse nebst benötigter DAC (YM3014B) rumliegen, also haben wir überlegt dem Schwein einfach das singen beizubringen. Wir wollen Musik und Sounds haben.&lt;/p>
&lt;p>Der &lt;a href="http://de.wikipedia.org/wiki/Yamaha_YM3812">YM3812&lt;/a> ist ein sehr verbreiteter Chip, der sich auf OPL2 beschränkt, für unsere Zwecke aber völlig ausreichend ist. Nur wie stellt man das wieder an? Das &lt;a href="http://www.vgmpf.com/Docs/YM3812%20-%20Manual.pdf">Datenblatt&lt;/a> ist ziemlich dünn, reicht aber aus um klar zu machen was wir alles brauchen.&lt;/p>
&lt;ul>
&lt;li>Decoder&lt;/li>
&lt;li>dedizierter Takt, optimalerweise 3,58 Mhz (beknackt)&lt;/li>
&lt;li>DAC (YM3014) der die 16Bit Floating Point des YM3812 in eine Spannung wandelt&lt;/li>
&lt;li>Opamps&lt;/li>
&lt;/ul>
&lt;h4 id="decoder">Decoder&lt;/h4>
&lt;p>Das Design des Steckschwein ist ja mittlerweile sehr vereinfacht, und wir können den YM3812 ziemlich einfach mit einem entsprechenden 7400 an den Bus hängen. Wie beim VDP ist auch beim YM3812 ein dedizierter Read- und Write-Pin vorgesehen und zusätzlich - warum auch immer - noch ein dediziertes CS (chip select). Das CS wird über den GAL erzeugt und wird direkt an Pin 7 des YM3812 geführt. Für unseren ersten Test nehmen wir den Adressbereich $0230-$023f. Wir brauchen laut Datenblatt 2 Adressen, einmal Register-Select und einmal Register-Write. Wir wählen $0230 für den Register-Select und $0231 für den Register-Write, A0 (Adressleitung) wird direkt an Pin 4 des YM3812 gegeben. /WR, /RD erzeugen wir über einen 7400 ohne PHI2.&lt;/p>
&lt;h4 id="dedizierter-takt">Dedizierter Takt&lt;/h4>
&lt;p>Das ist schon ehern spannend, zumal ich hier gerade keinen 3.58Mhz Quartz rumliegen habe. Naja, ich hab noch die 10,738Mhz Quartze für den VDP, aber ne Teilerschaltung - Div by 3 - basteln möchte ich jetzt auch nicht. Man könnte für nen Test noch den GAL dafür verwenden. Ich beschließe aber, dass auch dass noch zu aufwändig ist für nen ersten Test und nehme einfach einen 12Mhz Oszillator und den bewährten LS393. Ich teile die 12Mhz durch 4 und führe die gewonnenen 3Mhz an den YM3812. Muss dem reichen&amp;hellip;.&lt;/p>
&lt;h4 id="dac-und-opamp">DAC und Opamp&lt;/h4>
&lt;p>Der DAC und der Opamp wird wie im Datenblatt erst einmal mit dem ganz minimalistischem Aufbau ohne RC-Filter usw. an den YM3812 angeschlossen. Noch nen Kabel dran und in den Audio-Eingang des 1084S Monitor gesteckt. Fertig, fehlt nur noch die Software.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/cA7oGLFuxXQ" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>to be continued&amp;hellip;&lt;/p></content></item></channel></rss>