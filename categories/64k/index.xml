<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>64k on Steckschwein</title><link>https://www.steckschwein.de/categories/64k/</link><description>Recent content in 64k on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 22 Oct 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://www.steckschwein.de/categories/64k/index.xml" rel="self" type="application/rss+xml"/><item><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface</title><link>https://www.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</link><pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</guid><description>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</description><content>&lt;p>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.&lt;/p>
&lt;p>as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings&lt;/p>
&lt;ol>
&lt;li>the first 2 bytes send to vdp during a write are always register writes which require a short delay of at least 2µs in between each byte&lt;/li>
&lt;li>the write of the 3rd byte (after the 2nd) requires a delay of 8µs. any further &amp;ldquo;single byte transfer&amp;rdquo; - during a vram write - also requires the 8µs delay. the same is true if we want to initiate a register write direclty after a vram write.&lt;/li>
&lt;li>the 3rd and n-th byte write to port #3 (index register port) during a bulk register write requires only the 2µs between each byte&lt;/li>
&lt;/ol>
&lt;p>With this in mind, we can optimize our library a little bit by using different &amp;ldquo;nop slides&amp;rdquo; for address setup and vram writes.&lt;/p>
&lt;p>We enhance our vdp.inc and built two macros which provide the different delay we need.&lt;/p>
&lt;p>.macro vdp_wait_s
jsr vdp_nopslide_2m ; 2m for 2µs wait
&amp;hellip;&lt;/p>
&lt;p>.macro vdp_wait_l
jsr vdp_nopslide_8m ; 8m for 8µs wait
&amp;hellip;&lt;/p>
&lt;p>steckSchwein is running at 8Mhz, so we also defined some equations and used ca65 macros to build our nop slides.&lt;/p>
&lt;p>.define CLOCK_SPEED_MHZ 8&lt;/p>
&lt;p>; long delay with 6µ+2µs (below)
MAX_NOPS_8M = (6 * 1000 / (1000 / CLOCK_SPEED_MHZ)) / 2
; 8Mhz, 125ns per cycle, wait 6µs = 6000ns
; = 6000ns / 125ns = 48cl / 2 =&amp;gt; 24 NOP&lt;/p>
&lt;p>; short delay with 2µs wait
MAX_NOPS_2M = (2 * 1000 / (1000 / CLOCK_SPEED_MHZ) -12) / 2
; -12 =&amp;gt; jsr/rts = 2 * 6cl = 12cl must be subtract&lt;/p>
&lt;p>.macro m_vdp_nopslide
vdp_nopslide_8m:
; long delay with 6+2 2µs wait
.repeat MAX_NOPS_8M
nop
.endrepeat
vdp_nopslide_2m:
.repeat MAX_NOPS_2M
nop
.endrepeat
rts
.endmacro&lt;/p>
&lt;p>Another interesting thing would be, &amp;ldquo;how does the /WAIT&amp;rdquo; behave in this situation? the assumption here is, that the /WAIT will behave in the way as specified. so /WAIT will be go low at least after 130ns from CSW. so to handover the /RDY handling to the vdp via the /WAIT pin, we have to apply only 1 wait state from our WS-Gen. after one wait state, we can release the /RDY low from our WS so that the vdp /WAIT can drive /RDY as needed.&lt;/p>
&lt;p>Back home, Thomas did the test and changed the waitstate generator firmware for the GAL16V8.&lt;/p>
&lt;p>The equation was&lt;/p>
&lt;p>W2 = ROM * UART * SND * /VDP
W1 = W2
+ /ROM * UART * VDP&lt;/p>
&lt;p>and was changed to&lt;/p>
&lt;p>W2 = /SND
W1 = W2
+ /ROM ; /ROM wait state if ROM is cs
+ /VDP ; /VDP wait state if VDP is cs&lt;/p>
&lt;p>So finally, we only need one wait state from the waitstate generator to access the VDP. If the VDP requires more time - surely - during a video memory access it will drive /WAIT to low as long as needed. So after the explcit 1WS from our wait state generator we now hand over the /RDY control to the VDP. How our /RDY and /WAIT really work together is subject to one of our next sessions where we&amp;rsquo;re going to measure the things with a logic analyzer and oscilloscope. Nevertheless, it works in this way and it works exaclty as specified within the datasheet.&lt;/p></content></item><item><title>Das Design wird erweitert</title><link>https://www.steckschwein.de/post/das-design-wird-erweitert/</link><pubDate>Sun, 16 Mar 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/das-design-wird-erweitert/</guid><description>Sinn der Sache ist ja nicht, etwas 1:1 nachzubauen, sondern ein möglichst eigenes Design. Nachdem wir mit Chris&amp;rsquo; Design - bzw. dessen, was wir davon übernommen haben (Adressdekodierung, ACIA, VIA) - genug herumgespielt hatten, galt es, &amp;ldquo;unser&amp;rdquo; Ding draus zu machen. Der erste Schritt war ein Sprung ins kalte Wasser in die uns bislang noch unbekannte Welt der Programmierbaren Logik. Dazu haben wir zunächst die Adressdekodierung bestehend aus 74ls138/74ls154 sowie etwas glue Logic in VHDL implementiert und auf ein GAL22V10D gebrannt.</description><content>&lt;p>Sinn der Sache ist ja nicht, etwas 1:1 nachzubauen, sondern ein möglichst eigenes Design. Nachdem wir mit Chris&amp;rsquo; Design - bzw. dessen, was wir davon übernommen haben (Adressdekodierung, ACIA, VIA) - genug herumgespielt hatten, galt es, &amp;ldquo;unser&amp;rdquo; Ding draus zu machen. Der erste Schritt war ein Sprung ins kalte Wasser in die uns bislang noch unbekannte Welt der Programmierbaren Logik. Dazu haben wir zunächst die Adressdekodierung bestehend aus 74ls138/74ls154 sowie etwas glue Logic in VHDL implementiert und auf ein GAL22V10D gebrannt. Somit haben wir 3 TTL-ICs durch einen GAL ersetzt und wieder Platz auf dem Steckbrett geschaffen. Und das Beste: Änderungen an der Dekodierungslogik laufen ab sofort minimalinvasiv.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Die erste Erweiterung ist ein /CS-Signal für den 2. 62256-Chip, der sich seinen Adressbereich mit 4k IO-Bereich und 8K ROM teilen darf und uns immerhin noch 20k nutzbares RAM beschert. Anfängliche Pläne, das unter dem ROM und IO liegende RAM nach Vorbild des C64 nutzbar zu machen stellen wir erstmal zurück. Zu viel Aufwand für lumpige 12k.&lt;/p>
&lt;p>Inzwischen gibt es auch eine rs232-Schnittstelle auf Basis einer 65x51 ACIA. Der vorliegende Chip kann mit max. 2MHz getaktet werden, daher ist der diskret aufgebaute 3MHz-Oszillator wieder arbeitslos. An seiner Stelle betaktet ein 2MHz-TTL-Oszillator unseren Rechner.&lt;/p>
&lt;p>Diese Begrenzung auf 2MHz gefällt uns nicht, eigentlich wollten wir den Rechner später so hoch wie möglich takten, auf jeden Fall mit 4MHz. Modernere CPUs sowie VIAs von WDC, die bis zu 14MHz Taktfrequenz vertragen, sind so gut wie geordert. Einzig die ACIA soll komplett durch einen moderneren Chip ersetzt werden, da sie uns nicht nur auf 2MHz, sondern auch auf 19200 baud begrenzt. Ein bisschen zu vintage, darum soll als nächtes die ACIA einem zeitgemäßeren Chip weichen.&lt;/p></content></item></channel></rss>