<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bios on Steckschwein</title><link>https://www.steckschwein.de/categories/bios/</link><description>Recent content in bios on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 13 Jun 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://www.steckschwein.de/categories/bios/index.xml" rel="self" type="application/rss+xml"/><item><title>NVRAM improvements</title><link>https://www.steckschwein.de/post/nvram-improvements/</link><pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/nvram-improvements/</guid><description>As real computer is not a real computer without a real time clock, the Steckschwein is no exception here. As we know, we use the Maxim DS1306 RTC, which is a very common RTC which comes as DIP IC and has an SPI interface. And of course it supports battery backup in various configurations. And this is where things get interesting.
Apart from timekeeping, the DS1306 also has 96 bytes of battery buffered RAM.</description><content>&lt;p>As real computer is not a real computer without a real time clock, the Steckschwein is no exception here. As &lt;a href="http://steckschwein.de/hardware/via-65c22-as-spi-master/spi-devices/">we know&lt;/a>, we use the Maxim DS1306 RTC, which is a very common RTC which comes as DIP IC and has an SPI interface. And of course it supports battery backup in various configurations. And this is where things get interesting.&lt;/p>
&lt;p>Apart from timekeeping, the DS1306 also has 96 bytes of battery buffered RAM. The ideal place to store system configuration parameters. As of now, the RTC NVRAM contains the name of the file to be read from sdcard at startup, the line parameters for the serial interface (baud rate, data bits, parity, stopbits), and also a version number and a crc7 checksum:&lt;/p>
&lt;p>.struct nvram
version .byte
filename .byte 11
uart_baudrate .byte
uart_lsr .byte
crc7 .byte
.endstruct&lt;/p>
&lt;p>version - The version byte will help tracking changes to the NVRAM data structure so we can maintain backwards compatibility. But for now, it&amp;rsquo;s always $00. filename - The name of the file that will be read from sdcard at system bootup. uart_baudrate - lower byte of the 16 bit divisor of the 16550&amp;rsquo;s baud rate generator. The high byte will always be set to 0, since we do not need baud rates &amp;lt; 600 baud. uart_lsr - contents of the 16550&amp;rsquo;s Line Status Register, to setup the number of data bits, parity, and stop bits. crc7 - crc7 checksum of all the bytes except this last one. If at system startup the crc is not correct, an error message is displayed and fallback defaults are used.&lt;/p>
&lt;p>To manipulate the contents of the NVRAM in a user friendly way, steckOS provides a tool written in C.&lt;/p>
&lt;p>&lt;img src="images/nvram-1.jpg" alt=""> nvram tool&lt;/p>
&lt;p> &lt;/p>
&lt;p>As of now, we only use 15 bytes out of 96, so there are still 81 bytes left for whatever we might come up. Default text mode (40cols/80cols) comes to mind, also text/background colors&amp;hellip;&lt;/p></content></item><item><title>Mehr Karten (UPDATE)</title><link>https://www.steckschwein.de/post/mehr-karten-update/</link><pubDate>Fri, 24 Jul 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/mehr-karten-update/</guid><description>Unser &amp;ldquo;Standard&amp;rdquo;-Massenspeicher SD-Karte funktioniert zwar an und für sehr gut, Sorgenkind war aber immer die Initialisierungs-Routine. Bisher ließen sich damit nur günstige Class4-Karten initialisieren, bei &amp;ldquo;höherwertigen&amp;rdquo; Karten schlug die Initialisierung immer fehl, sodass nur etwa 3 von 5 Karten nutzbar waren.
Das hat uns schon etwas gewurmt, denn irgendwie hatte dieser Stand ein Geschmäckle von &amp;ldquo;Funktioniert aus Versehen&amp;rdquo;. Also mussten wir da nochmal ran. Der Initialisierungs-Flow entspricht im Wesentlichen dem, was auf der bekannten Seite http://elm-chan.</description><content>&lt;p>Unser &amp;ldquo;Standard&amp;rdquo;-Massenspeicher SD-Karte funktioniert zwar an und für sehr gut, Sorgenkind war aber immer die Initialisierungs-Routine. Bisher ließen sich damit nur günstige Class4-Karten initialisieren, bei &amp;ldquo;höherwertigen&amp;rdquo; Karten schlug die Initialisierung immer fehl, sodass nur etwa 3 von 5 Karten nutzbar waren.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Das hat uns schon etwas gewurmt, denn irgendwie hatte dieser Stand ein Geschmäckle von &amp;ldquo;Funktioniert aus Versehen&amp;rdquo;. Also mussten wir da nochmal ran. Der Initialisierungs-Flow entspricht im Wesentlichen dem, was auf der bekannten Seite &lt;a href="http://elm-chan.org/docs/mmc/mmc_e.html">http://elm-chan.org/docs/mmc/mmc_e.html&lt;/a> dokumentiert ist. In den letzten Tagen haben wir diesen unter die Lupe genommen, und tatsächlich ist etwas aufgefallen. Vor dem Senden eines Kommandos muss sichergestellt werden, dass die Karte bereit ist. Hierzu sendet man solange $ff an die Karte, bis diese auch $ff zurücksendet. Dann ist die Karte bereit, ein Kommando zu empfangen. In unserer Initialisierungsroutine wurde dies zwischen CMD55 und ACMD41 (näheres bitte dem Link entnehmen) schlichtweg nicht gemacht. Plötzlich lassen sich fast alle vorhandenen Karten initialisieren. Dass dies mit den Class4-Karten trotzdem funktionierte, war also gewissermaßen tatsächlich aus Versehen.&lt;/p>
&lt;p>Das nächste Problem war dann, dass von den jetzt nutzbaren Karten über die Shell zwar im Filesystem navigiert und Verzeichnisse aufgelistet werden konnten, das eigentliche Laden von Dateien bzw. Starten von Programmen funktionierte nicht. Die Blockleseroutinen liefen korrekt durch, die geladenen Daten jedoch waren fehlerhaft. Dass die Dateisystemoperationen funktioniert haben, und nur das Einlesen von Dateien Probleme machte, war verdächtig. &lt;a href="http://wordpress.steckschwein.de/wordpress/index.php/2015/05/20/filesystem-und-shell/">Noch im Mai verkündeten wir&lt;/a> u.a. stolz, dass wir zum Dateien lesen schnelle SD-Multiblock-Transfers verwenden. Diese haben den Vorteil, dass man der Karte nur die Adresse des ersten zu lesenden Blocks übermittelt, und dann einfach liest bis der Arzt kommt oder man der Karte sagt, dass man fertig ist. Vorteil ist, dass man die Blockadresse des nächsten Blocks nicht immer selber ausrechnen muss (immerhin eine 32bit-Addition) und auch nicht immer wieder an die Karte schicken muss.&lt;/p>
&lt;p>Gut, also die fat_read-Routine zurückgebaut, und schon ist das Steckschwein mit so ziemlich jeder handelsüblichen SD-Karte kompatibel.&lt;/p>
&lt;p>&lt;strong>[UPDATE:]&lt;/strong> Mittlerweile funktionieren auch wieder Multiblock-Transfers. Der Trick war, beim Lesen von der Karte die MOSI-Leitung nicht auf L, sondern auf H zu setzen, also nicht mehr $00 zu senden, sondern $ff. Die Idee kam, nachdem sämtliche Beispiele, die sich im Web finden lassen, $ff senden. Die Stelle in der SD-Karten-Spezifikation, in der das so spezifiziert ist, ist bis dato nicht gefunden worden.&lt;/p></content></item><item><title>Bootschwein</title><link>https://www.steckschwein.de/post/bootschwein/</link><pubDate>Mon, 05 Jan 2015 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/bootschwein/</guid><description>Die Aufgabe, die wir dem (Steck)BIOS zugedacht haben, beschränkt sich darauf, die vorhandene Hardware zu initialisieren, auf eine eingelegte SD-Karte zu prüfen, und dann von dort das eigentliche &amp;ldquo;Betriebssystem&amp;rdquo; zu laden. Fast ein bisschen PC-like.
Hier ist die Überlegung, im Stammverzeichnis eine bestimmte Datei zu finden und an eine bestimmte Adresse in den Speicher zu laden.
Sollte dies fehlschlagen, kann man immer noch in einen Monitor oder unsere bekannte rs232-Uploadroutine springen.</description><content>&lt;p>Die Aufgabe, die wir dem (Steck)BIOS zugedacht haben, beschränkt sich darauf, die vorhandene Hardware zu initialisieren, auf eine eingelegte SD-Karte zu prüfen, und dann von dort das eigentliche &amp;ldquo;Betriebssystem&amp;rdquo; zu laden. Fast ein bisschen PC-like.&lt;/p>
&lt;p>Hier ist die Überlegung, im Stammverzeichnis eine bestimmte Datei zu finden und an eine bestimmte Adresse in den Speicher zu laden.&lt;/p>
&lt;p>Sollte dies fehlschlagen, kann man immer noch in einen Monitor oder unsere bekannte rs232-Uploadroutine springen.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Um nun also eine Datei auf der SD-Karte zu finden, müssen wir erstmal rudimentäre Unterstützung für das FAT-Dateisystem bauen. FAT stammt aus den 70er Jahren und hat als Dateisystem für MS-DOS-basierte Betriebssysteme Verbreitung gefunden. Ursprünglich war es für Disketten gedacht (FAT12), und wurde immer wieder erweitert, um auch wesentlich größere Datenträgerkapazitäten wie z.B. von Festplatten zunächst bis 2GB (FAT16), dann aber auch über diese Begrenzung heraus (FAT32) zu unterstützen.&lt;/p>
&lt;p>Da so ziemlich jede SD-Karte, die man heute kaufen kann, mindestens 2GB Kapazität hat, lassen wir FAT12 und FAT16 außen vor, und konzentrieren uns nur auf FAT32. Hierzu ist sicherlich die &lt;a href="http://msdn.microsoft.com/en-us/windows/hardware/gg463080.aspx">offizielle Dokumentation von Microsoft&lt;/a> eine sinnvolle Lektüre, als wesentlich hilfreicher hat sich aber das auf FAT32 konzentrierte &lt;a href="https://www.pjrc.com/tech/8051/ide/fat32.html">Understanding FAT32 Filesystems von Paul Stoffregen&lt;/a> erwiesen, indem es einen gezielt durch die Strukturen führt, die man für FAT32 tatsächlich braucht.&lt;/p>
&lt;p>Unsere Implementation beschränkt sich darauf, das Stammverzeichnis der ersten Partition zu lesen, bis eine Datei gefunden wird, die das &amp;ldquo;System&amp;rdquo;-Attribut hat. Diese wird eingelesen.&lt;/p>
&lt;p>Hierbei ist das Verfolgen der Clusterketten, also das eigentliche Auswerten der FAT, nicht implementiert, sodass die max. Dateigröße der Größe eines Clusters entspricht. Zum finden und laden dessen, was später mal unser &amp;ldquo;Betriebsystem&amp;rdquo; werden soll, reicht es aber.&lt;/p>
&lt;p>Der rudimentäre Code findet sich in unserem &lt;a href="https://sourceforge.net/p/steckschwein/code/ci/default/tree/fat/">Repository auf Sourceforge&lt;/a>.&lt;/p></content></item><item><title>Noch schlauerer Decoder</title><link>https://www.steckschwein.de/post/noch-schlauerer-decoder/</link><pubDate>Tue, 01 Jul 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/noch-schlauerer-decoder/</guid><description>Wir sind jetzt also fast in der Lage, das RAM unter dem ROM zu nutzen. Hineinschreiben geht, lesen noch nicht. Da ist das ROM noch im Weg. Wir müssen also einen Weg finden, die GAL-Logik von außen zu beeinflussen. Unser GAL hat noch genügend Eingänge, sodass wir einen Pin zum ROM-Ein-/Ausschalter machen wollen. Lesezugriffe nach $e000-$ffff sollen also nur noch dann im ROM landen, wenn es &amp;ldquo;eingeschaltet&amp;rdquo; ist. Sonst wollen wir ins RAM.</description><content>&lt;p>Wir sind jetzt also fast in der Lage, das RAM unter dem ROM zu nutzen. Hineinschreiben geht, lesen noch nicht. Da ist das ROM noch im Weg. Wir müssen also einen Weg finden, die GAL-Logik von außen zu beeinflussen. Unser GAL hat noch genügend Eingänge, sodass wir einen Pin zum ROM-Ein-/Ausschalter machen wollen. Lesezugriffe nach $e000-$ffff sollen also nur noch dann im ROM landen, wenn es &amp;ldquo;eingeschaltet&amp;rdquo; ist. Sonst wollen wir ins RAM. Die wiederum erweiterte Logik im GAL sieht jetzt so aus:&lt;/p>
&lt;p>/CSHIRAM = G1*/A2                                 + G1*/A1*/A0          + /RW*G1*A2*A1 ; Writes to $e000-$ffff go to the RAM          + /ROMOFF*RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the RAM, IF ROMOFF is Low /CSROM   = ROMOFF*RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the ROM, IF ROMOFF is High ROMOFF haben wir Pin 13 des GAL zugeordnet. Und tatsächlich startet unser Steckschwein nur noch, wenn dieser PIN mittels eines PullUp-Widerstands nach High gezogen wird.  Lassen wir unser Testprogramm aus dem letzten Post nochmal laufen:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Das gewohnte Bild, Lesezugriff geht ins ROM, Schreibzugriff ins RAM. Jetzt ziehen wir ROMOFF auf Masse und schalten damit das ROM aus:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Volltreffer, das ROM wird nicht mehr selektiert, wir landen immer im RAM. ROMOFF müssen wir jetzt nur noch per Software steuerbar machen, und unser nutzbares RAM hat sich um 8k erweitert, sofern wir in Kauf nehmen, dass wir keine ROM-Routinen verwenden können, solange wir dort lesen. Aber das ist beim C64 ja auch nicht anders. Ein konkreter Verwendungszweck der neuen Dekoderlogik drängt sich bereits auch ohne Softwaresteuerung der ROMOFF-Leitung auf: Das Testen neuer Versionen des ROM-Code(BIOS) ohne jedesmal das EEPROM brennen zu müssen. Schon richtig modern. Als abschließendes Experiment verbinden wir ROMOFF mit dem Bit0 von Port A der VIA. Die VIA hat die angenehme Eigenschaft, dass ihre Ports im Urzustand immer als Eingänge geschaltet sind und die Pins durch interne Pullups auf H gezogen werden. Um jetzt aus dem RAM ab $e000 zu lesen, brauchen wir nur Bit 0 von Port A der VIA zu löschen. Folgendes Programm testet, ob das auch so klappt: lda #000001         sta via1porta ; Pin 0 von Port A auf 1 setzen -&amp;gt; ROM ein         sta via1ddra  ; Pin 0 von Port A als Ausgang setzen lda #$00         ldx #$42         stx $e000     ; $42 landet im RAM dec via1porta ; Pin 0 von Port A ist jetzt 0 -&amp;gt; ROM  aus         lda $e000     ; $42 aus dem RAM lesen         inc via1porta ; -&amp;gt; ROM ein jsr lcdhex&lt;/p>
&lt;p>&amp;hellip; und auf dem LCD erscheint die $42. Freude.&lt;/p></content></item></channel></rss>