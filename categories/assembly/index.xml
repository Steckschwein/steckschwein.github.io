<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>assembly on Steckschwein</title><link>https://www.steckschwein.de/categories/assembly/</link><description>Recent content in assembly on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 21 Dec 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://www.steckschwein.de/categories/assembly/index.xml" rel="self" type="application/rss+xml"/><item><title>Chuck Peddle, 1937 - 2019</title><link>https://www.steckschwein.de/post/chuck-peddle-1937-2019/</link><pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/chuck-peddle-1937-2019/</guid><description>Chuck Peddle, the main designer of the 6502, has passed away on Dec. 15th, 2019.
Peddle was one of the engineers that developed the 6800 at Motorola. He later went to MOS in order to implement his vision of an 8bit CPU for way less than $300, which was Motorola&amp;rsquo;s price for the 6800.
This idea of a cheap but powerful CPU materialized as the 6501, and finally the 6502. That very chip, which started the microcomputer revolution, and on which both Marko and myself began to write our first code ever at an early age.</description><content>&lt;p>Chuck Peddle, the main designer of the 6502, has passed away on Dec. 15th, 2019.&lt;/p>
&lt;p>Peddle was one of the engineers that developed the 6800 at Motorola. He later went to MOS in order to implement his vision of an 8bit CPU for way less than $300, which was Motorola&amp;rsquo;s price for the 6800.&lt;/p>
&lt;p>This idea of a cheap but powerful CPU materialized as the 6501, and finally the 6502. That very chip, which started the microcomputer revolution, and on which both Marko and myself began to write our first code ever at an early age. BASIC at first, followed by assembly language later.&lt;/p>
&lt;p>Learning to code assembly on this small and elegant CPU provided the both of us with profound knowledge and experience about the inner workings of a computer. Knowledge which is still valuable in our respective careers in IT, and also of course when working on our pet project, the Steckschwein. Things would have gone quite different without Chuck Peddle&amp;rsquo;s elegant little CPU.&lt;/p>
&lt;p>Thanks, Chuck!&lt;/p></content></item><item><title>Weird bug in SD card code</title><link>https://www.steckschwein.de/post/weird-bug-in-sd-card-code/</link><pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/weird-bug-in-sd-card-code/</guid><description>Frank van den Hoef, who is adapting the Steckschwein SPI &amp;amp; FAT32 code for his tiny65 machine made me aware of a classic mistake for a 6502 assembly coder to make. Namely in our sdcard driver, when waiting for the &amp;ldquo;proper&amp;rdquo; response from the card (which should have bit 7 cleared). The routine handling this looked like this:
1 sd_cmd_response_wait: 2 ldy #sd_cmd_response_retries 3 @l: dey 4 beq sd_block_cmd_timeout ; y already 0?</description><content>&lt;p>Frank van den Hoef, who is adapting the Steckschwein SPI &amp;amp; FAT32 code for his tiny65 machine made me aware of a classic mistake for a 6502 assembly coder to make. Namely in our sdcard driver, when waiting for the &amp;ldquo;proper&amp;rdquo; response from the card (which should have bit 7 cleared). The routine handling this looked like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>1 sd_cmd_response_wait:
2 ldy #sd_cmd_response_retries
3 @l: dey
4 beq sd_block_cmd_timeout ; y already 0? then invalid response or timeout
5 jsr spi_r_byte
6 bit #80 ; bit 7 clear
7 bne @l ; no, next byte
8 cmp #$00 ; got cmd response, check if $00 to set z flag accordingly
9 rts
10 sd_block_cmd_timeout:
11 debug &amp;#34;sd_block_cmd_timeout&amp;#34;
12 lda #$1f ; make up error code distinct from possible sd card responses to mark timeout
13 rts
&lt;/code>&lt;/pre>&lt;p>Classic. Obviously, line 6 should read:&lt;/p>
&lt;pre tabindex="0">&lt;code> bit #$80 ; bit 7 clear
&lt;/code>&lt;/pre>&lt;p>With that fixed, the sd card init routine now fails, which is odd since we fixed something that was obviously broken.&lt;/p>
&lt;p>&lt;img src="images/sd_fail-e1571229478149.jpg" alt="sd_fail.jpg">&lt;/p>
&lt;p>Ok, now what? Enabling Marko&amp;rsquo;s mighty debugging macros, it becomes apparent that the sd card init fails right after sending CMD0 to the card. This command is the first command of the init sequence and is supposed to put the card into &amp;ldquo;idle mode&amp;rdquo;. Which the card confirms with an answer of $01. Which is what the init code is expecting, and not getting. Instead, we get $3F, which does not make a lot of sense.&lt;/p>
&lt;p>But why did it work before the fix? Assuming that the card did not change it&amp;rsquo;s behaviour at the same time I fixed the code, let&amp;rsquo;s check what actually happened. Before the fix, we were ANDing $3F with 80:&lt;/p>
&lt;p>&lt;code> 00111111 $3f&lt;/code>&lt;br>
&lt;code>01010000 80 (no $, decimal)&lt;/code>&lt;/p>
&lt;p>In this case, the BNE after the BIT #80 would take the branch to @l, causing the next byte being read, until finally the card responds with $01:&lt;/p>
&lt;p>&lt;code> 00000001 $01&lt;/code>&lt;br>
&lt;code>01010000 80 (no $, decimal)&lt;/code>&lt;/p>
&lt;p>Now the BNE does not take the branch, and the routine exits.&lt;/p>
&lt;p>Now, with the fixed code,  ANDing $3F with **$**80, to check if bit 7 is clear, which it is:&lt;/p>
&lt;p>&lt;code> 00111111 $3F&lt;/code>&lt;br>
&lt;code>10000000 $80&lt;/code>&lt;/p>
&lt;p>Alright, exit the loop and return $3f as response of the card. Which isn&amp;rsquo;t $01, so init failed.&lt;/p>
&lt;p>At this point, I have no explanation for the card responding $3F. I assume that the card might be not ready to process commands at this point, so I added code to repeat sending CMD0 until we get $01 or we run out of retries.&lt;/p></content></item><item><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface</title><link>https://www.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</link><pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</guid><description>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</description><content>&lt;p>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.&lt;/p>
&lt;p>as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings&lt;/p>
&lt;ol>
&lt;li>the first 2 bytes send to vdp during a write are always register writes which require a short delay of at least 2µs in between each byte&lt;/li>
&lt;li>the write of the 3rd byte (after the 2nd) requires a delay of 8µs. any further &amp;ldquo;single byte transfer&amp;rdquo; - during a vram write - also requires the 8µs delay. the same is true if we want to initiate a register write direclty after a vram write.&lt;/li>
&lt;li>the 3rd and n-th byte write to port #3 (index register port) during a bulk register write requires only the 2µs between each byte&lt;/li>
&lt;/ol>
&lt;p>With this in mind, we can optimize our library a little bit by using different &amp;ldquo;nop slides&amp;rdquo; for address setup and vram writes.&lt;/p>
&lt;p>We enhance our vdp.inc and built two macros which provide the different delay we need.&lt;/p>
&lt;pre tabindex="0">&lt;code>.macro vdp_wait_s
jsr vdp_nopslide_2m ; 2m for 2µs wait
...
.macro vdp_wait_l
jsr vdp_nopslide_8m ; 8m for 8µs wait
...
&lt;/code>&lt;/pre>&lt;p>steckSchwein is running at 8Mhz, so we also defined some equations and used ca65 macros to build our nop slides.&lt;/p>
&lt;pre tabindex="0">&lt;code>.define CLOCK_SPEED_MHZ 8
; long delay with 6µ+2µs (below)
MAX_NOPS_8M = (6 * 1000 / (1000 / CLOCK_SPEED_MHZ)) / 2
; 8Mhz, 125ns per cycle, wait 6µs = 6000ns
; = 6000ns / 125ns = 48cl / 2 =&amp;gt; 24 NOP
; short delay with 2µs wait
MAX_NOPS_2M = (2 * 1000 / (1000 / CLOCK_SPEED_MHZ) -12) / 2
; -12 =&amp;gt; jsr/rts = 2 * 6cl = 12cl must be subtract
.macro m_vdp_nopslide
vdp_nopslide_8m:
; long delay with 6+2 2µs wait
.repeat MAX_NOPS_8M
nop
.endrepeat
vdp_nopslide_2m:
.repeat MAX_NOPS_2M
nop
.endrepeat
rts
.endmacro
&lt;/code>&lt;/pre>&lt;p>Another interesting thing would be, &amp;ldquo;how does the /WAIT&amp;rdquo; behave in this situation? the assumption here is, that the /WAIT will behave in the way as specified. so /WAIT will be go low at least after 130ns from CSW. so to handover the /RDY handling to the vdp via the /WAIT pin, we have to apply only 1 wait state from our WS-Gen. after one wait state, we can release the /RDY low from our WS so that the vdp /WAIT can drive /RDY as needed.&lt;/p>
&lt;p>Back home, Thomas did the test and changed the waitstate generator firmware for the GAL16V8.&lt;/p>
&lt;p>The equation was&lt;/p>
&lt;pre tabindex="0">&lt;code>W2 = ROM \* UART \* SND \* /VDP
W1 = W2
+ /ROM \* UART \* VDP
&lt;/code>&lt;/pre>&lt;p>and was changed to&lt;/p>
&lt;pre tabindex="0">&lt;code>W2 = /SND
W1 = W2
+ /ROM ; /ROM wait state if ROM is cs
+ /VDP ; /VDP wait state if VDP is cs
&lt;/code>&lt;/pre>&lt;p>So finally, we only need one wait state from the waitstate generator to access the VDP. If the VDP requires more time - surely - during a video memory access it will drive /WAIT to low as long as needed. So after the explcit 1WS from our wait state generator we now hand over the /RDY control to the VDP. How our /RDY and /WAIT really work together is subject to one of our next sessions where we&amp;rsquo;re going to measure the things with a logic analyzer and oscilloscope. Nevertheless, it works in this way and it works exaclty as specified within the datasheet.&lt;/p></content></item><item><title>VCFB 2018 It was great...</title><link>https://www.steckschwein.de/post/vcfb-2018-its-great/</link><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/vcfb-2018-its-great/</guid><description>VCF 2018 in Berlin was great! We&amp;rsquo;ve met interesting people there. Got a handshake with Scot W. Stevenson who for(th)ced us to use his TaliForth2 ;)
Later on Saturday Daniel Illgen - maintainer of the Adlib Tracker II for Linux - had decided to honor us with his OPL2 knowledge while on the way out. He advised us to keep the OPL2 sound chip on the Steckschwein, because the OPL2 chip is still not outbid.</description><content>&lt;p>VCF 2018 in Berlin was great! We&amp;rsquo;ve met interesting people there. Got a handshake with Scot W. Stevenson who for(th)ced us to use his &lt;a href="https://github.com/scotws/TaliForth2">TaliForth2&lt;/a> ;)&lt;/p>
&lt;p>Later on Saturday &lt;a href="http://www.adlibtracker.net/downloads.php">Daniel Illgen&lt;/a> - maintainer of the Adlib Tracker II for Linux - had decided to honor us with his OPL2 knowledge while on the way out. He advised us to keep the OPL2 sound chip on the Steckschwein, because the OPL2 chip is still not outbid. We hat doubts at first, but then we could listen to OPL2 with so called &amp;ldquo;software low frequency oscillation&amp;rdquo; (soft lfo) and the drums and bass sounds great!&lt;/p>
&lt;p>Beside the VCF there where talks about demos and the history of the demoscene then and now. There where two interesting and awesome talks given by &amp;ldquo;&lt;a href="http://svolli.de/">SvOlli&lt;/a>&amp;rdquo; about the demoscene and demo coding on the Atari VCS (Stella).&lt;/p>
&lt;p>Here are the slides of out talks and Links to the livestream from Saturday 13.10.2018.&lt;/p>
&lt;ul>
&lt;li>Steckschwein - &lt;a href="https://steckschwein.files.wordpress.com/2018/10/the-history.pdf">The history and why it&amp;rsquo;s called &amp;ldquo;Steckschwin&amp;rdquo;&lt;/a>&lt;/li>
&lt;li>Steckschwein - &lt;a href="https://steckschwein.files.wordpress.com/2018/10/asm_tests_ci.pdf">6502 Test Driven Development and Continuous Integration&lt;/a>&lt;/li>
&lt;li>Livestream: &lt;a href="https://media.ccc.de/c/vcfb18">https://vcfb.de/2018/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Many thanks to &lt;a href="http://www.stefan-hoeltgen.de/">Dr. Stefan Höltgen&lt;/a> and his team arround the VCFB which made it possible that we could take a part on that cool event!&lt;/p></content></item></channel></rss>