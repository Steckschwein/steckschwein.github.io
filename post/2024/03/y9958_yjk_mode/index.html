<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>YM9958 YJK (YUV) mode - Steckschwein</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="YM9958 YJK (YUV) mode"><meta property="og:description" content="Some time ago we introduced a tiny tool called ppmview.prg in our collection of tools and progs for our Steckschwein. The ppmview.prg, as the name already tells, is able to load an image in ppm (Portable BitMap) format with a maximum size of 256x212px and displays it on the screen.
The first version of ppmview was released in 2018 and since then we just use the SCREEN 8 (MSX) also known as graphic mode 7 (RGB)."><meta property="og:type" content="article"><meta property="og:url" content="https://www.steckschwein.de/post/2024/03/y9958_yjk_mode/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-03-20T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-20T00:00:00+00:00"><meta itemprop=name content="YM9958 YJK (YUV) mode"><meta itemprop=description content="Some time ago we introduced a tiny tool called ppmview.prg in our collection of tools and progs for our Steckschwein. The ppmview.prg, as the name already tells, is able to load an image in ppm (Portable BitMap) format with a maximum size of 256x212px and displays it on the screen.
The first version of ppmview was released in 2018 and since then we just use the SCREEN 8 (MSX) also known as graphic mode 7 (RGB)."><meta itemprop=datePublished content="2024-03-20T00:00:00+00:00"><meta itemprop=dateModified content="2024-03-20T00:00:00+00:00"><meta itemprop=wordCount content="1386"><meta itemprop=keywords content="6502,msx,msx2,msx2+,screen 8,screen 12,vdp,vram,yjk,yuv,y9958,"><meta name=twitter:card content="summary"><meta name=twitter:title content="YM9958 YJK (YUV) mode"><meta name=twitter:description content="Some time ago we introduced a tiny tool called ppmview.prg in our collection of tools and progs for our Steckschwein. The ppmview.prg, as the name already tells, is able to load an image in ppm (Portable BitMap) format with a maximum size of 256x212px and displays it on the screen.
The first version of ppmview was released in 2018 and since then we just use the SCREEN 8 (MSX) also known as graphic mode 7 (RGB)."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=Steckschwein rel=home><div class="logo__item logo__text"><div class=logo__title>Steckschwein</div><div class=logo__tagline>An 8bit computer for the 21st century</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li><li class=menu__item><a class=menu__link href=/><span class=menu__text>Blog</span></a></li><li class=menu__item><a class=menu__link href=/hardware/><span class=menu__text>Hardware</span></a></li><li class=menu__item><a class=menu__link href=/software/><span class=menu__text>Software</span></a></li><li class=menu__item><a class=menu__link href=/resources/><span class=menu__text>Resources</span></a></li><li class=menu__item><a class=menu__link href=/impressum/><span class=menu__text>Impressum</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>YM9958 YJK (YUV) mode</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2024-03-20T00:00:00Z>March 20, 2024</time></div></div></header><div class="content post__content clearfix"><p>Some time ago we introduced a tiny tool called <em>ppmview.prg</em> in our collection of tools and progs for our Steckschwein. The ppmview.prg, as the name already tells, is able to load an image in ppm (<a href=https://en.wikipedia.org/wiki/Netpbm>Portable BitMap</a>) format with a maximum size of 256x212px and displays it on the screen.</p><p>The first version of ppmview was released in 2018 and since then we just use the SCREEN 8 (MSX) also known as graphic mode 7 (RGB).<br>Mode 7 is a bitmap mode where we have 256 colors available and each pixel requires 1 Byte for their color information.
The 1 Byte color information must be stored in VRAM encoded as GRB 3:3:2 (green, red, blue), which means 3 Bit green, 3 Bit red and 2 Bit blue.<br>On the other side we have the PPM color information - which is 24Bit RGB - so we have to adapt or map the 24Bit to our 8 Bit GRB color value in some way.<br>It becomes apparent that this comes with a price, namely the loss of color information. Especially the blue part of the pixel is just 2 Bit, hence we have 4 levels of blue per pixel available only.
The following screenshot from our <a href=https://github.com/Steckschwein/steckschwein-emulator/>Emulator</a> shows the loss of color information.</p><p><img alt="Lena PPM to SCREEN 8 GRB" src=/post/2024/03/Y9958_yjk_mode.rgb.png></p><p>There must be more to it&mldr;</p><p>In the technical documentation of the Y9958 one can read that there where some registers added. Beside the horizontal scroll registers R#26, R#27, register R#25 was added and offers 2 interesting Bits we&rsquo;ll now focus on. These are Bit 4 and Bit 3 in R#25.</p><h4 id=yjk-type-data-display-function-r25>YJK-Type Data Display Function R#25</h4><div style=width:50%;text-align:center><table><thead><tr><th>Bit 7</th><th>Bit 6</th><th>Bit 5</th><th>Bit 4</th><th>Bit 3</th><th>Bit 2</th><th>Bit 1</th><th>Bit 0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td>YAE</td><td><strong>YJK</strong></td><td></td><td></td><td></td></tr></tbody></table></div><p>If Bit 3 of R#25 is set the Y9958 will read the data from VRAM and interprets them as YJK typed data. The VDP converts the YJK data to corresponding RGB signals via the internal DAC which has 5 Bit per color part (RGB).
All we have to do now is just encode the 24Bit RGB value given in the ppm file to appropriate YJK values in the VDP RAM. From the datasheet we can find out that 4 Bytes in VRAM are grouped together to encode the YJK data for 4 consecutive pixels.</p><h4 id=yjk-data-in-vram-for-4-pixels>YJK Data in VRAM for 4 pixels</h4><pre tabindex=0><code>          | C7 | C6 | C5 | C4 | C3 | C2 | C1 | C0 |
          |----+----+----+----+----+----+----+----|
1st pixel |           Y0           |      KL      |
2nd pixel |           Y1           |      KH      |
3rd pixel |           Y2           |      JL      |
4th pixel |           Y3           |      JH      |
</code></pre><p>Furthermore the forumlas to convert the RGB data to YJK representation is given in the datasheet with</p><h4 id=from-rgb-to-yjk>from RGB to YJK</h4><pre tabindex=0><code>Y = B/2 + R/4 + G/8
J = R – Y
K = G – Y
</code></pre><p>The Y value specifies the brightness and may vary for each pixel, but the color information (chrominance), given as J and K, is shared among 4 pixels.
Somehow we have to derrive or calculate the J and K values upon the RGB information of 4 adjacent pixels in the ppm file. There are various approaches available for doing that,
i decided to use a lightweight kind of chroma- or color- sub-sampling based on the 4:1:1 approach.</p><h4 id=lightweight-411-color-sub-sampling>Lightweight 4:1:1 color sub-sampling</h4><p>The idea behind color sub-sampling is to use the average of each component (RGB) from 4 pixels and calculate a median Y upon the formula given above. But we need to be careful to round the result during the calculation.</p><pre tabindex=0><code> R_a = round((R0 + R1 + R2 + R3) / 4)
</code></pre><p>In 6502 assembly there is no DIV instruction nor can we round up the result of a calculation. But we can easily shift left and right. We end up in some code like this</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>    <span style=color:#a6e22e>CLC</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LDA</span> <span style=color:#75715e>#2                    ; R_a = ((R0 + R1 + R2 + R3 + 2)&gt;&gt;2); B_a, G_a same manner
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ADC</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>R0</span>,<span style=color:#66d9ef>Y</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ADC</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>R1</span>,<span style=color:#66d9ef>Y</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ADC</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>R2</span>,<span style=color:#66d9ef>Y</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ADC</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>R3</span>,<span style=color:#66d9ef>Y</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LSR</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LSR</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>STA</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>R_a</span>,<span style=color:#66d9ef>Y</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>...</span>
</span></span></code></pre></div><p>R0..R3 are the R component of the 4 adjacent pixels which we read from the ppm file beforehand. In R0..R3 and G0..G3, B0..B3 respectively we only use the 5 higher Bits of the RGB value from the ppm file. This is because the Y values are also just 5 Bits wide.</p><p>Furthermore we add #2 to the sum of the R components. This is for &ldquo;rounding up&rdquo;, cause if we divide by 4, which is simply 2 shifts right (LSR) on 6502 we&rsquo;ll lose the fraction. To round up, we use the fact that</p><pre tabindex=0><code>  round(A/B) = (A + (B/2)) / B =&gt; e.g. round(5/2) = (5 + 1) / 2 = 3 FTW!
</code></pre><p>With the average RGB values R_a, G_a, B_a we can calculate the average of Y with the formula given from the datasheet.</p><pre tabindex=0><code>  Y_a = round(B_a/2 + R_a/4 + G_a/8)
</code></pre><p>Some transformation to ease the 6502 coding, we end up in</p><pre tabindex=0><code>  Y_a = (4*B_a + 2*R_a + G_a + 4) / 8 # rounding is replaced with +4
      = (B_a&lt;&lt;2 + R_a&lt;&lt;1 + G_a + 4) &gt;&gt; 8
</code></pre><p>and in 6502 assembly</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>    <span style=color:#a6e22e>ASL</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>B_a</span>  <span style=color:#75715e>; B_a &lt;&lt; 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ASL</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>B_a</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LDA</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>R_a</span>  <span style=color:#75715e>; R_a &lt;&lt; 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ASL</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CLC</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ADC</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>B_a</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ADC</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>G_a</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ADC</span> <span style=color:#75715e>#4                  ; +4 for round up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>LSR</span>                     <span style=color:#75715e>; DIV 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>LSR</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LSR</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>STA</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>Y_a</span>
</span></span></code></pre></div><p>The J and K values can now be calculated upon the formulars from the datasheet, and are just the difference between Y_a and R_a and G_a, respectively.</p><pre tabindex=0><code>    J = R_a - Y_a
    K = G_a - Y_a
</code></pre><p>and in 6502 assembly it&rsquo;s just a simple subtraction.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>    <span style=color:#a6e22e>SEC</span>                       <span style=color:#75715e>; J = R_a - Y_a;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>lda</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>R_a</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>SBC</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>Y_a</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>STA</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>J</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>...</span>
</span></span></code></pre></div><p>Now that we have J, K available we can calculate back the Y0..Y3 values for each pixel. Again we have to use the formular Y = B/2 + R/4 + G/8 from the datasheet and apply them for each pixel.
We use the same transformation from above to get simple 6502 assembly code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>    <span style=color:#a6e22e>LDA</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>B3</span>,<span style=color:#66d9ef>Y</span>   <span style=color:#75715e>; Y3..Y0 = round(B0/2 + R0/4 + G0/8) = (B0&lt;&lt;2 + R0&lt;&lt;1 + G + 4) &gt;&gt; 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ASL</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ASL</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>STA</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>B3</span>,<span style=color:#66d9ef>Y</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LDA</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>R3</span>,<span style=color:#66d9ef>Y</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ASL</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CLC</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ADC</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>B3</span>,<span style=color:#66d9ef>Y</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ADC</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>G3</span>,<span style=color:#66d9ef>Y</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ADC</span> <span style=color:#75715e>#4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>AND</span> <span style=color:#75715e>#$F8                  ; !!! we do not &gt;&gt;3 (div 8) but mask out bit 2..0 since the y value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>STA</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>Y3</span>,<span style=color:#66d9ef>Y</span>   <span style=color:#75715e>; in vram has to be placed as bit 7..3 and bit 2..0 are the k/j component
</span></span></span></code></pre></div><p>The calculation from Y3 down to Y0 can be done in a loop, that&rsquo;s why i use the indrect addressing mode. There is an appropriate yjk struct (ca65 assembly) which is structured in a way that we easily can count down the index.<br>Note that the DIV 8 step is intentionally left out here, but rather we mask the result with #$F8. That&rsquo;s because the Y values in VRAM must be stored in Bit 7..3 which is exactly our result so we must not shift to right 3 times just to shift left 3 times while combining with J, K ;)</p><p>The rest of the code is easy, we just combine the calculated Y0..Y3 values with J,K.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>    <span style=color:#a6e22e>LDA</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>K</span>      <span style=color:#75715e>; Y0 with K low
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>AND</span> <span style=color:#75715e>#$07
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ORA</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>Y0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>STA</span> <span style=color:#66d9ef>a_vram</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LDA</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>K</span>      <span style=color:#75715e>; Y1 with K high
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>LSR</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LSR</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LSR</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>AND</span> <span style=color:#75715e>#$07
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ORA</span> <span style=color:#66d9ef>yjk_chunk</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>yjk</span>::<span style=color:#66d9ef>Y1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>STA</span> <span style=color:#66d9ef>a_vram</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>...</span>
</span></span></code></pre></div><p>for Y2,Y3 same manner but with J.</p><p>Finally we putting it all together and enhance our ppmview.prg with the YJK mode, also known as SCREEN 12 in MSX Basic. We also add an option -rgb to support the &ldquo;old&rdquo; RGB mode still.</p><p><img alt="Lena PPM to SCREEN 12 YJK" src=/post/2024/03/Y9958_yjk_mode.yjk.png></p><p>I think the result in YJK mode, especially when used with fotos, is very impressive and even though we have followed the simple approach of sub-sampling only.</p><p>The source of ppmview and the ppm library are available at <a href=https://github.com/Steckschwein/code/>Github</a>.</p><p>What we did not focussed on yet is the YAE (Bit 4) in R#25. The so called SCREEN 10 and SCREEN 11 modes (MSX Basic). Maybe this is something we will have a look in the future.</p><p>Further readings and investigations whether this mode was being used in MSX2/MSX2+ at all, i found interesting articles about the YJK mode (see links below). As far as i can see there is no game or kind of which is using this mode &ldquo;heavily&rdquo; (yet) ;)</p><h4 id=links>Links</h4><ul><li><a target=_blank href=https://map.grauw.nl/articles/yjk/>https://map.grauw.nl/articles/yjk/</a></li><li><a target=_blank href="https://tomseditor.com/gallery/browse?platform=msx&format=screen12">https:\tomseditor.com\gallery\browse?platform=msx&amp;format=screen12</a></li><li><a target=_blank href=https://en.wikipedia.org/wiki/Chroma_subsampling>https:\en.wikipedia.org\wiki\Chroma_subsampling</a></li></ul></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/6502/ rel=tag>6502</a></li><li class=tags__item><a class="tags__link btn" href=/tags/msx/ rel=tag>msx</a></li><li class=tags__item><a class="tags__link btn" href=/tags/msx2/ rel=tag>msx2</a></li><li class=tags__item><a class="tags__link btn" href=/tags/msx2+/ rel=tag>msx2+</a></li><li class=tags__item><a class="tags__link btn" href=/tags/screen-8/ rel=tag>screen 8</a></li><li class=tags__item><a class="tags__link btn" href=/tags/screen-12/ rel=tag>screen 12</a></li><li class=tags__item><a class="tags__link btn" href=/tags/vdp/ rel=tag>vdp</a></li><li class=tags__item><a class="tags__link btn" href=/tags/vram/ rel=tag>vram</a></li><li class=tags__item><a class="tags__link btn" href=/tags/yjk/ rel=tag>yjk</a></li><li class=tags__item><a class="tags__link btn" href=/tags/yuv/ rel=tag>yuv</a></li><li class=tags__item><a class="tags__link btn" href=/tags/y9958/ rel=tag>y9958</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2024 Steckschwein.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>