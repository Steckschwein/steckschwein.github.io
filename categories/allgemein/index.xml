<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>allgemein on</title><link>https://beta.steckschwein.de/categories/allgemein/</link><description>Recent content in allgemein on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 14 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://beta.steckschwein.de/categories/allgemein/index.xml" rel="self" type="application/rss+xml"/><item><title>Fixing PS/2 Keyboard handling (Part I)</title><link>https://beta.steckschwein.de/post/fixing-ps-2-keyboard-handling-part-i/</link><pubDate>Sat, 14 Nov 2020 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/fixing-ps-2-keyboard-handling-part-i/</guid><description>The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:
The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI. The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&amp;rsquo;t the states of the keyboard LEDs.</description><content>&lt;p>The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:&lt;/p>
&lt;ul>
&lt;li>The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI.&lt;/li>
&lt;li>The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&amp;rsquo;t the states of the keyboard LEDs.&lt;/li>
&lt;/ul>
&lt;p>Although mid- to long term, we likely might &amp;ldquo;upgrade&amp;rdquo; to USB anyway, but not without having done PS/2 right first. So, I will talk about integrating IRQ handling, and in a follow up post Marko will talk about how he got the PS/2 controller talking to the keyboard.&lt;/p>
&lt;p>Luckily, during the design of the IO-board, we have been clever enough to hook IO-pins PC0 to PC2 to RESET_TRIG, NMI and IRQ, respectively. So on the hardware-side, we are very much ready.&lt;br>
First problem to solve is how to emulate an open collector output on the AVR controller. As it seems, a common way to do that is to disable the internal pullup of the pin, and have it configured as input to be &amp;ldquo;tri state&amp;rdquo;. When active, the pin gets activated as an output, and will pull the IRQ line low.&lt;/p>
&lt;p>&lt;code>// pull IRQ line DDRC |= (1 &amp;lt;&amp;lt; IRQ);&lt;/code>&lt;/p>
&lt;p>&lt;code>// release IRQ line DDRC &amp;amp;= ~(1 &amp;lt;&amp;lt; IRQ);&lt;/code>&lt;/p>
&lt;p>Now that we know how to handle the IRQ-line, we need to figure out, WHEN to pull it. Obviously when a key was hit. And when to release it?&lt;/p>
&lt;p>Finally, we decided to go the most simple way. The PS/2 controller will pull the IRQ line as long as there are more than 0 chars in the buffer. Once the buffer is empty, the IRQ-line will be released. This way, we do not need an interrupt register and hence no time consuming check of the latter, but need to do a little buffering on the steckOS-side.&lt;/p>
&lt;p>This is all the code that&amp;rsquo;s needed on the PS/2 controller side:&lt;/p>
&lt;pre tabindex="0">&lt;code> if (kb_buffcnt &amp;gt; 0)
{
DDRC |= (1 &amp;lt;&amp;lt; IRQ); // pull IRQ line
}
else
{
DDRC &amp;amp;= ~(1 &amp;lt;&amp;lt; IRQ); // release IRQ line
}
&lt;/code>&lt;/pre>&lt;p>Now, we need to add a little handling code to the steckOS IRQ-handler. Since we do not have an interrupt register, we just check the keyboard last, after every &amp;ldquo;known&amp;rdquo; interrupt source has been handled.&lt;br>
To get around having to implement another keyboard buffer, we just use a single memory location, labelled &amp;ldquo;key&amp;rdquo;. The IRQ handler will only fetch a byte from the keyboard when the target location is zero (0), otherwise it will just exit.&lt;br>
The system getkey-routine will load the contents from that location into the A register, and overwrite the location with 0 again to enable fetching the next char from the buffer.&lt;/p>
&lt;p>The SPI check code is the last bit in the IRQ-handler routine:&lt;/p>
&lt;pre tabindex="0">&lt;code>@check_spi:
lda key
bne @exit
jsr fetchkey
bcc @exit
sta key
@exit:
restore
rti
&lt;/code>&lt;/pre>&lt;p>That&amp;rsquo;s basically all that&amp;rsquo;s needed. The former getkey-routine has been renamed to fetchkey, and the new getkey routine only handles the ZP buffer location while retaining the old behaviour including setting the carry flag when a byte has been received. This way, existing programs using the keyboard do not have to be modified.&lt;/p>
&lt;p>Now, we finally have a chance of reacting to keystrokes during program execution without having to explicitly poll the keyboard. This enables us to handle Ctrl-C and such much more elegantly. Also, any REPL-like program (like the shell) does not have to constantly poll the SPI bus.&lt;/p></content></item><item><title>Connecting SNES Controller to the Steckschwein</title><link>https://beta.steckschwein.de/post/connecting-snes-controller-to-the-steckschwein/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/connecting-snes-controller-to-the-steckschwein/</guid><description>Recently, Michael Steil published a blog post about connecting NES and SNES Controller to a 6502-based system showing how to use NES and SNES controllers on a C64 without the need for any special hardware, by just connecting them to the C64&amp;rsquo;s user port.
Why not use his approach and adapt it to the Steckschwein? The Steckschwein has a User Port, too, albeit a very different one as the C64. Basically, the Steckschwein-User-Port consists of the complete Port A of the VIA, plus the /RESET and /IRQ lines.</description><content>&lt;p>Recently, Michael Steil published a &lt;a href="https://www.pagetable.com/?p=1365">blog post about connecting NES and SNES Controller to a 6502-based system&lt;/a> showing how to use NES and SNES controllers on a C64 without the need for any special hardware, by just connecting them to the C64&amp;rsquo;s user port.&lt;/p>
&lt;p>Why not use his approach and adapt it to the Steckschwein? The Steckschwein has a User Port, too, albeit a very different one as the C64. Basically, the Steckschwein-User-Port consists of the complete Port A of the VIA, plus the /RESET and /IRQ lines. Also of course, VCC and GND.&lt;/p>
&lt;pre tabindex="0">&lt;code>User Port:
|---------GND
| |-------PA6
| | |-----PA4
| | | |---PA2 (DATA1)
| | | | |-PA0 (CLK)
o o X o o o o o
o o X o o o o o
| | | | |-PA1 (LATCH)
| | | |---PA3 (DATA2)
| | |-----PA5
| | |-----PA7
|---------VCC
SNES Controller:
/---------------------
| 7 6 5 | 4 3 2 1 |
\\---------------------
Pin Description
1 +5V
2 CLK
3 LATCH
4 DATA
5 –
6 –
7 GND
&lt;/code>&lt;/pre>&lt;p>&lt;img src="images/snes.jpg" alt="snes"> Simple adapter to connect one SNES controller&lt;/p>
&lt;p>As for the code, we use Michael&amp;rsquo;s code with only a few modifications respective to the different pinout, and with a handful of optimizations. Having a 65c02 instead of the 6510 in the C64 gives us the STZ instruction, also using PA0 as clock pin takes just an INC instruction followed by STZ to pulse the clock line.&lt;/p>
&lt;pre tabindex="0">&lt;code>nes_data = via1porta
nes_ddr = via1ddra
; zero page
controller1 = $00 ; 3 bytes
controller2 = $03 ; 3 bytes
bit_clk = %00000001 ; PA0 : CLK (both controllers)
bit_latch = %00000010 ; PA1 : LATCH (both controllers)
bit_data1 = %00000100 ; PA2 : DATA (controller #1)
bit_data2 = %00001000 ; PA3 : DATA (controller #2)
query_controllers:
lda #$ff-bit_data1-bit_data2
sta nes_ddr
lda #$00
sta nes_data
; pulse latch
lda #bit_latch
sta nes_data
;lda #0
;sta nes_data
stz nes_data
; read 3x 8 bits
ldx #0
l2: ldy #8
l1: lda nes_data
cmp #bit_data2
rol controller2,x
and #bit_data1
cmp #bit_data1
rol controller1,x
;lda #bit_clk
;sta nes_data
inc nes_data
;lda #0
;sta nes_data
stz nes_data
dey
bne l1
inx
cpx #3
bne l2
rts
&lt;/code>&lt;/pre>&lt;p>Small test program to output a different character for each button:&lt;/p>
&lt;p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/GgCyrkfQ8-o" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
 &lt;/p>
&lt;p>Also, instead of the original Nintendo SNES controller, I use an &lt;a href="https://www.8bitdo.com/">8bitdo SN30&lt;/a> Bluetooth controller with the SNES receiver. One could say this is the first time a Bluetooth device has been connected to the Steckschwein.&lt;/p>
&lt;p>&lt;img src="images/img_5814.jpg" alt="IMG_5814"> Bluetooth SNES receiver from 8bitdo&lt;/p>
&lt;p>Up next: Patching our games!&lt;/p></content></item><item><title>Steckschwein emulator</title><link>https://beta.steckschwein.de/post/steckschwein-emulator/</link><pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/steckschwein-emulator/</guid><description>Back from the VCFB (Vintage Computer Festival Berlin) 2019 where we had good talks, met interesting people and got new ideas. Especially from Michael Steil who just asked the simple question &amp;ldquo;How you can develop software for the Steckschwein without an emulator?&amp;rdquo;
With the answer in my mind I felt a little annoyed and also &amp;ldquo;triggered&amp;rdquo; at the same time&amp;hellip; However, Michael Steil was nice enough to strip down his Commander X16-Emulator into a barebone 65c02 computer emulator, so all we had to do was to implement our memory map (easy) and borrow a V9958 video chip implementation from blueMSX and implement it into the emulator (hard).</description><content>&lt;p>Back from the VCFB (Vintage Computer Festival Berlin) 2019 where we had good talks, met interesting people and got new ideas. Especially from &lt;a href="https://www.pagetable.com/">Michael Steil&lt;/a> who just asked the simple question &lt;strong>&amp;ldquo;How you can develop software for the Steckschwein without an emulator?&amp;rdquo;&lt;/strong>&lt;/p>
&lt;p>With the answer in my mind I felt a little annoyed and also &amp;ldquo;triggered&amp;rdquo; at the same time&amp;hellip; However, Michael Steil was nice enough to strip down his Commander X16-Emulator into a barebone 65c02 computer emulator, so all we had to do was to implement our memory map (easy) and borrow a V9958 video chip implementation from blueMSX and implement it into the emulator (hard).&lt;/p>
&lt;p>We&amp;rsquo;ll guide you through the adaption of the emulator step by step. Let&amp;rsquo;s start with the &amp;ldquo;easy&amp;rdquo; part, the&amp;hellip;&lt;/p>
&lt;h3 id="memory-mapping">Memory Mapping&lt;/h3>
&lt;p>is done in a dedicated file &lt;a href="https://github.com/twoinke/steckschwein-emulator/blob/master/memory.c">memory.c&lt;/a> where we simply do the dispatching to a dedicated hardware emulation upon a given address. Luckily the Steckschwein i/o is located in a dedicated and continuous address range within $0200-$0280.&lt;/p>
&lt;p>So if the CPU accesses these address range e.g. asking for a byte from such an address via&lt;/p>
&lt;p>&lt;code>LDA $0220&lt;/code>&lt;/p>
&lt;p>the emulator dispatches the memory read to the corresponding i/o implementation. this  is done with a simple ordered &amp;ldquo;if-cascade&amp;rdquo; as follows&lt;/p>
&lt;pre tabindex="0">&lt;code>uint8_t
real_read6502(uint16_t address, bool debugOn, uint8_t bank)
{
if (address &amp;lt; 0x0200)
{ // RAM
return RAM[address];
}
else if (address &amp;lt; 0x0280) { // I/O
// TODO I/O map?
if (address &amp;lt; 0x210) // UART at $0200
{
return uart_read(address &amp;amp; 0xf);
}
else if (address &amp;lt; 0x0220) // VIA at $0210
{
return via1_read(address &amp;amp; 0xf);
}
else if (address &amp;lt; 0x0230) // VDP at $0220
{
return ioPortRead(NULL,address);
}
&lt;/code>&lt;/pre>&lt;p>The LDA shown above will end up in the line with&lt;/p>
&lt;p>&lt;code>return ioPortRead(NULL,address);&lt;/code>&lt;/p>
&lt;p>and thus our VDP implementation is asked for a byte to read.&lt;/p>
&lt;p>All other addresses are either RAM or ROM depending on the value within our memory control port $0230. For more details check out the &lt;a href="http://steckschwein.de/hardware/cpuramdecoder/">memory map&lt;/a>.&lt;/p>
&lt;h3 id="via-and-sdcard">VIA and SDCard&lt;/h3>
&lt;p>The X16 and the Steckschwein share a few similar approaches, for example in terms of mass storage and/or peripheral communication. Both use the VIA to implement the SPI bus protocol via &amp;ldquo;bit banging&amp;rdquo; to communicate with various components, such as the SD card or the RTC. This part of the emulator almost completely derived from the X16 emulator, with only small modifications.&lt;/p>
&lt;h3 id="emulating-the-v9958">Emulating the V9958&lt;/h3>
&lt;p>The video part was much more difficult, because Steckschwein uses the &lt;a href="http://steckschwein.de/hardware/v9958-video-board/">V9958&lt;/a>. Emulating that kind of video chip is much much work todo and requires a very good understanding what&amp;rsquo;s really going on within the chip at every µs when the screen is drawn.&lt;/p>
&lt;p>Fortunately the MSX and MSX2 systems are very good documented and there are plenty of emulators with source available. As this sounds good the outcome of our investigation was quite sober. Only the fMSX and the blueMSX emulators gave us an idea how we can use or reuse the code of the VDP implementation.&lt;/p>
&lt;p>Although the &lt;a href="http://www.bluemsx.com/">blueMSX&lt;/a> code is not maintained anymore we decided to give&amp;rsquo;em a try. This is because the blueMSX implementation is build more like a kind of emulator framework which can be used to build emulators for a wide range of hardware and not only for MSX systems.&lt;/p>
&lt;p>For short, the following changes where made to get the emulator with the VDP work&lt;/p>
&lt;ol>
&lt;li>strip out unnecessary code and extract the raw VDP V9558 implementation&lt;/li>
&lt;li>create a blueMSX board implementation for Steckschwein&lt;/li>
&lt;li>adapt the fake6502.c code to the blueMSX API with the appropriate cpu callbacks&lt;/li>
&lt;li>glue code to dispatch the i/o access of addresses $220-$224 to the blueMSX VDP code&lt;/li>
&lt;li>get cyclic exact timings required for video by using the blueMSX timer loop&lt;/li>
&lt;/ol>
&lt;p>And here we are&amp;hellip; the emulator is able to boot our bios, which in turn mounts the sdcard and loads the kernel just like the real Steckschwein does.&lt;/p>
&lt;p>&lt;img src="images/steckschwein_emulator_vdp-1.jpg" alt="steckschwein_emulator_vdp">&lt;/p>
&lt;p>On the screenshot you may have noticed the &amp;ldquo;date&amp;rdquo; tool, which actually gives the correct datetime. Hence the rtc emulation is also done already.&lt;/p>
&lt;p>to be continued&amp;hellip;&lt;/p>
&lt;p>code: &lt;a href="https://github.com/Steckschwein/steckschwein-emulator">https://github.com/Steckschwein/steckschwein-emulator&lt;/a>&lt;/p></content></item><item><title>Markos Pacman Talk at VCFb</title><link>https://beta.steckschwein.de/post/markos-pacman-talk-at-vcfb/</link><pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/markos-pacman-talk-at-vcfb/</guid><description>Marko talked about his Pacman port to the Steckschwein at VCFb. Basically it&amp;rsquo;s the same talk he did at VCFe in April, but this time, there&amp;rsquo;s a video. Enjoy!
https://media.ccc.de/v/vcfb19_-_111_-_de_-_201910121615_-_pac-man_auf_dem_steckschwein_-_marko_lauke</description><content>&lt;p>Marko talked about his Pacman port to the Steckschwein at VCFb. Basically it&amp;rsquo;s the same talk he did at VCFe in April, but this time, there&amp;rsquo;s a video. Enjoy!&lt;/p>
&lt;p>&lt;a href="https://media.ccc.de/v/vcfb19_-_111_-_de_-_201910121615_-_pac-man_auf_dem_steckschwein_-_marko_lauke">https://media.ccc.de/v/vcfb19_-_111_-_de_-_201910121615_-_pac-man_auf_dem_steckschwein_-_marko_lauke&lt;/a>&lt;/p></content></item><item><title>Forth Benchmarks</title><link>https://beta.steckschwein.de/post/forth-benchmarks/</link><pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/forth-benchmarks/</guid><description>The main motivation to get Forth up and running on the Steckschwein was to participate at The Ultimate Benchmark, in order to crush all 8bit competition to dust.
So the plan was to benchmark the Steckschwein live at the VCFe. Unfortunately, Carsten could not be there, so no Forth benchmark competition this year. Recently, Carsten presented his benchmark results using TaliForth2, which led us to run the same benchmarks he did and send the results to Carsten, who was kind enough to include them on his site:</description><content>&lt;p>The main motivation to get Forth up and running on the Steckschwein was to participate at &lt;a href="https://theultimatebenchmark.org/">The Ultimate Benchmark&lt;/a>, in order to crush all 8bit competition to dust.&lt;/p>
&lt;p>So the plan was to benchmark the Steckschwein live at the VCFe. Unfortunately, Carsten could not be there, so no Forth benchmark competition this year. Recently, Carsten presented his benchmark results using TaliForth2, which led us to run the same benchmarks he did and send the results to Carsten, who was kind enough to include them on his site:&lt;/p>
&lt;p>&lt;a href="https://theultimatebenchmark.org/#sec-7">https://theultimatebenchmark.org/#sec-7&lt;/a>&lt;/p></content></item><item><title>VCFe 20.0 - over and out</title><link>https://beta.steckschwein.de/post/vcfe-20-0-over-and-out/</link><pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/vcfe-20-0-over-and-out/</guid><description>VCFe 20.0 is over, all of a sudden, and we had lots of fun as always.
Many thanks to everyone stopping by at our table, especially to those who voted for us at the poll. We got the fo(u)rth place.
Special thanks to Michael Steil, Andre Fachat und Marco Baye for hanging and hacking with us.
Very special thanks to Andre Fachat for his inpromptu 6502 talk right before our turn.</description><content>&lt;p>VCFe 20.0 is over, all of a sudden, and we had lots of fun as always.&lt;/p>
&lt;p>Many thanks to everyone stopping by at our table, especially to those who voted for us at the poll. We got the fo(u)rth place.&lt;/p>
&lt;p>Special thanks to Michael Steil, Andre Fachat und Marco Baye for hanging and hacking with us.&lt;/p>
&lt;p>Very special thanks to Andre Fachat for his inpromptu 6502 talk right before our turn. I think we did prepare a real feast for every 6502 afficionado.&lt;/p></content></item><item><title>Vintage Computer Festival Europe</title><link>https://beta.steckschwein.de/post/vintage-computer-festival-europe/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/vintage-computer-festival-europe/</guid><description>Das VCFe steht wieder vor der Tür. Am kommenden Wochenende, also vom 27.4. bis 28.4., findet das Vintage Computer Festival Europe in München statt.
Das diesjährige Motto ist &amp;ldquo;Pixelritter - Programmieren am Limit&amp;rdquo;. Und auch auf dem Steckschwein werden wir Pixel zeigen, teilweise am Limit programmiert.
Veranstaltungsort ist das Kulturzentrum Trudering
Wasserburger Landstrasse 32 81825 München</description><content>&lt;p>Das VCFe steht wieder vor der Tür. Am kommenden Wochenende, also vom 27.4. bis 28.4., findet das &lt;a href="http://www.vcfe.org">Vintage Computer Festival Europe&lt;/a> in München statt.&lt;/p>
&lt;p>Das diesjährige Motto ist &amp;ldquo;Pixelritter - Programmieren am Limit&amp;rdquo;. Und auch auf dem Steckschwein werden wir Pixel zeigen, teilweise am Limit programmiert.&lt;/p>
&lt;p>Veranstaltungsort ist das Kulturzentrum Trudering&lt;/p>
&lt;p>Wasserburger Landstrasse 32 81825 München&lt;/p></content></item><item><title>Make Munich 2019 - It's been our pleasure</title><link>https://beta.steckschwein.de/post/make-munich-2019-is-been-our-pleasure/</link><pubDate>Sun, 03 Mar 2019 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/make-munich-2019-is-been-our-pleasure/</guid><description>Make Munich 2019 was awesome. Thanks to everyone who helped making this great event possible.
Again, we are stunned by how much positive feedback we got from so many people. Thank you all!!
Also, like in 2016, our booth was partly turned by a lot of kids into the official Make Munich arcade. So we definitely need to write more games. And build more Steckschweins. Let the children play.</description><content>&lt;p>Make Munich 2019 was awesome. Thanks to everyone who helped making this great event possible.&lt;/p>
&lt;p>Again, we are stunned by how much positive feedback we got from so many people. Thank you all!!&lt;/p>
&lt;p>Also, like in 2016, our booth was partly turned by a lot of kids into the official Make Munich arcade. So we definitely need to write more games. And build more Steckschweins. Let the children play.&lt;/p></content></item><item><title>Meet us at Make Munich, 2.3. - 3.3.2019</title><link>https://beta.steckschwein.de/post/meet-us-at-make-munich-2-3-3-3-2019/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/meet-us-at-make-munich-2-3-3-3-2019/</guid><description>Check out our homebrew 65c02 8bit goodness including our brand new video/sound-hardware at the Make Munich fair. We&amp;rsquo;ll also have BASIC, Forth, a couple of games and candy. Our booth is in Hall 1, Booth Nr. 49, in the &amp;ldquo;Electronic Innovators&amp;rdquo;-Area. The did get that right, didn&amp;rsquo;t they?</description><content>&lt;p>Check out our homebrew 65c02 8bit goodness including our &lt;a href="http://steckschwein.de/2018/12/07/new-v9958-board-with-integrated-opl2/">brand new video/sound-hardware&lt;/a> at the Make Munich fair. We&amp;rsquo;ll also have BASIC, Forth, a couple of games and candy. Our booth is in Hall 1, Booth Nr. 49, in the &amp;ldquo;Electronic Innovators&amp;rdquo;-Area. The did get that right, didn&amp;rsquo;t they?&lt;/p></content></item><item><title>Fixing the white screen problem on a Tekway DST1062B oscilloscope</title><link>https://beta.steckschwein.de/post/fixing-the-white-screen-problem-on-a-tekway-dst1062b-oscilloscope/</link><pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/fixing-the-white-screen-problem-on-a-tekway-dst1062b-oscilloscope/</guid><description>The Tekway DST 1062B (also known unter the Hantek or Voltcraft brand) is an inexpensive 60MHz digital storage oscilloscope, which is very much hackable and has proven to be worth its weight in gold pressed latinum.
More recently, my scope became affected by the infamous white screen problem, which apparently is a problem quite common to this model and its 100MHz or 200MHz siblings.
The Tekway/Hantek white screen of death</description><content>&lt;p>The Tekway DST 1062B (also known unter the Hantek or Voltcraft brand) is an inexpensive 60MHz digital storage oscilloscope, which is very much hackable and has proven to be worth its weight in gold pressed latinum.&lt;/p>
&lt;p>More recently, my scope became affected by the infamous white screen problem, which apparently is a problem quite common to this model and its 100MHz or 200MHz siblings.&lt;/p>
&lt;p>&lt;img src="images/white_screen.jpg" alt=""> The Tekway/Hantek white screen of death&lt;/p>
&lt;p>The screen just goes white, but the scope otherwise responds to pressing buttons, etc. so it appears not to be completely dead. Some research revealed bad connections inside the scope as a possible culprit: &lt;a href="https://hackcorrelation.blogspot.com/2014/01/dso5062b-white-screen-repair-and-hack.html">https://hackcorrelation.blogspot.com/2014/01/dso5062b-white-screen-repair-and-hack.html&lt;/a> But in my case, that did not do anything. More research brought me to a couple of messages within the famous Tekway hacking thread on the EEVBlog-Forum: &lt;a href="https://www.eevblog.com/forum/testgear/hantek-tekway-dso-hack-get-200mhz-bw-for-free/msg87635/#msg87635">https://www.eevblog.com/forum/testgear/hantek-tekway-dso-hack-get-200mhz-bw-for-free/msg87635/#msg87635&lt;/a>&lt;/p>
&lt;p>Forum member &amp;ldquo;bbf&amp;rdquo; told me during a conversation, that he had replaced the 3.3V regulator, but did not remember exactly, which regulator he used. With this information, I went to examine the power supply. The 3.3V rail is powered by a KA78R33 regulator, which is rated for a maximum current of 1A. I removed it in order to power the 3.3V rail directly from my bench supply.&lt;/p>
&lt;p>&lt;img src="images/photo_2019-02-12_17-33-18.jpg" alt=""> That&amp;rsquo;s a lot of load for the stock 3.3V regulator&lt;/p>
&lt;p>And there we have it. The KA78R33 is under a constant load of almost 1.3A. Also using the bench supply I could play around with the exact voltage and I found out, that the scope is very sensitive about the voltage being correct. A voltage drop down to 3.2V will make the screen go white again. To make things worse, the KA78R33 is completely potted in plastic, which I don&amp;rsquo;t imagine to be the best idea in terms of heat dissipation. So we obviously need a beefier 3.3V regulator. I decided to go for a LM1085 which is rated for 3A, so we have plenty of safety margin. Also, it is almost pin compatible with the KA78R33, if inserted &amp;ldquo;the other way around&amp;rdquo;. Also, the LM1085 does not have GND but Vout on it&amp;rsquo;s housing, so one needs to be careful to not have it touch anything it&amp;rsquo;s not supposed to. So with the new regulator, the scope works like a charm again.&lt;/p>
&lt;p>Originally, the scope was sold as fanless, which was a big selling point for me back then. Inside, there happens to be a place to mount an 50mm 12V fan, also the power supply has a 12V rail just to power a fan. To be on the safe side from now on, I installed a fan. I just replaced the 12V regulator with a 9V one in order to keep fan noise down.&lt;/p>
&lt;p>&lt;img src="images/scope_ok_again.jpg" alt="scope_ok_again">&lt;/p></content></item><item><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface</title><link>https://beta.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</link><pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</guid><description>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</description><content>&lt;p>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.&lt;/p>
&lt;p>as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings&lt;/p>
&lt;ol>
&lt;li>the first 2 bytes send to vdp during a write are always register writes which require a short delay of at least 2µs in between each byte&lt;/li>
&lt;li>the write of the 3rd byte (after the 2nd) requires a delay of 8µs. any further &amp;ldquo;single byte transfer&amp;rdquo; - during a vram write - also requires the 8µs delay. the same is true if we want to initiate a register write direclty after a vram write.&lt;/li>
&lt;li>the 3rd and n-th byte write to port #3 (index register port) during a bulk register write requires only the 2µs between each byte&lt;/li>
&lt;/ol>
&lt;p>With this in mind, we can optimize our library a little bit by using different &amp;ldquo;nop slides&amp;rdquo; for address setup and vram writes.&lt;/p>
&lt;p>We enhance our vdp.inc and built two macros which provide the different delay we need.&lt;/p>
&lt;p>.macro vdp_wait_s
jsr vdp_nopslide_2m ; 2m for 2µs wait
&amp;hellip;&lt;/p>
&lt;p>.macro vdp_wait_l
jsr vdp_nopslide_8m ; 8m for 8µs wait
&amp;hellip;&lt;/p>
&lt;p>steckSchwein is running at 8Mhz, so we also defined some equations and used ca65 macros to build our nop slides.&lt;/p>
&lt;p>.define CLOCK_SPEED_MHZ 8&lt;/p>
&lt;p>; long delay with 6µ+2µs (below)
MAX_NOPS_8M = (6 * 1000 / (1000 / CLOCK_SPEED_MHZ)) / 2
; 8Mhz, 125ns per cycle, wait 6µs = 6000ns
; = 6000ns / 125ns = 48cl / 2 =&amp;gt; 24 NOP&lt;/p>
&lt;p>; short delay with 2µs wait
MAX_NOPS_2M = (2 * 1000 / (1000 / CLOCK_SPEED_MHZ) -12) / 2
; -12 =&amp;gt; jsr/rts = 2 * 6cl = 12cl must be subtract&lt;/p>
&lt;p>.macro m_vdp_nopslide
vdp_nopslide_8m:
; long delay with 6+2 2µs wait
.repeat MAX_NOPS_8M
nop
.endrepeat
vdp_nopslide_2m:
.repeat MAX_NOPS_2M
nop
.endrepeat
rts
.endmacro&lt;/p>
&lt;p>Another interesting thing would be, &amp;ldquo;how does the /WAIT&amp;rdquo; behave in this situation? the assumption here is, that the /WAIT will behave in the way as specified. so /WAIT will be go low at least after 130ns from CSW. so to handover the /RDY handling to the vdp via the /WAIT pin, we have to apply only 1 wait state from our WS-Gen. after one wait state, we can release the /RDY low from our WS so that the vdp /WAIT can drive /RDY as needed.&lt;/p>
&lt;p>Back home, Thomas did the test and changed the waitstate generator firmware for the GAL16V8.&lt;/p>
&lt;p>The equation was&lt;/p>
&lt;p>W2 = ROM * UART * SND * /VDP
W1 = W2
+ /ROM * UART * VDP&lt;/p>
&lt;p>and was changed to&lt;/p>
&lt;p>W2 = /SND
W1 = W2
+ /ROM ; /ROM wait state if ROM is cs
+ /VDP ; /VDP wait state if VDP is cs&lt;/p>
&lt;p>So finally, we only need one wait state from the waitstate generator to access the VDP. If the VDP requires more time - surely - during a video memory access it will drive /WAIT to low as long as needed. So after the explcit 1WS from our wait state generator we now hand over the /RDY control to the VDP. How our /RDY and /WAIT really work together is subject to one of our next sessions where we&amp;rsquo;re going to measure the things with a logic analyzer and oscilloscope. Nevertheless, it works in this way and it works exaclty as specified within the datasheet.&lt;/p></content></item><item><title>VCFB 2018 It was great...</title><link>https://beta.steckschwein.de/post/vcfb-2018-its-great/</link><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/vcfb-2018-its-great/</guid><description>VCF 2018 in Berlin was great! We&amp;rsquo;ve met interesting people there. Got a handshake with Scot W. Stevenson who for(th)ced us to use his TaliForth2 ;)
Later on Saturday Daniel Illgen - maintainer of the Adlib Tracker II for Linux - had decided to honor us with his OPL2 knowledge while on the way out. He advised us to keep the OPL2 sound chip on the Steckschwein, because the OPL2 chip is still not outbid.</description><content>&lt;p>VCF 2018 in Berlin was great! We&amp;rsquo;ve met interesting people there. Got a handshake with Scot W. Stevenson who for(th)ced us to use his &lt;a href="https://github.com/scotws/TaliForth2">TaliForth2&lt;/a> ;)&lt;/p>
&lt;p>Later on Saturday &lt;a href="http://www.adlibtracker.net/downloads.php">Daniel Illgen&lt;/a> - maintainer of the Adlib Tracker II for Linux - had decided to honor us with his OPL2 knowledge while on the way out. He advised us to keep the OPL2 sound chip on the Steckschwein, because the OPL2 chip is still not outbid. We hat doubts at first, but then we could listen to OPL2 with so called &amp;ldquo;software low frequency oscillation&amp;rdquo; (soft lfo) and the drums and bass sounds great!&lt;/p>
&lt;p>Beside the VCF there where talks about demos and the history of the demoscene then and now. There where two interesting and awesome talks given by &amp;ldquo;&lt;a href="http://svolli.de/">SvOlli&lt;/a>&amp;rdquo; about the demoscene and demo coding on the Atari VCS (Stella).&lt;/p>
&lt;p>Here are the slides of out talks and Links to the livestream from Saturday 13.10.2018.&lt;/p>
&lt;ul>
&lt;li>Steckschwein - &lt;a href="https://steckschwein.files.wordpress.com/2018/10/the-history.pdf">The history and why it&amp;rsquo;s called &amp;ldquo;Steckschwin&amp;rdquo;&lt;/a>&lt;/li>
&lt;li>Steckschwein - &lt;a href="https://steckschwein.files.wordpress.com/2018/10/asm_tests_ci.pdf">6502 Test Driven Development and Continuous Integration&lt;/a>&lt;/li>
&lt;li>Livestream: &lt;a href="https://media.ccc.de/c/vcfb18">https://vcfb.de/2018/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Many thanks to &lt;a href="http://www.stefan-hoeltgen.de/">Dr. Stefan Höltgen&lt;/a> and his team arround the VCFB which made it possible that we could take a part on that cool event!&lt;/p></content></item><item><title>Save the date: VCFb - 13.10.-14.10.</title><link>https://beta.steckschwein.de/post/save-the-date-vcfb-13-10-14-10/</link><pubDate>Mon, 01 Oct 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/save-the-date-vcfb-13-10-14-10/</guid><description>We are very excited that we will be exhibiting the Steckschwein at the Vintage Computing Festival Berlin . Also, we will be holding a talk about everything Steckschwein on Saturday, the 13.10. at 10:30.
The Vintage Computing Festival Berlin will again be taking place at the &amp;ldquo;Deutsches Technikmuseum Berlin&amp;rdquo;, the German technical museum, which is a very interesting place to go by itself.
This is going to be good.</description><content>&lt;p>We are very excited that we will be exhibiting the Steckschwein at the &lt;a href="http://vcfb.de/2018/">Vintage Computing Festival Berlin&lt;/a> . Also, we will be holding a talk about everything Steckschwein on Saturday, the 13.10. at 10:30.&lt;/p>
&lt;p>The Vintage Computing Festival Berlin will again be taking place at the &amp;ldquo;Deutsches Technikmuseum Berlin&amp;rdquo;, the German technical museum, which is a very interesting place to go by itself.&lt;/p>
&lt;p>This is going to be good.&lt;/p></content></item><item><title>VCFe diesmal ohne Steckschwein</title><link>https://beta.steckschwein.de/post/vcfe-diesmal-ohne-steckschwein/</link><pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/vcfe-diesmal-ohne-steckschwein/</guid><description>Zum ersten Mal in der Geschichte des Steckschweins sind wir dieses Jahr nicht als Aussteller auf dem VCFe dabei.
Das Kommen lohnt sich aber trotzdem - diesmal findet das VCFe nämlich im Leibniz-Rechenzentrum der Bayerischen Akademie der Wissenschaften in Garching statt.</description><content>&lt;p>Zum ersten Mal in der Geschichte des Steckschweins sind wir dieses Jahr nicht als Aussteller auf dem &lt;a href="http://vcfe.org/D/">VCFe&lt;/a> dabei.&lt;/p>
&lt;p>Das Kommen lohnt sich aber trotzdem - diesmal findet das VCFe nämlich im &lt;a href="https://www.lrz.de/">Leibniz-Rechenzentrum&lt;/a> der Bayerischen Akademie der Wissenschaften in Garching statt.&lt;/p></content></item><item><title>Switching to english</title><link>https://beta.steckschwein.de/post/switching-to-english/</link><pubDate>Tue, 20 Mar 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/switching-to-english/</guid><description>There seems to be quite some interest in our little project from outside of germany. Thanks to all who are following what we are doing.
To save you the effort of putting our blatherings through Google Translate or even having to learn german, we decided switch to writing our blog articles in english.
The rest of the site will be translated as we go. The hardware page has already been translated.</description><content>&lt;p>There seems to be quite some interest in our little project from outside of germany. Thanks to all who are following what we are doing.&lt;/p>
&lt;p>To save you the effort of putting our blatherings through Google Translate or even having to learn german, we decided switch to writing our blog articles in english.&lt;/p>
&lt;p>The rest of the site will be translated as we go. &lt;a href="http://steckschwein.de/hardware/">The hardware page&lt;/a> has already been translated.&lt;/p></content></item><item><title>V9958 - Vom Steckbrett zum Prototypen</title><link>https://beta.steckschwein.de/post/v9958-vom-steckbrett-zum-prototypen/</link><pubDate>Thu, 01 Mar 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/v9958-vom-steckbrett-zum-prototypen/</guid><description>Es ist soweit, der erste Prototyp auf Platine von unserem neuen V9958-Videoboard ist fertig layoutet, und die Platinen warten beim Fertiger auf ihren Versand.
Der Steckbrettaufbau vom letzten Post wurde auf 128k erweitert. Dazu ist einfach eine 2. Bank von 2 Stück 64k x 4 DRAMS dazugebaut worden. Damit entspricht der Aufbau unserem Schaltplan, und dieser ist damit getestet.
Unsere Timing-Probleme führen wir auf zu kurze Delays bei Registerzugriffen, ein Softwareproblem also, zurück.</description><content>&lt;p>Es ist soweit, der erste Prototyp auf Platine von unserem neuen V9958-Videoboard ist fertig layoutet, und die Platinen warten beim Fertiger auf ihren Versand.&lt;/p>
&lt;p>Der Steckbrettaufbau vom &lt;a href="http://steckschwein.de/2017/12/09/es-wird-wieder-gesteckt/">letzten Post&lt;/a> wurde auf 128k erweitert. Dazu ist einfach eine 2. Bank von 2 Stück 64k x 4 DRAMS dazugebaut worden. Damit entspricht der Aufbau unserem Schaltplan, und dieser ist damit getestet.&lt;/p>
&lt;p>Unsere Timing-Probleme führen wir auf zu kurze Delays bei Registerzugriffen, ein Softwareproblem also, zurück. Das Businterface als solches ist durchaus sauber, und wir haben es genauso gelassen wie beim TMS9929. Einziger Unterschied ist, dass /CSW und /CSR nicht mehr mit einem 7400 erzeugt werden, sondern mit einem 74139. Damit sparen wir uns später einen IC, wenn wir aus dem Videoboard ein kombiniertes Video- und Soundboard machen, indem wir den OPL2-Chip noch dazupacken. Aber wir greifen vor.&lt;/p>
&lt;p>Das neue V9958-Board markiert auch eine Veränderung in unserer Vorgehensweise. Bislang haben wir Neuerungen immer komplett ausdesigned auf dem Steckbrett aufgebaut, und erst ganz am Schluss Platinen fertigen lassen, haben wir hier bewusst erst nur die Basisversion layoutet und direkt als Platinen fertigen lassen. Die günstigen Preise der diversen Platinenfertiger machens möglich, und wir verbringen weniger Zeit mit nervtötenden, wackligen Steckbrettaufbauten, und können uns auch langwierige und fehlerträchtige Aufbauten auf Lochrasterplatine sparen. Als angenehmen Nebeneffekt haben wir zwingend einen Schaltplan für jeden Schritt erstellt und haben somit alles lückenlos dokumentiert. Wir rechnen mit noch mindestens 2 Revisionen des Boards. Nämlich eine Reduktion der DRAM-Bestückung auf einen einzigen 16bit-Baustein, und zum Schluss Hinzufügen des Soundchips, sodass das Steckschwein in Zukunft nur noch aus 3 Platinen besteht. Jedenfalls bis wir uns dann an den Einplatiner wagen.&lt;/p>
&lt;p>&lt;img src="images/img_3308.jpg" alt="IMG_3308"> Der Steckbrettaufbau mit 128k. Für das Bild im Hintergrund werden trotzdem nur 16k verwendet.&lt;/p>
&lt;p>&lt;img src="images/photo_2018-03-01_18-53-11.jpg" alt="photo_2018-03-01_18-53-11"> 3D-Rendering der neuen Platine&lt;/p></content></item><item><title>Meltdown / Spectre</title><link>https://beta.steckschwein.de/post/meltdown-spectre/</link><pubDate>Fri, 05 Jan 2018 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/meltdown-spectre/</guid><description>Aufgrund der verwendeten überlegenen Prozessortechnologie ist das Steckschwein nicht von den aktuellen Prozessor-Sicherheitslücken Meltdown bzw. Spectre betroffen.</description><content>&lt;p>Aufgrund der verwendeten überlegenen Prozessortechnologie ist das Steckschwein nicht von den aktuellen Prozessor-Sicherheitslücken Meltdown bzw. Spectre betroffen.&lt;/p></content></item><item><title>Es wird wieder gesteckt</title><link>https://beta.steckschwein.de/post/es-wird-wieder-gesteckt/</link><pubDate>Sat, 09 Dec 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/es-wird-wieder-gesteckt/</guid><description>Wir haben uns schon länger ein Upgrade des Videochips des Steckschweins vorgenommen. Der TMS9929 ist ein netter Chip, aber an einem 8MHz-65c02, der dazu noch so coole Hardware-Features hat, fühlt er sich ein bisschen wie die Achillesferse an.
Zum Glück war beim TMS9929 nicht Schluss, denn dieser hat im Laufe der Zeit diverse Nachfolger bekommen, welche von Yamaha hergestellt wurden und in diversen Weiterentwicklungen des MSX-Standards Verwendung fanden.
Der direkte Nachfolger der TMS99xx-Reihe ist der V9938.</description><content>&lt;p>Wir haben uns schon länger ein Upgrade des Videochips des Steckschweins vorgenommen. Der TMS9929 ist ein netter Chip, aber an einem 8MHz-65c02, der dazu noch so coole Hardware-Features hat, fühlt er sich ein bisschen wie die Achillesferse an.&lt;/p>
&lt;p>Zum Glück war beim TMS9929 nicht Schluss, denn dieser hat im Laufe der Zeit diverse Nachfolger bekommen, welche von Yamaha hergestellt wurden und in diversen Weiterentwicklungen des MSX-Standards Verwendung fanden.&lt;/p>
&lt;p>Der direkte Nachfolger der TMS99xx-Reihe ist der &lt;a href="https://en.wikipedia.org/wiki/Yamaha_V9938">V9938&lt;/a>. Dieser kam 1984 raus, also ganze 7 Jahre nachdem der TMS9918/9929 erschienen ist, und hat dementsprechend auch einiges mehr drauf, z.B.:&lt;/p>
&lt;ul>
&lt;li>ein 80x24 Zeichen-Textmodus&lt;/li>
&lt;li>maximale Auflösung von 512 × 212 (16 Farben von 512)&lt;/li>
&lt;li>32 Sprites, davon max. 8 auf einer Rasterzeile&lt;/li>
&lt;li>Hardwarebeschleunigtes Füllen, Linien ziehen, etc.&lt;/li>
&lt;li>Vertikales Scrollregister&lt;/li>
&lt;/ul>
&lt;p>Der Nachfolger des V9938 wiederum ist der &lt;a href="https://en.wikipedia.org/wiki/Yamaha_V9958">V9958&lt;/a> von 1988. Dieser hat gegenüber dem Vorgänger nur einige kleine Verbesserungen erhalten, und zwar unter anderem:&lt;/p>
&lt;ul>
&lt;li>Horizontales Scrollregister&lt;/li>
&lt;li>Hardwarebeschleunigtes Füllen, Linien ziehen, etc. auch in nicht-bitmap-Modi&lt;/li>
&lt;/ul>
&lt;p>Beide Chips können bis zu 192k DRAM adressieren, und zwar max. 128k Video-RAM + 64k Extended RAM. Es werden DRAMs in den Formaten 16Kx1b, 16Kx4b, 64Kx1b und 64Kx4b unterstützt.&lt;/p>
&lt;p>&lt;img src="images/img_3129-e1512817894665.jpg" alt="img_3129.jpg">&lt;/p>
&lt;p>Unser Testaufbau &amp;ldquo;begnügt&amp;rdquo; sich mit 2x 64Kx4b und damit insgesamt 64Kb Video RAM (der TMS9929 kann nur max. 16K). Verglichen mit dem TMS9929 funktioniert das DRAM-Interface des V9958 selbst auf dem Steckbrett so stabil, dass wir auf irgendwelche SRAM-basierten Lösungen verzichten können. Auch der weitere Aufbau ist eher übersichtlich. Da der V9958 direkt RGB liefert, ist keine aufwendige Aufbereitung des Videosignals nötig. Als Ausgangsstufe wird ein Sony CXA2075M eingesetzt, der nebenher auch S-Video und Composite erzeugt. Damit dürfte sich künftig die Zahl der Steckschwein-geeigneten Fernseher/Monitore drastisch erhöhen.&lt;/p>
&lt;p>Jetzt bleiben noch einige Detailfragen des Businterface zu klären. Wie &lt;a href="http://lc64.blogspot.de/2015/04/v9938-with-rgb-output.html">MrFossi1&lt;/a> schon festgestellt hat, lassen sich Datentransfers ins Videoram nicht mehr in hoher Geschwindigkeit durchführen, während der Videochip im Blank ist oder das Display deaktiviert. Beim TMS9929 war das möglich.&lt;/p>
&lt;p>Der V9958 hingegen verfügt allerdings über einen ominösen /WAIT-Pin, dessen Funktion allerdings erst per Software aktiviert werden muss. Das Datenblatt erwähnt die Wait-Funktion nur kurz als Möglichkeit, Zugriffe aufs VRAM zu beschleunigen, schweigt sich dann aber aus. Hier gilt es zu forschen.&lt;/p></content></item><item><title>Neue Hardware - die Platinen sind da</title><link>https://beta.steckschwein.de/post/neue-hardware-die-platinen-sind-da/</link><pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/neue-hardware-die-platinen-sind-da/</guid><description>Die neuen IO-Platinen mit integriertem UART sind fertig und haben ihren Weg von China nach München gefunden.
Mit dem neuen Layout hat es nicht nur der UART mit aufs IO-Board geschafft, es sind auch etliche kleinere und größere Verbesserungen eingeflossen:
Die Joystickports wurden komplett neu designed. Die Optokoppler sparen wir uns, stattdessen wählen wir über einen VIA Pin verschiedene Treiber an, die den gewünschten Joystickport mit VIA Port A verbindet. Die Ports lassen sich auch per Software komplett abschalten, damit der User-Port frei verfügbar ist.</description><content>&lt;p>Die neuen IO-Platinen mit integriertem UART sind fertig und haben ihren Weg von China nach München gefunden.&lt;/p>
&lt;p>Mit dem neuen Layout hat es nicht nur der UART mit aufs IO-Board geschafft, es sind auch etliche kleinere und größere Verbesserungen eingeflossen:&lt;/p>
&lt;ul>
&lt;li>Die Joystickports wurden komplett neu designed. Die Optokoppler sparen wir uns, stattdessen wählen wir über einen VIA Pin verschiedene Treiber an, die den gewünschten Joystickport mit VIA Port A verbindet. Die Ports lassen sich auch per Software komplett abschalten, damit der User-Port frei verfügbar ist. Als Schutz für die VIA werden Serienwiderstände verwendet.&lt;/li>
&lt;li>Der SD-Karten-Footprint und der verwendente Slot passen genau zusammen. Das war beim alten Board nicht der Fall. Jetzt sind die Karten- und die Schreibschutzerkennung endlich nutzbar.&lt;/li>
&lt;li>Die Datenpins für die PS/2 Schnittstelle am ATmega8 sind gewandert und liegen jetzt an PD6 und 7. Dadurch sind die RX und TX Pins des USART verfügbar geworden und können nun z.B. für das Debugging des Tastaturcontrollers verwendet werden.&lt;/li>
&lt;li>Zweckmäßigere Plazierung vom SPI-Anschluss des ATmega8 und des freien SPI Ports am Platinenrand. Updates der Tastaturcontrollerfirmware sind nun kein Krampf mehr.&lt;/li>
&lt;li>Der User-Port hat ein besseres Pinout.&lt;/li>
&lt;li>Die neue Platine sieht einfach besser aus.
&lt;img src="images/img_3091.jpg" alt="IMG_3091"> Frisch ausgepackte Platine&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="images/img_3092.jpg" alt="IMG_3092"> Fertig bestückte Platine
&lt;img src="images/img_3093.jpg" alt="IMG_3093"> Die nun obsolet gewordenen Platinen.&lt;/p></content></item><item><title>Mal wieder neue Hardware</title><link>https://beta.steckschwein.de/post/mal-wieder-neue-hardware/</link><pubDate>Wed, 22 Nov 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/mal-wieder-neue-hardware/</guid><description>Die Zeit ist reif für ein Hardware-Update, und zwar für die IO-Platine 2.0. Vorgesehen war ja schon länger, den UART dort zu integrieren. Ausserdem war das Joystick&amp;ndash;Interface noch unausgegoren, sodass auch hier etwas Neues entwickelt wurde.
Zum Schutz der VIA-Pins dienen nun keine Optokoppler, sondern simple Serienwiderstände sollen die Ports zumindest vor dem Fall schützen, dass man doch mal die Datenrichtung der Joystick-Pins auf Ausgang schaltet und dann die VIA grillt indem man den Joystick betätigt.</description><content>&lt;p>Die Zeit ist reif für ein Hardware-Update, und zwar für die IO-Platine 2.0. Vorgesehen war ja schon länger, den UART dort zu integrieren. Ausserdem war das Joystick&amp;ndash;Interface noch unausgegoren, sodass auch hier etwas Neues entwickelt wurde.&lt;/p>
&lt;p>Zum Schutz der VIA-Pins dienen nun keine Optokoppler, sondern simple Serienwiderstände sollen die Ports zumindest vor dem Fall schützen, dass man doch mal die Datenrichtung der Joystick-Pins auf Ausgang schaltet und dann die VIA grillt indem man den Joystick betätigt. Die Widerstände begrenzen den Strom auf 1mA. Das muss die VIA abkönnen. Zudem war im vorigen Design der Userport nicht wirklich nutzbar, weil immer noch die Joysticks daran hingen. Jetzt ist es so, dass jeder Joystick über Tri State Buffer an VIA Port A verbunden wird, und zwar grundsätzlich wahlweise. Ausserdem besteht die Möglichkeit, die Joyports komplett abzuschalten. Dies wird mit dem OUT1-Pin des UART bewerkstelligt. Somit läßt sich per Software konfigurieren, ob man Userport oder Joystick benutzen möchte.&lt;/p>
&lt;p>Der User-Port hat ein neues, von &lt;a href="http://neil.franklin.ch/">Neil Franklin&lt;/a> vorgeschlagenes Pinout, in dem nun auch die /RESET und /IRQ-Leitungen vorhanden sind. Auch am Tastaturcontroller hat sich eine Kleinigkeit geändert, die Datenpins für den PS/2 Port sind nach PD6 bzw. PD7 gewandert. Somit sind die RX/TX-Pins des AVR USART wieder frei und bereit für neue Schandtaten. Deswegen haben sie auch eine kleine Pinleiste spendiert bekommen.&lt;/p>
&lt;p>&lt;img src="images/io2_0.png" alt=""> 3D Rendering der neuen IO-Platine&lt;/p></content></item><item><title>Musik</title><link>https://beta.steckschwein.de/post/musik/</link><pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/musik/</guid><description>Das Programmieren von Soundchips ist nicht trivial. Das habe ich damals auf dem C64 schon nicht kapiert. Mit dem Yamaha YM3812 oder auch OPL2 hat das Steckschwein einen weit komplexeren Chip als den SID, denn OPL2 kennt gleich ganze 9 Stimmen statt drei, und jede ist über eine Unzahl Parameter konfigurierbar.
Wie funktioniert der YM3812? Wie kriegt man also einen Ton aus diesem Monstrum? Die beste Quelle zum Thema OPL2 ist wohl &amp;ldquo;Programming the AdLib/Sound Blaster FM Music Chips&amp;rdquo; von Jeffrey S.</description><content>&lt;p>Das Programmieren von Soundchips ist nicht trivial. Das habe ich damals auf dem C64 schon nicht kapiert. Mit dem Yamaha YM3812 oder auch OPL2 hat das Steckschwein einen weit komplexeren Chip als den SID, denn OPL2 kennt gleich ganze 9 Stimmen statt drei, und jede ist über eine Unzahl Parameter konfigurierbar.&lt;/p>
&lt;h2 id="wie-funktioniert-der-ym3812">Wie funktioniert der YM3812?&lt;/h2>
&lt;p>Wie kriegt man also einen Ton aus diesem Monstrum? Die beste Quelle zum Thema OPL2 ist wohl &amp;ldquo;&lt;a href="http://www.shipbrook.net/jeff/sb.html">Programming the AdLib/Sound Blaster FM Music Chips&lt;/a>&amp;rdquo; von Jeffrey S. Lee. Zumindest wird einem hier schnell klar, was auf einen zukommt, will man auch nur einen einfachen Ton ausgeben. So hat der OPL2-Chip insgesamt 244 Register, die neben den Stimmen auch die integrierten Timer konfigurieren, und belegt 2 Portadressen. Konkret bedeutet das, dass man in Adresse 1 die Nummer des gewünschen Registers schreibt. Nach 3.3µs liegt an Adresse 2 das gewählte Register zum Beschreiben an. Lesen läßt sich nur das Statusregister. Hat man also das gewählte Register beschrieben, ist der Chip dann 23µs nicht ansprechbar.&lt;/p>
&lt;p>Zunächst müssen wir also dafür sorgen, dass der Soundchip seine Daten mit dem richtigen Timing bekommt. Der Einfachheit halber machen wir das nicht über Timer, sondern mit NOPs. Die Länge der Nopslides zu berechnen, überlassen wir dem Assembler. Um Platz zu sparen, nutzen wir eine Nopslide mit zwei Einsprüngen.&lt;/p>
&lt;p>opl2_data_delay_time = 25000
opl2_reg_delay_time = 5000&lt;/p>
&lt;p>opl2_data_delay = ((opl2_data_delay_time - opl2_reg_delay_time) / (1000/clockspeed)) / 2 -12
opl2_reg_delay = (opl2_reg_delay_time / (1000/clockspeed)) / 2 -12&lt;/p>
&lt;p>Und die entsprechenden Subroutinen. Die je 6 Zyklen für JSR und RTS sind ja oben schon abgezogen:&lt;/p>
&lt;p>opl2_delay_data: ; 23000ns / 0
.repeat opl2_data_delay
nop
.endrepeat&lt;/p>
&lt;p>opl2_delay_register: ; 3300 ns
.repeat opl2_reg_delay
nop
.endrepeat
rts&lt;/p>
&lt;p>Das wäre also geklärt.&lt;/p>
&lt;h2 id="futter-für-den-soundchip">Futter für den Soundchip&lt;/h2>
&lt;p>Nachdem also schonmal klar ist, auf welch umständliche Weise der Chip mit Daten betankt werden will, bleibt nur noch die Frage: Betanken womit? FM-Synthese ist ein zu weites Feld, als dass wir dort jetzt tief einsteigen wollen. Viel naheliegender wäre ein Player für eingängige Musikfiles. Erste &lt;a href="http://steckschwein.de/2015/01/04/das-schwein-kann-singen/">Experimente von Marko mit den von DosBox erzeugten DRO Files&lt;/a> waren schon recht vielversprechend. Leider ist es etwas umständlich, mit DosBox neue Musikstücke zu konvertieren, und auch die Trefferquote für lauffähige Stücke ist nicht besonders hoch. Zudem ist der von uns verwendete Player ein ziemlicher Hack mit per NOP grob hingefummelten Timings. Dieser war ursprünglich mal für ein OPL2-Modul für den C64 geschrieben worden. Was es nicht alles gibt. MIDI-Files wollen wir uns auch noch nicht antun, weil wir hier eine Umsetzung der verwendeten MIDI-Instrumente in OPL2-Parameter hätten bauen müssen. Ideal wäre ein Dateiformat, das die OPL2-Registerwerte bereits enthält.&lt;/p>
&lt;p>Zum Glück hat sich damals id-Software zu Zeiten der Commander Keen-Spiele etwas entsprechendes ausgedacht: Das &lt;a href="http://www.shikadi.net/moddingwiki/IMF_Format">IMF-Format&lt;/a>. Dieses Format wurde für eine Reihe früher id-Software-Spiele und deren Ableger verwendet, von Commander Keen 4-6 über Duke Nukem II bis hin zu Wolfenstein 3D. Dementsprechend groß ist die Anzahl der verfügbaren Musikstücke.&lt;/p>
&lt;p>IMF-Dateien sind äußerst simpel aufgebaut, jede Datei ist im Prinzip eine Abfolge von 4byte-Paketen, die Registernummer, Registerwert und die Dauer der Pause bis zum nächsten Wert enthalten:&lt;/p>
&lt;p>Register (8bit) | Wert (8bit) | Pause (16bit)&lt;/p>
&lt;p>Die &amp;ldquo;Pause&amp;rdquo; ist in &amp;ldquo;Ticks&amp;rdquo; angegeben, welche sich auf die Abspielfrequenz des jeweiligen Stückes bezieht. Diese ist meist entweder 560Hz oder 700Hz. Hier kommt dann ein Timer-Interrupt zum Einsatz, der 560 oder 700mal in der Sekunde ausgeführt wird. Hierzu verwenden wir Timer 1 des 6522 VIA. Der OPL2 Chip hat zwar auch Timer, aber diese basieren auf festen Intervallen von 80µs bzw 320µs, was in unserem Fall nicht so richtig aufgeht.&lt;/p>
&lt;p>Der Plan ist folgender: Das IMF-File wird komplett in den Speicher geladen. Dann positionieren wir einen Zeiger auf den Anfang der im Speicher befindlichen Daten.&lt;/p>
&lt;p>In der Zeropage benutzen wir 2 Bytes als unseren Delay-Zähler. Diesen setzen wir inital auf 0. In der Interrupt-Routine prüfen wir als erstes, ob der Delay-Zähler 0 ist. Wenn nicht, dekrementieren wir ihn und verlassen die Routine wieder. Ist der Zähler 0, setzen wir das Datenbyte aus unseren IMF-Daten in das vorgesehene Register. Dann rücken wir den Datenzeiger um 4 Bytes weiter, setzen den Delay-Zähler neu, und verlassen den Interrupt.&lt;/p>
&lt;p>player_isr:
pha
phy&lt;/p>
&lt;p>bit via1ifr ; Interrupt from VIA?
bpl @isr_end&lt;/p>
&lt;p>bit via1t1cl ; Acknowledge timer interrupt by reading channel low&lt;/p>
&lt;p>; delay counter zero?
lda delayh
clc
adc delayl
beq @l1&lt;/p>
&lt;p>; if no, 16bit decrement and exit routine
dec16 delayh&lt;/p>
&lt;p>bra @isr_end
@l1:&lt;/p>
&lt;p>ldy #$00
lda (imf_ptr),y
sta opl_stat&lt;/p>
&lt;p>iny
lda (imf_ptr),y&lt;/p>
&lt;p>jsr opl2_delay_register&lt;/p>
&lt;p>sta opl_data&lt;/p>
&lt;p>iny
lda (imf_ptr),y
sta delayh&lt;/p>
&lt;p>iny
lda (imf_ptr),y
sta delayl&lt;/p>
&lt;p>; song data end reached? then set state to 80 so loop will terminate
lda imf_ptr_h
cmp imf_end+1
bne @l3
lda imf_ptr
cmp imf_end+0
bne @l3&lt;/p>
&lt;p>lda #$80
sta state&lt;/p>
&lt;p>bra @isr_end
@l3:&lt;/p>
&lt;p>;advance pointer by 4 bytes
clc
lda #$04
adc imf_ptr
sta imf_ptr
bcc @isr_end
inc imf_ptr_h
@isr_end:
; jump to kernel isr
ply
pla
jmp (old_isr)&lt;/p>
&lt;p>&lt;a href="https://bitbucket.org/steckschwein/steckschwein-code/src/074d9f378daeedeb45166a346cafd39907be22c9/imfplayer/?at=default">Der vollständige Player&lt;/a> ist in unserem &lt;a href="https://bitbucket.org/steckschwein/steckschwein-code">Bitbucket-Repository&lt;/a> zu finden. Wir gehen jetzt den Wolfenstein 3D-Soundtrack hören.&lt;/p></content></item><item><title>Logikanalyse II [UPDATE]</title><link>https://beta.steckschwein.de/post/logikanalyse-ii/</link><pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/logikanalyse-ii/</guid><description>Inzwischen sind die 74F00 eingetroffen und der 74HCT00 durch einen ebensolchen ersetzt. Das Oszilloskopbild sieht gleich deutlich besser aus:
gelb: /WE, blau: A9
Der Schreibvorgang wird also jetzt zumindest abgeschlossen, bevor sich die Adresse auf dem Adressbus ändert. Das ist schonmal viel sauberer.
Nur leider hat es das Problem nicht gelöst, das Steckschwein läuft mit den &amp;ldquo;richtigen&amp;rdquo; RAMs immer noch instabil, was sich insbesondere bei BASIC-Programmen bemerkbar macht:
Wäre auch zu einfach gewesen.</description><content>&lt;p>Inzwischen sind die 74F00 eingetroffen und der 74HCT00 durch einen ebensolchen ersetzt. Das Oszilloskopbild sieht gleich deutlich besser aus:&lt;/p>
&lt;p>&lt;img src="images/tekway449_3.gif" alt=""> gelb: /WE, blau: A9&lt;/p>
&lt;p>Der Schreibvorgang wird also jetzt zumindest abgeschlossen, bevor sich die Adresse auf dem Adressbus ändert. Das ist schonmal viel sauberer.&lt;/p>
&lt;p>Nur leider hat es das Problem nicht gelöst, das Steckschwein läuft mit den &amp;ldquo;richtigen&amp;rdquo; RAMs immer noch instabil, was sich insbesondere bei BASIC-Programmen bemerkbar macht:&lt;/p>
&lt;p>&lt;img src="images/photo_2017-05-04_19-56-29.jpg" alt="photo_2017-05-04_19-56-29">&lt;/p>
&lt;p>Wäre auch zu einfach gewesen.&lt;/p>
&lt;p>&lt;strong>[UPDATE]&lt;/strong> Ein weiterer Test mit anderen 55ns-SRAMs, nämlich Bausteinen von BSI im TSOP28-Gehäuse auf DIP28-Adaptern, lief problemlos durch. Das BASIC-Programm, mit dem wir testen, lief 2 Tage problemlos durch. Dies ist insofern bemerkenswert, als dass das Steckschwein mit diesen Bausteinen vorher überhaupt nicht lief. Also doch ein Erfolg. Warum die 55ns-Chips von Alliance Memory Probleme machen, müssen wir noch untersuchen.&lt;/p>
&lt;p>&lt;img src="images/photo_2017-05-06_19-57-10.jpg" alt=""> TSOP28-SRAMs auf DIP28 Adapter&lt;/p></content></item><item><title>VCFe 18.0 - ein Resümee</title><link>https://beta.steckschwein.de/post/vcfe-18-0-ein-resuemee/</link><pubDate>Tue, 02 May 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/vcfe-18-0-ein-resuemee/</guid><description>Kein VCFe ohne einen resümmierenden Post-VCFe-Post von uns.
Vorweg: Der neue Veranstaltungsort im Kulturzentrum Trudering ist hervorragend. Eine moderne Veranstaltungshalle, mehr Platz als in der alten ESV-Turnhalle, großzügiger Foyerbereich und ein deutlich größerer Vortragsraum. Die Nahrungsversorgung bestreitet im Kulturzentrum Trudering das integrierte indische Restaurant &amp;ldquo;Taj&amp;rdquo;, welches ebenso überzeugen konnte. Alles in allem ein großer Gewinn und allen Anzeichen nach wird das nächste VCFe auch wieder dort stattfinden.
Das Steckschwein auf dem VCFe 18.</description><content>&lt;p>Kein VCFe ohne einen resümmierenden Post-VCFe-Post von uns.&lt;/p>
&lt;p>Vorweg: Der neue Veranstaltungsort im Kulturzentrum Trudering ist hervorragend. Eine moderne Veranstaltungshalle, mehr Platz als in der alten ESV-Turnhalle, großzügiger Foyerbereich und ein deutlich größerer Vortragsraum. Die Nahrungsversorgung bestreitet im Kulturzentrum Trudering das integrierte indische Restaurant &amp;ldquo;Taj&amp;rdquo;, welches ebenso überzeugen konnte. Alles in allem ein großer Gewinn und allen Anzeichen nach wird das nächste VCFe auch wieder dort stattfinden.&lt;/p>
&lt;p>&lt;img src="images/223033882_14372495918269115578.jpg" alt=""> Das Steckschwein auf dem VCFe 18.0&lt;/p>
&lt;p>Auch das Interesse am Steckschwein erstaunt und erfreut immer wieder. Dieses Jahr ging es in erster Linie darum, mit EhBasic ein lauffähiges BASIC auf dem Steckschwein nebst einiger Beispielprogramme aus  &amp;ldquo;101 BASIC Computer Games&amp;rdquo; zu zeigen. Weiterhin haben wir mit Unterstützung von Carsten Strotmann versucht, VolksForth auf dem Steckschwein zum Laufen zu kriegen, um endlich mal am Ultimate Benchmark teilnehmen zu können. Leider hat sich das Steckschwein hier auch als stark Forth-resistent erwiesen, wie das auch schon bei unseren Versuchen mit FIG-Forth der Fall war. Aber wir bleiben dran.&lt;/p>
&lt;p>Die Herren mit den Arcade-Automaten indessen haben merklich gefehlt. Für jüngeres Publikum gab es so nur wenig Daddelmöglichkeiten, weswegen das Steckschwein zeitweilig als Zockmaschine aushelfen durfte.&lt;/p>
&lt;p>Alles in allem ist eine tolle Veranstaltung in einer neuen tollen Halle noch toller geworden und wir freuen uns aufs VCFe 19.0.&lt;/p></content></item><item><title>Logikanalyse</title><link>https://beta.steckschwein.de/post/logikanalyse/</link><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/logikanalyse/</guid><description>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.
Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.
Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2.</description><content>&lt;p>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.&lt;/p>
&lt;p>&lt;img src="images/logic_analyzer.jpg" alt=""> Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.&lt;/p>
&lt;p>Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2. Takthälfte für Buszugriffe nutzt. Diese ist nur 62,5ns lang. Von dieser Zeit geht ausserdem noch die Durchlaufzeit der Adressdekodierung und weiterer Glue-Logik ab. Eigens angeschaffte neue SRAMs von Alliance Memory mit 55ns Zugriffszeit sollten also ganz knapp schnell genug sein. Trotzdem treten mit diesen immer wieder merkwürdig zufällige Abstürze auf, die 100ns-Chips laufen dagegen problemlos.&lt;/p>
&lt;p>Also ran an die Maschine. Hierbei zeigte sich auch schon schnell etwas Merkwürdiges:&lt;/p>
&lt;p>&lt;img src="images/we_addr.png" alt=""> Analyse von Adress- und Datenbus sowie Steuersignale&lt;/p>
&lt;p>Es fiel etwas unangenehm auf, dass die steigende Flanke von /WE (Ende des Schreibzugriffs) direkt mit der Änderung des Adressbus zusammenfällt. Idealerweise sollte der Schreibzugriff beendet sein, bevor am Adressbus eine andere Adresse anliegt. Das Datenblatt nennt die Zeitspanne zwischen der steigenden Flanke von /WE und einer Änderung auf dem Adressbus tWR (Write Recovery Time):&lt;/p>
&lt;p>&lt;img src="images/sram_timing.png" alt="sram_timing">&lt;/p>
&lt;p>Laut Diagramm soll also /WE high werden, &lt;strong>bevor&lt;/strong> sich der Adressbus ändert. Im Datenblatt selbst ist die Write Recovery Time mit 0ns angegeben, und zwar bei beiden SRAMs, die 100ns-Typen sowie bei den 55ns-Bausteinen. Das würde bedeutet, dass die steigende Flanke von /WE mit einer Änderung der Adresse zeitlich zusammenfallen darf. Der verwendete Logicanalyzer hat eine Auflösung von 10ns, sodass man eigentlich nur sagen kann, dass sich /WE und der Adressbus im selben Zeitraum von 10ns ändern. Also schauen wir uns /WE und eine zufällige Adressleitung nochmal unterm Oszilloskop an.&lt;/p>
&lt;p>&lt;img src="images/oszi.jpg" alt=""> /WE und A9 unterm Oszilloskop. Gelb: /WE, Blau: A9&lt;/p>
&lt;p>Offenbar ändert sich der Adressbus, &lt;strong>bevor&lt;/strong> mit der steigenden Flanke von /WE der Schreibzugriff endet! Einen ausreichend schnellen Chip vorausgesetzt, könnte der anliegende Schreibzugriff womöglich in die neue Adresse hereingeschleppt werden. Wie dem auch sei, auf jeden Fall etwas, das so nicht sein darf! Wir halten die 0ns Write Recovery Time nicht ein, indem wir sie um ca. 4ns unterschreiten.&lt;/p>
&lt;p>/OE und /WE für die RAMs wird bei uns durch 3 NAND-Gatter in einem 74HCT00 aus der r/W-Leitung und dem Systemtakt erzeugt. Ein 74HCT00 hat eine Durchlaufzeit von ca. 9ns. Als nächstes werden wir also stattdessen einen 74F00 verwenden, der uns mit 3.7ns Durchlaufzeit wieder in den Bereich tWR &amp;gt; 0ns bringen sollte. Sollte es das nicht bringen, werden wir uns etwas grundsätzlichere Gedanken machen müssen.&lt;/p></content></item><item><title>Das VCFe 18.0 steht vor der Tür</title><link>https://beta.steckschwein.de/post/das-vcfe-18-0-steht-vor-der-tuer/</link><pubDate>Wed, 19 Apr 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/das-vcfe-18-0-steht-vor-der-tuer/</guid><description>Am 29.04.2017 ist es wieder so weit, das Vintage Computer Festival Europe vereint in München wieder für 3 Tage Freunde historischer Computer.
Was sich geändert hat, ist der Veranstaltungsort, denn die altehrwürdige Turnhalle des E.S.V. München-Ost ist vergangenes Jahr abgerissen worden:
Kulturzentrum Trudering Wasserburger Landstraße 32 81825 München
Was sich nicht geändert hat, ist, dass das Steckschwein wieder mit dabei sein wird. Diesmal mit lauffähigem EhBASIC und einigen klassischen Beispielen.</description><content>&lt;p>&lt;img src="images/vcflogo.gif" alt="vcflogo">&lt;/p>
&lt;p>Am 29.04.2017 ist es wieder so weit, das &lt;a href="http://vcfe.org/">Vintage Computer Festival Europe&lt;/a> vereint in München wieder für 3 Tage Freunde historischer Computer.&lt;/p>
&lt;p>Was sich geändert hat, ist der Veranstaltungsort, denn die altehrwürdige Turnhalle des E.S.V. München-Ost ist vergangenes Jahr abgerissen worden:&lt;/p>
&lt;p>&lt;strong>Kulturzentrum Trudering Wasserburger Landstraße 32 81825 München&lt;/strong>&lt;/p>
&lt;p>Was sich nicht geändert hat, ist, dass das Steckschwein wieder mit dabei sein wird. Diesmal mit lauffähigem EhBASIC und einigen klassischen Beispielen.&lt;/p>
&lt;p>Wir freuen uns.&lt;/p></content></item><item><title>LOAD / SAVE in EhBasic</title><link>https://beta.steckschwein.de/post/load-save-in-ehbasic/</link><pubDate>Tue, 28 Feb 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/load-save-in-ehbasic/</guid><description>Nachdem EhBasic brauchbar auf unserem SteckOS-Kernel läuft, fehlen noch 2 Kleinigkeiten für das vollkommene Glück. Denn noch lassen sich die geschriebenen BASIC-Kunstwerke nicht speichern. Dies stellt uns gleich vor 2 Herausforderungen:
Unsere FAT32-Implementierung beherrscht noch gar keinen Schreibzugriff. Genauer gesagt ist es noch nicht möglich, freie Cluster zu finden und Verzeichniseinträge zu erzeugen. LOAD und SAVE existieren in EhBasic nur als Vektoren, an die bei Aufruf gesprungen wird. Was dort passieren soll, muss für die jeweilige Hardware selbst implementiert werden.</description><content>&lt;p>Nachdem EhBasic brauchbar auf unserem SteckOS-Kernel läuft, fehlen noch 2 Kleinigkeiten für das vollkommene Glück. Denn noch lassen sich die geschriebenen BASIC-Kunstwerke nicht speichern. Dies stellt uns gleich vor 2 Herausforderungen:&lt;/p>
&lt;ol>
&lt;li>Unsere FAT32-Implementierung beherrscht noch gar keinen Schreibzugriff. Genauer gesagt ist es noch nicht möglich, freie Cluster zu finden und Verzeichniseinträge zu erzeugen.&lt;/li>
&lt;li>LOAD und SAVE existieren in EhBasic nur als Vektoren, an die bei Aufruf gesprungen wird. Was dort passieren soll, muss für die jeweilige Hardware selbst implementiert werden.&lt;/li>
&lt;/ol>
&lt;p>Fangen wir also ganz vorne an. Neue Dateien anlegen können wir noch nicht, da wir noch keine Operationen auf der FAT unterstützen, also auch keine freien Cluster finden können. Der Kunstgriff hier ist, diese Aufgaben von einem System erledigen zu lassen, das das schon kann. Dementsprechend werden einfach auf einem PC der Wahl auf der Karte Dateien FILE0000.DAT bis FILE0009.DAT angelegt. Diese sollen dann als unsere &amp;ldquo;Schreib-Slots&amp;rdquo; dienen. Vorhandene Dateien zu überschreiben und die Dateigröße im Directory mit der neuen Größe zu überschreiben, ist kein großes Problem.&lt;/p>
&lt;p>Um nun LOAD und SAVE in EhBasic implementieren zu können, brauchen wir zunächst Antworten auf folgende Fragen:&lt;/p>
&lt;ol>
&lt;li>In welchem Speicherbereich liegt mein Programm, das ich speichern will?&lt;/li>
&lt;li>Wie teile ich EhBasic mit, wo mein geladenes Programm im Speicher endet?&lt;/li>
&lt;li>Wie gebe ich LOAD und SAVE einen Dateinamen als Parameter mit?&lt;/li>
&lt;/ol>
&lt;p>Der Reihe nach. Die ersten beiden Fragen sind relativ klar im EhBasic-Forum auf 6502.org beantwortet. Der xxxx leider verstorbene EhBasic-Autor Lee Davison hat im &lt;a href="http://forum.6502.org/viewtopic.php?f=5&amp;amp;t=2198">entsprechenden Thread&lt;/a> die Antworten auf die Fragen 1 und 2 2012 gegeben:&lt;/p>
&lt;p>&amp;ldquo;If you want to save the program as binary you should save (Smeml) to (Svarl)-1.&amp;rdquo;&lt;/p>
&lt;p>Smeml/h ist ein Vektor, der auf die Startadresse für Basicprogramme zeigt. Direkt nach dem Basic-Programm folgt demnach der Variablenbereich, auf den Svarl/h zeigt. Dann ist ja alles ganz einfach. Wir setzen unseren write_block-Pointer auf dasselbe Ziel wie Smeml/h. Die Dateigröße errechnen sich aus Svarl-1 - Smeml.&lt;/p>
&lt;pre>&lt;code> lda Smemh
sta write\_blkptr + 1
lda Smeml
sta write\_blkptr + 0
sec
lda Svarl
sbc Smeml
sta fd\_area + F32\_fd::FileSize + 0,x
lda Svarh
sbc Smemh
sta fd\_area + F32\_fd::FileSize + 1,x
lda #$00
sta fd\_area + F32\_fd::FileSize + 2,x
sta fd\_area + F32\_fd::FileSize + 3,x
&lt;/code>&lt;/pre>
&lt;p>Das Laden gestaltet sich analog:&lt;/p>
&lt;p>&amp;ldquo;To load a binary program start loading it at (Smeml) and set (Svarl) to the last address + 1 then call LAB_1477 to clear the variables and reset the execution pointer. An easy way to do the first part is by copying (Smeml) to (Svarl) and using (Svarl) as a post incremented save pointer. If there is a chance that the program has been relocated it&amp;rsquo;s probably a good idea to rebuild the line pointer chain. &amp;quot;&lt;/p>
&lt;p>Wir setzen unseren read_block-Pointer also auf Smeml/h, laden die Datei, addieren die Dateigröße aus dem Filedeskriptor und setzen Svarl/h entsprechend.&lt;/p>
&lt;pre>&lt;code> lda Smemh
sta read\_blkptr + 1
lda Smeml
sta read\_blkptr + 0
jsr krn\_read
bne io\_error
clc
lda Smeml
adc fd\_area + F32\_fd::FileSize + 0,x
sta Svarl
lda Smemh
adc fd\_area + F32\_fd::FileSize + 1,x
sta Svarh
jsr krn\_close
bne io\_error
jsr krn\_primm
.byte &amp;quot;Ok&amp;quot;, $0a, $00
JMP LAB\_1319
&lt;/code>&lt;/pre>
&lt;p>Statt LAB_1477 springen wir nach LAB_1319. Hier wird implizit auch nach LAB_1477 gesprungen, aber noch wie oben erwähnt die line-pointer-chain neu aufgebaut. Damit sind wir flexibel, denn so können wir bereits gespeicherte Programme auch dann wieder laden und ausführen, falls sich unsere Basic-Start-Adresse einmal ändern sollte.&lt;/p>
&lt;p>Erste Versuche mit hart codiertem Dateinamen verlaufen vielversprechend. Jetzt möchten wir uns noch aussuchen können, welche Datei geladen oder in welche gespeichert werden soll. Wir müssen EhBasic beibiegen, nach LOAD noch ein Stringargument auszuwerten: LOAD &amp;ldquo;filename&amp;rdquo;&lt;/p>
&lt;p>To be continued&amp;hellip;&lt;/p></content></item><item><title>EhBASIC nochmal</title><link>https://beta.steckschwein.de/post/ehbasic-nochmal/</link><pubDate>Sun, 22 Jan 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/ehbasic-nochmal/</guid><description>Vor geraumer Zeit hatten wir ja bereits EhBASIC auf dem Steckschwein zum Laufen gebracht. Diese Version war im Wesentlichen eine Machbarkeitsstudie. Diese setzte auch noch nicht auf unseren SteckOS-Kernel auf, sondern auf BIOS-Routinen. Hier lag also noch ein wenig Arbeit vor uns.
Die EhBASIC-Dokumentation setzt bei einem potentiellen Portierungsziel nicht sehr viel voraus, und dies sind schon die &amp;ldquo;Preferred requirements&amp;rdquo;:
6502 or better processor (65c02, CCU3000, M38xx). 10k ROM or RAM for the interpreter code.</description><content>&lt;p>&lt;img src="images/img_2287.jpg" alt="img_2287">&lt;/p>
&lt;p>Vor geraumer Zeit hatten wir ja bereits EhBASIC auf dem Steckschwein zum Laufen gebracht. Diese Version war im Wesentlichen eine Machbarkeitsstudie. Diese setzte auch noch nicht auf unseren SteckOS-Kernel auf, sondern auf BIOS-Routinen. Hier lag also noch ein wenig Arbeit vor uns.&lt;/p>
&lt;p>Die EhBASIC-Dokumentation setzt bei einem potentiellen Portierungsziel nicht sehr viel voraus, und dies sind schon die &amp;ldquo;Preferred requirements&amp;rdquo;:&lt;/p>
&lt;ol>
&lt;li>6502 or better processor (65c02, CCU3000, M38xx).&lt;/li>
&lt;li>10k ROM or RAM for the interpreter code.&lt;/li>
&lt;li>RAM from $0000 to $BFFF (more with changes).&lt;/li>
&lt;li>Any character based I/O (e.g. RS232, LCD/keyboard etc).&lt;/li>
&lt;/ol>
&lt;p>Punkte 1 und 2 sind schnell abgehakt. Einen 65c02 hat das Steckschwein ja. 10k ROM haben wir nicht am Stück, jedoch wollen wir das Basic ja als Programm im RAM ausführen, und davon haben wir 64k. Alles klar.&lt;/p>
&lt;p>Die Punkte 3 und 4 erfordern jedoch ein paar kleine Anpassungen. RAM von $0000 bis $BFFF gibt es im Steckschwein nicht durchgehend, denn von $0200 bis $027F liegt ja der IO-Bereich. Hier gilt es also zunächst zu prüfen, ob EhBASIC zufällig in diesem Bereich irgendetwas tut. Im EhBASIC-eigenen Monitor min_mon wird zwar ein IO-Bereich angegeben, dieser wird jedoch in unserer Version nicht angesprochen, da wir zur Ein- und Ausgabe unserer SteckOS-Kernel-Routinen verwenden wollen.&lt;/p>
&lt;p>Jetzt müssen wir sicherstellen, dass sich der Basic-Start, also die Adresse, an der die eigentlichen Basic-Programme im Speicher liegen, mit nichts überschneidet. EhBASIC wird ja offenbar eher ROM-basiert  verwendet und liegt damit meist im oberen Adressbereich. Im Quellcode gibt es die Konstanten Ram_base und Ram_top. Hier gab es schon das erste Problem, dass Ram_top nicht größer sein konnte als die Startadresse des eigentlichen EhBASIC-Codes. Mit Hilfe der äußerst hilfreichen Community im Forum auf 6502.org konnten wir &amp;ldquo;unser&amp;rdquo; Basic aber patchen: &lt;a href="http://forum.6502.org/viewtopic.php?p=48368#p48368">http://forum.6502.org/viewtopic.php?p=48368#p48368&lt;/a>&lt;/p>
&lt;p>EhBASIC benötigt außerdem eine Routine zur Zeicheneingabe. Laut Dokumentation:&lt;/p>
&lt;blockquote>
&lt;p>This is a non halting scan of the input device. If a character is ready it should be placed in A and the carry flag set, if there is no character then A, and the carry flag, should be cleared.&lt;/p>
&lt;/blockquote>
&lt;p>Einen non-halting Scan der Tastatur haben wir schon, die Routine &amp;ldquo;krn_getkey&amp;rdquo;. Die geforderte Mimik mit dem Carry Flag haben wir dort noch eingebaut und nutzen diese auch selbst in krn_keyin. So kann krn_getkey direkt in EhBasic verwendet werden.&lt;/p>
&lt;p>Auch unsere krn_chrout-Routine können wir direkt in EhBasic nutzen.&lt;/p>
&lt;p>Damit haben wir endlich ein lauffähiges Basic auf unserem Steckschwein!&lt;/p>
&lt;p>Relativ schnell fiel allerdings etwas störend ins Gewicht, dass der Tokenizer von EhBasic die Eingabe von BASIC-Schlüsselwörtern in Großbuchstaben erwartet, was auf Dauer etwas anstrengend ist. Das Steckschwein, unterstützt bekanntlich Groß- und Kleinschreibung mit Kleinschreibung als Default.&lt;/p>
&lt;p>Es wäre doch nett, wenn der Tokenizer beides akzeptieren würde. Dies würde ja nichtmal die Ausführungsgeschwindigkeit negativ beeinträchtigen, da nur für das Parsen ein weiterer Schritt nötig wäre.&lt;/p>
&lt;p>Ganz so trivial wie angenommen war der Patch dann doch nicht. Der EhBASIC tokenizer sucht zunächst nach dem ersten Zeichen des Dictionary-Eintrags. Das zu suchende Zeichen liegt hierbei im Akku. Das Dictionary liegt schon in Großschreibung vor, sodass es an dieser Stelle reicht, den Akkuinhalt zu prüfen, ob es sich um einen Buchstaben handelt, und diesen dann in den entsprechenden Großbuchstaben zu verwandeln. Unser toupper-Makro tut genau das!&lt;/p>
&lt;p>Jetzt funktioniert der Tokenizer zumindest schon einmal für das erste Zeichen case-insensitiv. Für den Rest des Schlüsselworts galt es, ein wenig zu knobeln, denn das zu vergleichende Zeichen liegt hier nicht im Akku. Der Hack besteht nun darin, nach einem Nichttreffer den Akkuinhalt in einen Kleinbuchstaben zu verwandeln und einfach nochmal zu vergleichen: &lt;a href="https://bitbucket.org/steckschwein/steckschwein-code/commits/7729b971379f4ec022e9c98a3154ff6b0a20653f">https://bitbucket.org/steckschwein/steckschwein-code/commits/7729b971379f4ec022e9c98a3154ff6b0a20653f&lt;/a>&lt;/p>
&lt;p>Das macht den Tokenizer für in Kleinbuchstaben geringfügig langsamer, was aber auf die Ausführungsgeschwindigkeit keinen Einfluss. Als Extra-Bonus können Variablennamen jetzt groß oder klein geschrieben sein, also i ist nicht gleich I.&lt;/p>
&lt;p>Zuletzt wurde noch eine weitere Anregung aus dem 6502.org-Forum umgesetzt, denn zwar ist der Tokenizer jetzt case-insensitive, aber Buchstaben, die nicht im Dictionary stehen, werden weiterhin immer als Großbuchstaben dargestellt. Auch hier gibt es einen kleinen Patch: &lt;a href="http://forum.6502.org/viewtopic.php?p=50271#p50271">http://forum.6502.org/viewtopic.php?p=50271#p50271&lt;/a>&lt;/p>
&lt;p>Jetzt fehlen nur noch Implementationen für LOAD und SAVE, damit wir unsere BASIC-Kunstwerke auch im Filesystem speichern können und evtl. das ein oder andere BASIC-Spiel vom C64 portieren können.&lt;/p></content></item><item><title>Es wird geschraubt</title><link>https://beta.steckschwein.de/post/es-wird-geschraubt/</link><pubDate>Mon, 25 Jul 2016 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/es-wird-geschraubt/</guid><description>Es ist mal wieder recht still ums Schwein. Und mal wieder ist das kein Indiz dafür, dass nicht gewerkelt wird. In den letzten Wochen wurden BIOS und der SteckOS-Kernel auf Basis des Assemblers ca65 neu gebaut. Dessen nachgelagerter Linker erlaubt eine übersichtlichere Strukturierung der Codebasis.
In den FAT32-Code wird aktuell ebenfalls einiges an Hirnschmalz investiert, um endlich Cluster Chain lookups und Schreib-Support bauen zu können.
Darüberhinaus kam letzte Woche der Geistesblitz, die Kommunikation des Tastaturcontrollers ATmega8 mit der Tastatur über dessen eingebauten USART zu machen, anstatt &amp;ldquo;Zu Fuß&amp;rdquo; in Software.</description><content>&lt;p>Es ist mal wieder recht still ums Schwein. Und mal wieder ist das kein Indiz dafür, dass nicht gewerkelt wird. In den letzten Wochen wurden BIOS und der SteckOS-Kernel auf Basis des Assemblers ca65 neu gebaut. Dessen nachgelagerter Linker erlaubt eine übersichtlichere Strukturierung der Codebasis.&lt;/p>
&lt;p>In den FAT32-Code wird aktuell ebenfalls einiges an Hirnschmalz investiert, um endlich Cluster Chain lookups und Schreib-Support bauen zu können.&lt;/p>
&lt;p>Darüberhinaus kam letzte Woche der Geistesblitz, die Kommunikation des Tastaturcontrollers ATmega8 mit der Tastatur über dessen eingebauten USART zu machen, anstatt &amp;ldquo;Zu Fuß&amp;rdquo; in Software. Hier wird aktuell also auch geforscht. Wenn das klappt, dann wird dies auf jeden Fall in das Redesign des IO-Boards einfließen.&lt;/p>
&lt;p>&lt;img src="images/f5daf605-fa8e-4a54-bee9-9d807671d973.jpg" alt="f5daf605-fa8e-4a54-bee9-9d807671d973">&lt;/p></content></item><item><title>Wir sind umgezogen II</title><link>https://beta.steckschwein.de/post/wir-sind-umgezogen-ii/</link><pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/wir-sind-umgezogen-ii/</guid><description>Nach dem Umzug der Website ist jetzt unser Code-Repository dran. Dies ist jetzt auf bitbucket.org zu finden:
https://bitbucket.org/steckschwein/steckschwein-code</description><content>&lt;p>Nach dem Umzug der Website ist jetzt unser Code-Repository dran. Dies ist jetzt auf &lt;a href="https://bitbucket.org">bitbucket.org&lt;/a> zu finden:&lt;/p>
&lt;p>&lt;a href="https://bitbucket.org/steckschwein/steckschwein-code">https://bitbucket.org/steckschwein/steckschwein-code&lt;/a>&lt;/p></content></item><item><title>Wir sind umgezogen</title><link>https://beta.steckschwein.de/post/wir-sind-umgezogen/</link><pubDate>Thu, 23 Jun 2016 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/wir-sind-umgezogen/</guid><description>www.steckschwein.de wird nun direkt bei Wordpress.com gehostet. Somit müssen wir uns um keinen root-Server mehr kümmern und haben mehr Zeit fürs Steckschwein. :-)</description><content>&lt;p>&lt;a href="https://www.steckschwein.de">www.steckschwein.de&lt;/a> wird nun direkt bei Wordpress.com gehostet. Somit müssen wir uns um keinen root-Server mehr kümmern und haben mehr Zeit fürs Steckschwein. :-)&lt;/p></content></item><item><title>VCFe 15 - Schön wars!</title><link>https://beta.steckschwein.de/post/vcfe-15-schoen-wars/</link><pubDate>Sun, 04 May 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/vcfe-15-schoen-wars/</guid><description>Das VCFe 15 ist zu Ende, wo eine größere Öffentlichkeit unsere Steckschweine und Experimente live in Augenschein nehmen konnte, und wo wir am Sonntag Mittag auch einen kleinen Vortrag zu Entstehung der Idee, des Steckschweins und Problemen halten durften.
Wer uns verpasst hat, findet zumindest hier die Folien.
Wir sind immer noch überwältigt von all der positiven Resonanz, die wir erfahren haben. Insgeheim hatten wir eher damit gerechnet, dass unsere Basteleien von den Cracks eher belächelt würden, aber das Gegenteil war der Fall.</description><content>&lt;p>Das &lt;a href="http://www.vcfe.org/D/">VCFe 15&lt;/a> ist zu Ende, wo eine größere Öffentlichkeit unsere Steckschweine und Experimente live in Augenschein nehmen konnte, und wo wir am Sonntag Mittag auch einen kleinen Vortrag zu Entstehung der Idee, des Steckschweins und Problemen halten durften.&lt;/p>
&lt;p>Wer uns verpasst hat, findet zumindest hier &lt;a href="https://drive.google.com/file/d/0B82yoNWUtYziaHJscW9sVjVpNVk/edit?usp=sharing">die Folien&lt;/a>.&lt;/p>
&lt;p>Wir sind immer noch überwältigt von all der positiven Resonanz, die wir erfahren haben. Insgeheim hatten wir eher damit gerechnet, dass unsere Basteleien von den Cracks eher belächelt würden, aber das Gegenteil war der Fall. So viel konstruktive Vorschläge, fachliche Unterstützung und sogar Sachspenden - damit haben wir nicht gerechnet und wir freuen uns tierisch! Vielen Dank an alle!&lt;/p>
&lt;p> &lt;/p>
&lt;p>&lt;a href="https://steckschwein.files.wordpress.com/2014/05/16910-img-20140502-wa0008.jpg">&lt;img src="images/16910-img-20140502-wa0008.jpg" alt="">&lt;/a>&lt;/p>
&lt;p> &lt;/p>
&lt;p>&lt;a href="https://steckschwein.files.wordpress.com/2014/05/51450-img-20140503-wa0000.jpg">&lt;img src="images/51450-img-20140503-wa0000.jpg" alt="">&lt;/a>&lt;/p></content></item><item><title>TMS9929 Wir sind am Ziel!</title><link>https://beta.steckschwein.de/post/tms9929-wir-sind-am-ziel/</link><pubDate>Mon, 14 Apr 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/tms9929-wir-sind-am-ziel/</guid><description>Nachdem das Timing vom Steckschwein grundsätzlich passt, sind auf einmal auch sämtliche Voodoo-Fehler verschwunden.
Jetzt lässt sich der VDP auch besser ansprechen, allerdings gibt es schon noch ein paar Probleme zu lösen, bspw. ist das DRAM sehr instabil irgendwie flackert ständig der Screen oder die Zeichen &amp;ldquo;Nullen&amp;rdquo; sich aus. Wir untersuchen das Steckbrett und die Spannungsversorgung. Wir beschließen, die Steckbrettkabel durch kurze blanke Drahtbrücken zu ersetzen und platzieren direkt am Vcc der einzelnen DRAMs die Abblock-Kondensatoren mit 100nF.</description><content>&lt;p>Nachdem das Timing vom Steckschwein grundsätzlich passt, sind auf einmal auch sämtliche Voodoo-Fehler verschwunden.&lt;/p>
&lt;p>Jetzt lässt sich der VDP auch besser ansprechen, allerdings gibt es schon noch ein paar Probleme zu lösen, bspw. ist das DRAM sehr instabil irgendwie flackert ständig der Screen oder die Zeichen &amp;ldquo;Nullen&amp;rdquo; sich aus. Wir untersuchen das Steckbrett und die Spannungsversorgung. Wir beschließen, die Steckbrettkabel durch kurze blanke Drahtbrücken zu ersetzen und platzieren direkt am Vcc der einzelnen DRAMs die Abblock-Kondensatoren mit 100nF. Genauso die Spannungsversorgung des VDPs, hier auch nochmal kurze Drahtbrücken verwenden und einen Abblock-Kondensator direkt an Vcc vorsehen.&lt;/p>
&lt;p>Wow, das Bild steht! Wie auf den Fernseher gemalt.Wir verbiegen den C64 Zeichensatz noch soweit, dass wir bequem ASCII-Zeichen als Text eingeben können ohne umständlich zu konvertieren.&lt;/p>
&lt;p>Und so sieht&amp;rsquo;s dann aus.&lt;/p>
&lt;p>&lt;a href="https://steckschwein.files.wordpress.com/2014/04/9b2ed-vdp_breakthrough.jpg">&lt;img src="images/9b2ed-vdp_breakthrough.jpg" alt="TMS9929 displaying cbm 64 letters" title="TMS9929 ">&lt;/a>&lt;/p></content></item><item><title>ACIA muss wieder raus</title><link>https://beta.steckschwein.de/post/acia-muss-wieder-raus/</link><pubDate>Fri, 28 Mar 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/acia-muss-wieder-raus/</guid><description>Die 65x51 ACIA erschien uns als die am tiefsten hängende Frucht, um eine RS232 Schnittstelle zu implementieren, nachdem wir Bit Banging nach C64 Vorbild ziemlich schnell verworfen hatten.
Auch programmiertechnisch mach die ACIA einen simplen Eindruck, ganze drei Register wollen beherrscht werden.
Die rs232-Schnittstelle ermöglicht uns, Code auf den Steckbrettrechner zu laden, ohne jedesmal das EEPROM neu brennen zu müssen. Eine gewaltige Erleichterung.
Aber - wir haben es bereits erwähnt - die ACIA hat keine Zukunft bei uns.</description><content>&lt;p>Die 65x51 ACIA erschien uns als die am tiefsten hängende Frucht, um eine RS232 Schnittstelle zu implementieren, nachdem wir Bit Banging nach C64 Vorbild ziemlich schnell verworfen hatten.&lt;br>
Auch programmiertechnisch mach die ACIA einen simplen Eindruck, ganze drei Register wollen beherrscht werden.&lt;br>
Die rs232-Schnittstelle ermöglicht uns, Code auf den Steckbrettrechner zu laden, ohne jedesmal das EEPROM neu brennen zu müssen. Eine gewaltige Erleichterung.&lt;/p>
&lt;p>Aber - wir haben es bereits erwähnt - die ACIA hat keine Zukunft bei uns. Die uns vorliegenden Chips können mit bis zu 2 MHz getaktet werden. Wir aber wollen hoch hinaus. Mit den aktuellen 65cXX-Chips von WDC sind schließlich bis zu 14MHz möglich.&lt;br>
Darüberhinaus sind mit der ACIA ohne Hacks nur 19200 baud möglich, und selbst hochgezüchtet sind mehr als 38400 baud nicht drin. Dazu kommt, dass es keinen Puffer gibt und für jedes empfangene Byte ein Interrupt ausgelöst werden müßte.&lt;/p>
&lt;p>Die Entscheidung ist gefallen. Die ACIA hat uns viel Spass gemacht, aber noch mehr Spass macht ein modernerer Schnittstellenchip: der 16550 UART, bekannt aus der Welt der IBM-kompatiblen.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Der 16550 kann zunächst einmal seine niedere Herkunft als PC-Chip nicht verbergen. Reset und Interrupt-Signal sind active high, sodass hier schonmal ein wenig Glue Logic vonnöten ist. Das Reset-Signal wird durch einen freien Inverter des 74ls04 geschickt. Um die IRQ-Leitung bei einem Interrupt auf L ziehen zu können, benötigen wir hier einen Inverter mit Open Collector-Ausgang. Dazu kommt ein 74ls06 zu Einsatz, der auch bis jetzt nichts anderes macht als das IRQ-Signal des UART zu verarbeiten.&lt;br>
Das Businterface erfordert weitere Anpassungen. Der 16550 hat ein jeweils separates Signal für RD (read) und WR (write), und zwar wahlweise eins als active high und eins als active low. Irgendwie muss man 40 Pins ja voll kriegen. Das jeweils nicht benötigte Signal wird entsprechend auf Potential gelegt. Also legen wir RD und WR auf Masse und kümmern uns nur noch um /RD und /WR.&lt;br>
Einen dedizierten Takteingang, wie wir es von den Chips der 65xx-Serie gewohnt sind, gibt es auch nicht.&lt;br>
Wir lassen uns von &lt;a href="http://www.6502.org/users/andre/icaphw/c64ser.html">Andre Fachats Umbau eines C64 auf 16550&lt;/a> inspirieren und legen CS0 auf High, CS2 auf Low und geben den Systemtakt PHI2 auf CS1. Somit ist der Chip immer nur selektiert, wenn PHI2 H ist. Die Adressdekodierung übernimmt hier wieder der GAL. Das CS-Signal von dort dient als Enable-Signal für einen 74ls138, der aus /RW und PHI2 separate /RD und /RW Signale dient. Der 74ls138 hat sogar noch einen Eingang und zwei Ausgänge frei, sodass sich unter Dazunahme einer weiteren Adressleitung sehr einfach ein zweiter UART unterbringen ließe. Auch hier dient die Arbeit von Andre Fachat als Vorbild.&lt;/p>
&lt;p>Richtig spassig wird der 16550 aber, wenn es an die Programmierung geht. Er verfügt über 12 Register, die an 8 Adressen ansprechbar sind. Auch Nicht-Mathematiker erkennen hier sofort, dass hier Registeradressen doppelt belegt sind. Registeradresse A beherbergt, wenn gelesen, also Register X, wenn geschrieben wird, ist es aber Register Y. Wahnsinn.&lt;br>
Quasi als kleiner Trost und Bonbon verfügt der 16550 dafür aber über das &amp;ldquo;Scratchpad&amp;rdquo;-Register. Dort kann man ein Byte ablegen und auch wieder lesen. Ansonsten beeinflusst es das Verhalten des Chips in keiner Weise. Die Bezeichnung &amp;ldquo;Scratchpad&amp;rdquo; legt nahe, dass dort Registerinhalte &amp;ldquo;entworfen&amp;rdquo; werden könnten, um sie dann von dort in das entsprechde Register zu übertragen. Nur verfügt der 16550 über keinerlei Möglichkeit, den Inhalt eines seiner Register ins Scratchpad zu legen oder von dort zu holen, sodass es jede andere Specherstelle genauso tut. Was bleibt ist, dass man quasi mit jedem verbauten 16550 ein Byte RAM gratis erhält. Sogesehen kann man gar nicht genug UARTs haben.&lt;/p></content></item><item><title>Das Design wird erweitert</title><link>https://beta.steckschwein.de/post/das-design-wird-erweitert/</link><pubDate>Sun, 16 Mar 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/das-design-wird-erweitert/</guid><description>Sinn der Sache ist ja nicht, etwas 1:1 nachzubauen, sondern ein möglichst eigenes Design. Nachdem wir mit Chris&amp;rsquo; Design - bzw. dessen, was wir davon übernommen haben (Adressdekodierung, ACIA, VIA) - genug herumgespielt hatten, galt es, &amp;ldquo;unser&amp;rdquo; Ding draus zu machen. Der erste Schritt war ein Sprung ins kalte Wasser in die uns bislang noch unbekannte Welt der Programmierbaren Logik. Dazu haben wir zunächst die Adressdekodierung bestehend aus 74ls138/74ls154 sowie etwas glue Logic in VHDL implementiert und auf ein GAL22V10D gebrannt.</description><content>&lt;p>Sinn der Sache ist ja nicht, etwas 1:1 nachzubauen, sondern ein möglichst eigenes Design. Nachdem wir mit Chris&amp;rsquo; Design - bzw. dessen, was wir davon übernommen haben (Adressdekodierung, ACIA, VIA) - genug herumgespielt hatten, galt es, &amp;ldquo;unser&amp;rdquo; Ding draus zu machen. Der erste Schritt war ein Sprung ins kalte Wasser in die uns bislang noch unbekannte Welt der Programmierbaren Logik. Dazu haben wir zunächst die Adressdekodierung bestehend aus 74ls138/74ls154 sowie etwas glue Logic in VHDL implementiert und auf ein GAL22V10D gebrannt. Somit haben wir 3 TTL-ICs durch einen GAL ersetzt und wieder Platz auf dem Steckbrett geschaffen. Und das Beste: Änderungen an der Dekodierungslogik laufen ab sofort minimalinvasiv.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Die erste Erweiterung ist ein /CS-Signal für den 2. 62256-Chip, der sich seinen Adressbereich mit 4k IO-Bereich und 8K ROM teilen darf und uns immerhin noch 20k nutzbares RAM beschert. Anfängliche Pläne, das unter dem ROM und IO liegende RAM nach Vorbild des C64 nutzbar zu machen stellen wir erstmal zurück. Zu viel Aufwand für lumpige 12k.&lt;/p>
&lt;p>Inzwischen gibt es auch eine rs232-Schnittstelle auf Basis einer 65x51 ACIA. Der vorliegende Chip kann mit max. 2MHz getaktet werden, daher ist der diskret aufgebaute 3MHz-Oszillator wieder arbeitslos. An seiner Stelle betaktet ein 2MHz-TTL-Oszillator unseren Rechner.&lt;/p>
&lt;p>Diese Begrenzung auf 2MHz gefällt uns nicht, eigentlich wollten wir den Rechner später so hoch wie möglich takten, auf jeden Fall mit 4MHz. Modernere CPUs sowie VIAs von WDC, die bis zu 14MHz Taktfrequenz vertragen, sind so gut wie geordert. Einzig die ACIA soll komplett durch einen moderneren Chip ersetzt werden, da sie uns nicht nur auf 2MHz, sondern auch auf 19200 baud begrenzt. Ein bisschen zu vintage, darum soll als nächtes die ACIA einem zeitgemäßeren Chip weichen.&lt;/p></content></item></channel></rss>