<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Loading ASCII sources in EhBasic - Steckschwein</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Loading ASCII sources in EhBasic"><meta property="og:description" content="Since our implementation of FAT32 now supports reading a file byte for byte, a little rework of the file handling in our version of EhBasic is in order.
In the past, we only could read or write a file as a whole, relative to the location in memory where the according pointer pointed to. We used this in EhBasic to save and load BASIC programs by dumping and reloading it’s binary representation from memory."><meta property="og:type" content="article"><meta property="og:url" content="https://www.steckschwein.de/post/ascii_ehbasic/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-09-23T15:00:00+00:00"><meta property="article:modified_time" content="2021-09-23T15:00:00+00:00"><meta itemprop=name content="Loading ASCII sources in EhBasic"><meta itemprop=description content="Since our implementation of FAT32 now supports reading a file byte for byte, a little rework of the file handling in our version of EhBasic is in order.
In the past, we only could read or write a file as a whole, relative to the location in memory where the according pointer pointed to. We used this in EhBasic to save and load BASIC programs by dumping and reloading it’s binary representation from memory."><meta itemprop=datePublished content="2021-09-23T15:00:00+00:00"><meta itemprop=dateModified content="2021-09-23T15:00:00+00:00"><meta itemprop=wordCount content="486"><meta itemprop=keywords content="fat,basic,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Loading ASCII sources in EhBasic"><meta name=twitter:description content="Since our implementation of FAT32 now supports reading a file byte for byte, a little rework of the file handling in our version of EhBasic is in order.
In the past, we only could read or write a file as a whole, relative to the location in memory where the according pointer pointed to. We used this in EhBasic to save and load BASIC programs by dumping and reloading it’s binary representation from memory."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=Steckschwein rel=home><div class="logo__item logo__text"><div class=logo__title>Steckschwein</div><div class=logo__tagline>An 8bit computer for the 21st century</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>Blog</span></a></li><li class=menu__item><a class=menu__link href=/hardware/><span class=menu__text>Hardware</span></a></li><li class=menu__item><a class=menu__link href=/software/><span class=menu__text>Software</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li><li class=menu__item><a class=menu__link href=/impressum/><span class=menu__text>Impressum</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Loading ASCII sources in EhBasic</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-09-23T15:00:00Z>September 23, 2021</time></div></div></header><div class="content post__content clearfix"><p>Since our implementation of FAT32 now supports reading a file byte for byte, a little rework of the file handling in our version of EhBasic is in order.</p><p>In the past, we only could read or write a file as a whole, relative to the location in memory where the according pointer pointed to. We used this in EhBasic to save and load BASIC programs by dumping and reloading it’s binary representation from memory. While this works well, this approach has the major disadvantage that the saved program will be incompatible with other versions of EhBasic or even with our own when the token list is changed, which happens when adding new commands.</p><p>So clearly, the better approach is to read the BASIC program as source in it’s ASCII representation. This is the way EhBasic’s late creator, Lee Davison, preferred, and suggested how to implement this:</p><pre><code>To load an ASCII program redirect the character input vector to read 
from your filesystem and return to the main interpreter loop. 
The input vector should be restored and the file closed when the 
file end is reached or an error is encountered.
</code></pre><p>Basically the interpreter would read characters and interpret them, just like them being typed in, but instead they will be read from the file. So, our LOAD command is implemented like this:</p><pre tabindex=0><code>LAB_LOAD: 
    lda #O_RDONLY 
    jsr openfile

    lda #&lt;fread_wrapper 
    sta VEC_IN 
    lda #&gt;fread_wrapper 
    sta VEC_IN+1

    lda #&lt;outvec_dummy 
    sta VEC_OUT 
    lda #&gt;outvec_dummy 
    sta VEC_OUT+1 

    JMP LAB_1319 ; reset and return
</code></pre><p>All it does is changing the in and output vectors and then returning back to the interpreter, which then begins to read characters from VEC_IN until the file is read. But then what? The input vector still points to fread_wrapper, how do we get control back?
That’s the reason we did not point the vector directly to fat_fread_byte. Instead, we implemented a wrapper, which will read a byte from the file and pass it to EhBasic, and restore the vectors when EOF is reached:</p><pre tabindex=0><code>fread_wrapper: 
    phx 
    phy 
    ldx _fd 
    jsr krn_fread_byte 
    bcs @eof 
    cmp #KEY_LF ; replace with &#34;basic end of line&#34; 
    bne :+ 
    lda #KEY_CR
:   ply   
    plx 
    cmp #0 
    rts
@eof: 
    jsr krn_close
    jsr init_iovectors
    SMB7 OPXMDM ; set upper bit in flag (print Ready msg) 
    jmp LAB_1319 ; cleanup and Return to BASIC

init_iovectors: 
    lda #&lt;krn_chrout 
    sta VEC_OUT 
    lda #&gt;krn_chrout 
    sta VEC_OUT+1
    lda #&lt;krn_getkey 
    sta VEC_IN 
    lda #&gt;krn_getkey 
    sta VEC_IN+1 
    rts
</code></pre><p>Also, outvec dummy ist just an empty subroutine which we set the output vector VEC_OUT to, in order to suppress output while loading. Otherwise, the input would be echoed by the interpreter loop, resulting in the program being listed during load.</p><pre tabindex=0><code>outvec_dummy: 
    rts
</code></pre><p>Now we’re ready to feed almost any BASIC source to EhBasic, which will make porting existing BASIC software pretty easy.</p><p><img src=images/basic_load.png alt="ASCII based LOAD in action" title="ASCII based LOAD in action"></p><p>The next step will be to save BASIC programs in ASCII format by setting VEC_OUT accordingly and triggering a LIST command.</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/fat/ rel=tag>fat</a></li><li class=tags__item><a class="tags__link btn" href=/tags/basic/ rel=tag>basic</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 Steckschwein.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>