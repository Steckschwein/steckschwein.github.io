<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rs232 on Steckschwein</title><link>https://beta.steckschwein.de/categories/rs232/</link><description>Recent content in rs232 on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 28 Nov 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://beta.steckschwein.de/categories/rs232/index.xml" rel="self" type="application/rss+xml"/><item><title>Neue Hardware - die Platinen sind da</title><link>https://beta.steckschwein.de/post/neue-hardware-die-platinen-sind-da/</link><pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/neue-hardware-die-platinen-sind-da/</guid><description>Die neuen IO-Platinen mit integriertem UART sind fertig und haben ihren Weg von China nach München gefunden.
Mit dem neuen Layout hat es nicht nur der UART mit aufs IO-Board geschafft, es sind auch etliche kleinere und größere Verbesserungen eingeflossen:
Die Joystickports wurden komplett neu designed. Die Optokoppler sparen wir uns, stattdessen wählen wir über einen VIA Pin verschiedene Treiber an, die den gewünschten Joystickport mit VIA Port A verbindet. Die Ports lassen sich auch per Software komplett abschalten, damit der User-Port frei verfügbar ist.</description><content>&lt;p>Die neuen IO-Platinen mit integriertem UART sind fertig und haben ihren Weg von China nach München gefunden.&lt;/p>
&lt;p>Mit dem neuen Layout hat es nicht nur der UART mit aufs IO-Board geschafft, es sind auch etliche kleinere und größere Verbesserungen eingeflossen:&lt;/p>
&lt;ul>
&lt;li>Die Joystickports wurden komplett neu designed. Die Optokoppler sparen wir uns, stattdessen wählen wir über einen VIA Pin verschiedene Treiber an, die den gewünschten Joystickport mit VIA Port A verbindet. Die Ports lassen sich auch per Software komplett abschalten, damit der User-Port frei verfügbar ist. Als Schutz für die VIA werden Serienwiderstände verwendet.&lt;/li>
&lt;li>Der SD-Karten-Footprint und der verwendente Slot passen genau zusammen. Das war beim alten Board nicht der Fall. Jetzt sind die Karten- und die Schreibschutzerkennung endlich nutzbar.&lt;/li>
&lt;li>Die Datenpins für die PS/2 Schnittstelle am ATmega8 sind gewandert und liegen jetzt an PD6 und 7. Dadurch sind die RX und TX Pins des USART verfügbar geworden und können nun z.B. für das Debugging des Tastaturcontrollers verwendet werden.&lt;/li>
&lt;li>Zweckmäßigere Plazierung vom SPI-Anschluss des ATmega8 und des freien SPI Ports am Platinenrand. Updates der Tastaturcontrollerfirmware sind nun kein Krampf mehr.&lt;/li>
&lt;li>Der User-Port hat ein besseres Pinout.&lt;/li>
&lt;li>Die neue Platine sieht einfach besser aus.
&lt;img src="images/img_3091.jpg" alt="IMG_3091"> Frisch ausgepackte Platine&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="images/img_3092.jpg" alt="IMG_3092"> Fertig bestückte Platine
&lt;img src="images/img_3093.jpg" alt="IMG_3093"> Die nun obsolet gewordenen Platinen.&lt;/p></content></item><item><title>Exkurs: Wie kommt Code aufs Steckschwein?</title><link>https://beta.steckschwein.de/post/exkurs-wie-kommt-code-aufs-steckschwein/</link><pubDate>Thu, 03 Apr 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/exkurs-wie-kommt-code-aufs-steckschwein/</guid><description>Die Programmierung eines Computers, der nur aus einer gesteckten Schaltung besteht und weder Tastatur noch Speichermöglichkeit hat, ist eine mühsame Angelegenheit. Die allerersten Experimente bekamen ihr Futter auf einem 27128-EPROM serviert. Bekanntlich wollen diese vor dem Beschreiben mit neuem Code mit UV-Licht gelöscht werden. Also wurde für jedes Update ein EPROM mit neuem Code gebrannt, um die EPROMS anschließend in 10er-Packen ins Löschgerät zu schieben. 15 Minuten Kaffeepause.
Überhaupt, Code: Für die ersten Experimente hat es genügt, die reinen Hexcodes in einen Hexeditor zu tippen und die Daten dann zu brennen.</description><content>&lt;p>Die Programmierung eines Computers, der nur aus einer gesteckten Schaltung besteht und weder Tastatur noch Speichermöglichkeit hat, ist eine mühsame Angelegenheit. Die allerersten Experimente bekamen ihr Futter auf einem 27128-EPROM serviert. Bekanntlich wollen diese vor dem Beschreiben mit neuem Code mit UV-Licht gelöscht werden. Also wurde für jedes Update ein EPROM mit neuem Code gebrannt, um die EPROMS anschließend in 10er-Packen ins Löschgerät zu schieben. 15 Minuten Kaffeepause.&lt;/p>
&lt;p>Überhaupt, Code: Für die ersten Experimente hat es genügt, die reinen Hexcodes in einen Hexeditor zu tippen und die Daten dann zu brennen. Dies war vertretbar, da die ersten Programme etwa so aussahen: EA EA EA EA EA EA EA EA C9 C9 C9 C9 C9 C9 C9 C9 4C 00 0E&lt;/p>
&lt;p>Der Erwerb einiger EEPROMS des Typs 28c256 stellten eine große Erleichterung dar, als das Steckschwein langsam zu einem &amp;ldquo;richtigen&amp;rdquo; Computer und der Testcode damit immer umfangreicher würde. Die UV-Kaffeepausen entfielen, der Chip konnte einfach wieder neu gebrannt werden. Moderne Zeiten.&lt;/p>
&lt;p>Auch der komplexere Code erforderte langsam neue Herangehensweisen. Komplexere Routinen wurden auf dem C64 im Maschinensprachemonitor vorgeschrieben und die Hexcodes dann abgetippt und auf EEPROM gebrannt (ja, echt). Aber auch mühselig. Neues Werkzeug musste her. Und zwar in Form des &lt;a href="https://sourceforge.net/projects/acme-crossass/">ACME-Crossassemblers&lt;/a>. Nach kurzer Eingewöhnung (warum haben wir das nicht gleich so gemacht?) konnte nun drauflosgecoded werden dass die Schwarte kracht. Wenn nur dieses leidige Chip Umstecken nicht wäre.&lt;/p>
&lt;p>Unser Steckschwein verfügte inzwischen über eine 65c51 ACIA und damit über eine RS232-Schnittstelle. Das mußte sich doch irgendwie nutzen lassen. Steckschwein-seitig sollte das BIOS nur die Hardware initialisieren, im Falle der ACIA die Verbindungsparameter (Baudrate, Stopbit..) setzen, und dann einfach nur die Schnittstelle pollen und auf Futter warten. Und dieses dann Byte für Byte in den Speicher schreiben und am Ende an diese Adresse springen.&lt;/p>
&lt;p>Auf der anderen Seite des rs232-Kabels entschieden wir uns, ein kleines Python-Programm zu schreiben, welches mittels &lt;a href="http://pyserial.sourceforge.net/">Pyserial&lt;/a> die Kommunikation übernehmen sollte. Als rätselhaft schwierig gestaltete es sich, Daten &amp;ldquo;am Stück&amp;rdquo; an das Steckschwein zu senden, die Kommunikation brach nach wenigen Bytes ab. Wir hielten das zunächst für eine Macke der an Macken nicht armen ACIA, und programmierten drum herum. Die Laderoutine auf dem Steckschwein quittierte jedes empfangene Byte mit einem &amp;ldquo;*&amp;rdquo;. Das Python programm schrieb ein Byte, und las ein &amp;ldquo;*&amp;rdquo;. Als &amp;ldquo;Ende-Markierung&amp;rdquo; dienten 5 Null-Bytes am Ende des Programms. Wurde also das fünfte $00 empfangen, nahm die Laderoutine keine Daten mehr entgegen und führte ein JMP $1000 aus, wo der Code auch seine Startadresse zu haben hatte. Diese Methode war auch bei 19200 baud ziemlich lahm, aber tat ihren Job erstmal. Kein elendes Chip umstecken mehr. Den angeblichen ACIA-Macken wurde keine weitere Beachtung mehr geschenkt, sollte die ACIA doch schließlich durch einen 16550 UART abgelöst werden. Vorher den Code nochmal anzufassen wäre nicht sinnvoll.&lt;/p>
&lt;p>Nachdem also besagter 16550 einige Nerven gekostet hatte (hierzu an anderer Stelle mehr), war es Zeit, die Uploadroutine zu überarbeiten. Zum Einen sollte nach einem berechtigen Einwand von Marko die Endmarkierung mit den 5 Nullbytes weg. Sowas kommt nämlich durchaus vor, wenn man mal Zeichensätze oder sowas hochladen will. Zum anderen wäre es praktisch, wenn man die Ladeadresse wählen könnte. Doch zuallererst sollte dieser *-Hack weg. Denn dieser war auch mit dem UART noch nötig. Also sind entweder ACIA und UART beide gleich bescheuert, oder wir machen irgendwas falsch.&lt;/p>
&lt;p>Eigentlich sollte es möglich sein, mittels&lt;/p>
&lt;p>ser.write(code)&lt;/p>
&lt;p>unseren ganzen Code komplett rüberzuschieben, ohne zwischendrin irgendeinen Pseudo-Handshake veranstalten zu müssen. Trotzdem kommen immer nur ein paar Bytes an, dann ist Schluß. Experimentieren mit irgendwelchen Timeout-Parametern von pyserial brachte keine Abhilfe. Nach einigem Probieren ging dann ein Licht an. Wir hatten folgendes probiert:&lt;/p>
&lt;p>ser.write(code) time.sleep(1)&lt;/p>
&lt;p>Und siehe da - der Code wurde komplett übertragen. Anscheinend ist es so, dass in pyserial write nicht blockiert, read nach eingestelltem Timeout aber schon. Jedenfalls ist das auf dem Mac so, zu testen ob sich pyserial auf anderen Systemen anders verhält, haben wir uns erspart.&lt;/p>
&lt;p>Ich schreibe die Uploadroutine so um, dass sie 2 Bytes erwartet, nämlich die Ladeadresse, dies dann mit &amp;ldquo;OK&amp;rdquo; quittiert, dann nochmal 2 Bytes, nämlich die Länge der zu übertragenden Daten, wieder &amp;ldquo;OK&amp;rdquo;, dann die Daten selbst, bis die entsprechende Anzahl Bytes empfangen wurde, dann wieder &amp;ldquo;OK&amp;rdquo;.&lt;/p>
&lt;p>Das Python-Programm macht demnach einfach bytes = ser.write(struct.pack(&amp;rsquo;&amp;lt;h&amp;rsquo;, startaddr))         if ser.read(2) == &amp;lsquo;OK&amp;rsquo;:                 print &amp;ldquo;Start address %d bytes&amp;rdquo; % (bytes, ) bytes = ser.write(struct.pack(&amp;rsquo;&amp;lt;h&amp;rsquo;, length))         if ser.read(2) == &amp;lsquo;OK&amp;rsquo;:                 print &amp;ldquo;Length %d bytes&amp;rdquo; % (bytes, ) bytes = ser.write(content)         if ser.read(2) == &amp;lsquo;OK&amp;rsquo;:                 print &amp;ldquo;Length %d bytes&amp;rdquo; % (bytes, )&lt;/p>
&lt;p>Das war&amp;rsquo;s. Einfacher gehts fast nicht, die Ladeaddresse ist frei wählbar, und wir übertragen den Code dank UART jetzt mit 115200 baud statt mit 19200.&lt;/p></content></item><item><title>... kein Spaß - Murphy schlägt zu</title><link>https://beta.steckschwein.de/post/kein-spass-murphy-schlaegt-zu/</link><pubDate>Mon, 31 Mar 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/kein-spass-murphy-schlaegt-zu/</guid><description>Neben all den ermutigenden Experimenten gibt es natürlich auch immer mal wieder Rückschläge. Mittlerweile haben wir schon ein durchaus komplexes Gebilde auf dem Steckbrett, welches ja per se nicht die ideale Plattform ist, um so etwas zu bauen.
So wie aktuell gerade mein &amp;ldquo;Steckschwein&amp;rdquo; ein sehr merkwürdiges Verhalten an den Tag legt, ohne dass an der Schaltung etwas geändert worden wäre (Marko ist Zeuge).
Vorab nochmal der Ablauf unserer Upload-Routine, mit der wir das Steckschwein via RS232 mit Code befüttern:</description><content>&lt;p>Neben all den ermutigenden Experimenten gibt es natürlich auch immer mal wieder Rückschläge. Mittlerweile haben wir schon ein durchaus komplexes Gebilde auf dem Steckbrett, welches ja per se nicht die ideale Plattform ist, um so etwas zu bauen.&lt;/p>
&lt;p>So wie aktuell gerade mein &amp;ldquo;Steckschwein&amp;rdquo; ein sehr merkwürdiges Verhalten an den Tag legt, ohne dass an der Schaltung etwas geändert worden wäre (Marko ist Zeuge).&lt;/p>
&lt;p>Vorab nochmal der Ablauf unserer Upload-Routine, mit der wir das Steckschwein via RS232 mit Code befüttern:&lt;/p>
&lt;ol>
&lt;li>Transferprogramm sendet die Ladeaddresse (2 bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;li>Anzeige der Ladeaddresse im LCD&lt;/li>
&lt;li>Transferprogramm übermittelt die Länge der zu sendenden Daten (2 bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;li>Anzeige der Länge in Bytes im LCD&lt;/li>
&lt;li>Upload-Routine addiert Startaddresse + Länge in Bytes und errechnet so die Endadresse&lt;/li>
&lt;li>Anzeige der Endaddresse im LCD&lt;/li>
&lt;li>Transferprogramm sendet den Code (n bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;/ol>
&lt;p>Völlig unprovoziert wird auf einmal das &amp;ldquo;O&amp;rdquo; unterschlagen, sodass wir nur noch ein &amp;ldquo;K&amp;rdquo; erhalten. Dies läßt sich gut mit einem Terminalprogramm nachvollziehen. Um weiter debuggen zu können, passen wir das Transferprogramm an, dass es sich auch mit &amp;ldquo;K&amp;rdquo; zufriedengibt und laden eine echo-Routine, die die empfangenen Zeichen wieder über RS232 zurückschreibt und außerdem auf dem Display ausgibt.&lt;/p>
&lt;p>Wir beobachten, wie einige Zeichen wieder ge-echo-t werden, andere nicht, während sie nebst einigem Müll sowie der Ziffer 0 auf dem Display ausgegeben werden.&lt;/p>
&lt;p>Ein ähnliches Phänomen haben wir schon beim Einbau/Programmierung des UART beobachtet. Damals war der Fehler, dass die FIFO aktiviert war. Da wir den UART aktuell nur mittels Polling betreiben, gab es Probleme, die sich mit der Deaktivierung der FIFO beheben ließen. Das ist hier anders. Und zu allem Überfluss scheint das Phänomen zeitweilig auch wieder zu verschwinden. Will heissen: Ohne unser Zutun kam auch wieder ein &amp;ldquo;OK&amp;rdquo;. Dann wieder nicht mehr. Die zugegeben bis dato etwas windige Verdrahtung der Speicherchips wurde bei der Gelegenheit durch &amp;ldquo;richtige&amp;rdquo; Steckstrippen ersetzt. Die dabei entstandenen Fehler wurden schließlich auch gefunden, sodass wir mit einem Tag Verzug wieder so weit waren, das eigentliche Problem zu erforschen.&lt;/p>
&lt;p>Unsere Mem-Test-Routine läßt sich hochladen, zeigt aber immer denselben Fehler. Da wir nicht sicher sein können, ob die Routine tatsächlich korrekt hochgeladen wurde, macht weiteres Testen nur Sinn, wenn die dazu notwendigen Routinen bereits im ROM liegen.&lt;/p></content></item><item><title>ACIA muss wieder raus</title><link>https://beta.steckschwein.de/post/acia-muss-wieder-raus/</link><pubDate>Fri, 28 Mar 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/acia-muss-wieder-raus/</guid><description>Die 65x51 ACIA erschien uns als die am tiefsten hängende Frucht, um eine RS232 Schnittstelle zu implementieren, nachdem wir Bit Banging nach C64 Vorbild ziemlich schnell verworfen hatten.
Auch programmiertechnisch mach die ACIA einen simplen Eindruck, ganze drei Register wollen beherrscht werden.
Die rs232-Schnittstelle ermöglicht uns, Code auf den Steckbrettrechner zu laden, ohne jedesmal das EEPROM neu brennen zu müssen. Eine gewaltige Erleichterung.
Aber - wir haben es bereits erwähnt - die ACIA hat keine Zukunft bei uns.</description><content>&lt;p>Die 65x51 ACIA erschien uns als die am tiefsten hängende Frucht, um eine RS232 Schnittstelle zu implementieren, nachdem wir Bit Banging nach C64 Vorbild ziemlich schnell verworfen hatten.&lt;br>
Auch programmiertechnisch mach die ACIA einen simplen Eindruck, ganze drei Register wollen beherrscht werden.&lt;br>
Die rs232-Schnittstelle ermöglicht uns, Code auf den Steckbrettrechner zu laden, ohne jedesmal das EEPROM neu brennen zu müssen. Eine gewaltige Erleichterung.&lt;/p>
&lt;p>Aber - wir haben es bereits erwähnt - die ACIA hat keine Zukunft bei uns. Die uns vorliegenden Chips können mit bis zu 2 MHz getaktet werden. Wir aber wollen hoch hinaus. Mit den aktuellen 65cXX-Chips von WDC sind schließlich bis zu 14MHz möglich.&lt;br>
Darüberhinaus sind mit der ACIA ohne Hacks nur 19200 baud möglich, und selbst hochgezüchtet sind mehr als 38400 baud nicht drin. Dazu kommt, dass es keinen Puffer gibt und für jedes empfangene Byte ein Interrupt ausgelöst werden müßte.&lt;/p>
&lt;p>Die Entscheidung ist gefallen. Die ACIA hat uns viel Spass gemacht, aber noch mehr Spass macht ein modernerer Schnittstellenchip: der 16550 UART, bekannt aus der Welt der IBM-kompatiblen.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Der 16550 kann zunächst einmal seine niedere Herkunft als PC-Chip nicht verbergen. Reset und Interrupt-Signal sind active high, sodass hier schonmal ein wenig Glue Logic vonnöten ist. Das Reset-Signal wird durch einen freien Inverter des 74ls04 geschickt. Um die IRQ-Leitung bei einem Interrupt auf L ziehen zu können, benötigen wir hier einen Inverter mit Open Collector-Ausgang. Dazu kommt ein 74ls06 zu Einsatz, der auch bis jetzt nichts anderes macht als das IRQ-Signal des UART zu verarbeiten.&lt;br>
Das Businterface erfordert weitere Anpassungen. Der 16550 hat ein jeweils separates Signal für RD (read) und WR (write), und zwar wahlweise eins als active high und eins als active low. Irgendwie muss man 40 Pins ja voll kriegen. Das jeweils nicht benötigte Signal wird entsprechend auf Potential gelegt. Also legen wir RD und WR auf Masse und kümmern uns nur noch um /RD und /WR.&lt;br>
Einen dedizierten Takteingang, wie wir es von den Chips der 65xx-Serie gewohnt sind, gibt es auch nicht.&lt;br>
Wir lassen uns von &lt;a href="http://www.6502.org/users/andre/icaphw/c64ser.html">Andre Fachats Umbau eines C64 auf 16550&lt;/a> inspirieren und legen CS0 auf High, CS2 auf Low und geben den Systemtakt PHI2 auf CS1. Somit ist der Chip immer nur selektiert, wenn PHI2 H ist. Die Adressdekodierung übernimmt hier wieder der GAL. Das CS-Signal von dort dient als Enable-Signal für einen 74ls138, der aus /RW und PHI2 separate /RD und /RW Signale dient. Der 74ls138 hat sogar noch einen Eingang und zwei Ausgänge frei, sodass sich unter Dazunahme einer weiteren Adressleitung sehr einfach ein zweiter UART unterbringen ließe. Auch hier dient die Arbeit von Andre Fachat als Vorbild.&lt;/p>
&lt;p>Richtig spassig wird der 16550 aber, wenn es an die Programmierung geht. Er verfügt über 12 Register, die an 8 Adressen ansprechbar sind. Auch Nicht-Mathematiker erkennen hier sofort, dass hier Registeradressen doppelt belegt sind. Registeradresse A beherbergt, wenn gelesen, also Register X, wenn geschrieben wird, ist es aber Register Y. Wahnsinn.&lt;br>
Quasi als kleiner Trost und Bonbon verfügt der 16550 dafür aber über das &amp;ldquo;Scratchpad&amp;rdquo;-Register. Dort kann man ein Byte ablegen und auch wieder lesen. Ansonsten beeinflusst es das Verhalten des Chips in keiner Weise. Die Bezeichnung &amp;ldquo;Scratchpad&amp;rdquo; legt nahe, dass dort Registerinhalte &amp;ldquo;entworfen&amp;rdquo; werden könnten, um sie dann von dort in das entsprechde Register zu übertragen. Nur verfügt der 16550 über keinerlei Möglichkeit, den Inhalt eines seiner Register ins Scratchpad zu legen oder von dort zu holen, sodass es jede andere Specherstelle genauso tut. Was bleibt ist, dass man quasi mit jedem verbauten 16550 ein Byte RAM gratis erhält. Sogesehen kann man gar nicht genug UARTs haben.&lt;/p></content></item></channel></rss>