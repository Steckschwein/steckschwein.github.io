<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.ico><title>Fixing PS/2 Keyboard handling (Part I) - Steckschwein</title><meta name=description content="The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:
The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI. The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&rsquo;t the states of the keyboard LEDs."><meta name=generator content="Hugo 0.101.0"><link rel=stylesheet href=https://steckschwein.github.io/css/main.css><meta property="og:title" content="Fixing PS/2 Keyboard handling (Part I)"><meta property="og:description" content="The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:
The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI. The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&rsquo;t the states of the keyboard LEDs."><meta property="og:type" content="article"><meta property="og:url" content="https://steckschwein.github.io/post/fixing-ps-2-keyboard-handling-part-i/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-11-14T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-14T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Fixing PS/2 Keyboard handling (Part I)"><meta name=twitter:description content="The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:
The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI. The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&rsquo;t the states of the keyboard LEDs."><meta itemprop=name content="Fixing PS/2 Keyboard handling (Part I)"><meta itemprop=description content="The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:
The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI. The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&rsquo;t the states of the keyboard LEDs."><meta itemprop=datePublished content="2020-11-14T00:00:00+00:00"><meta itemprop=dateModified content="2020-11-14T00:00:00+00:00"><meta itemprop=wordCount content="609"><meta itemprop=keywords content><meta itemprop=name content="Fixing PS/2 Keyboard handling (Part I)"><meta itemprop=description content="The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:
The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI. The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&rsquo;t the states of the keyboard LEDs."><meta itemprop=datePublished content="2020-11-14T00:00:00+00:00"><meta itemprop=dateModified content="2020-11-14T00:00:00+00:00"><meta itemprop=wordCount content="609"><meta itemprop=keywords content></head><body class="flex relative h-full min-h-screen"><aside class="will-change-transform transform transition-transform -translate-x-full absolute top-0 left-0 md:relative md:translate-x-0 w-3/4 md:w-60 h-full min-h-screen p-3 bg-slate-50 dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 flex flex-col gap-2.5 z-20 sidebar"><p class="font-bold mb-5 flex items-center gap-2"><button aria-label="Close sidebar" class="md:hidden menu-trigger-close p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-6 w-6" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
<a href=https://steckschwein.github.io class=px-2><span>Steckschwein</span></a>
<button aria-label="Toggle dark mode" class="dark-mode-toggle p-2 rounded border dark:border-slate-700 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-4 w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="4"/><path d="M3 12h1m8-9v1m8 8h1m-9 8v1M5.6 5.6l.7.7m12.1-.7-.7.7m0 11.4.7.7M6.3 17.7l-.7.7"/></svg></button></p><ul class="list-none flex flex-col gap-1"><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/home/><span>The Project</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/hardware/><span>Hardware</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/software/><span>Software</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/impressum/><span>Impressum</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/articles/><span>Articles</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/post/><span>Posts</span></a></li></ul><div class=flex-1></div><ul class="list-none flex flex-wrap justify-center gap-1 pt-2 border-t border-slate-200 dark:border-slate-600"></ul></aside><div class="fixed bg-slate-700 bg-opacity-5 transition duration-200 ease-in-out inset-0 z-10 pointer-events-auto md:hidden left-0 top-0 w-full h-full hidden menu-overlay"></div><button aria-label="Toggle Sidebar" class="md:hidden absolute top-3 left-3 z-10 menu-trigger p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-100"><svg class="h-6 w-6" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="18" x2="16" y2="18"/></svg></button><div class=flex-1><main class="h-screen overflow-y-auto"><div class="px-6 py-20 w-full lg:w-[580px] mx-auto prose dark:prose-invert h-fit prose-img:mx-auto"><h1>Fixing PS/2 Keyboard handling (Part I)</h1><p class="text-sm text-slate-500 !mb-8">November 14, 2020</p><p>The way the PS/2 keyboard is handled has always been something we were never quite happy with. The key points being:</p><ul><li>The PS/2 controller had no way of signalling that there has been a new keystroke, the buffer had to be polled via SPI.</li><li>The PS/2 controller had no way of talking to the keyboard and had to rely for the keyboard to initialize itself properly. Also, typematic rate and delay could not be set, as couldn&rsquo;t the states of the keyboard LEDs.</li></ul><p>Although mid- to long term, we likely might &ldquo;upgrade&rdquo; to USB anyway, but not without having done PS/2 right first. So, I will talk about integrating IRQ handling, and in a follow up post Marko will talk about how he got the PS/2 controller talking to the keyboard.</p><p>Luckily, during the design of the IO-board, we have been clever enough to hook IO-pins PC0 to PC2 to RESET_TRIG, NMI and IRQ, respectively. So on the hardware-side, we are very much ready.<br>First problem to solve is how to emulate an open collector output on the AVR controller. As it seems, a common way to do that is to disable the internal pullup of the pin, and have it configured as input to be &ldquo;tri state&rdquo;. When active, the pin gets activated as an output, and will pull the IRQ line low.</p><p><code>// pull IRQ line DDRC |= (1 &lt;&lt; IRQ);</code></p><p><code>// release IRQ line DDRC &= ~(1 &lt;&lt; IRQ);</code></p><p>Now that we know how to handle the IRQ-line, we need to figure out, WHEN to pull it. Obviously when a key was hit. And when to release it?</p><p>Finally, we decided to go the most simple way. The PS/2 controller will pull the IRQ line as long as there are more than 0 chars in the buffer. Once the buffer is empty, the IRQ-line will be released. This way, we do not need an interrupt register and hence no time consuming check of the latter, but need to do a little buffering on the steckOS-side.</p><p>This is all the code that&rsquo;s needed on the PS/2 controller side:</p><pre><code>if (kb\_buffcnt &gt; 0)
{
    DDRC |= (1 &lt;&lt; IRQ);     // pull IRQ line
}
else
{
    DDRC &amp;= ~(1 &lt;&lt; IRQ); // release IRQ line
}
</code></pre><p>Now, we need to add a little handling code to the steckOS IRQ-handler. Since we do not have an interrupt register, we just check the keyboard last, after every &ldquo;known&rdquo; interrupt source has been handled.<br>To get around having to implement another keyboard buffer, we just use a single memory location, labelled &ldquo;key&rdquo;. The IRQ handler will only fetch a byte from the keyboard when the target location is zero (0), otherwise it will just exit.<br>The system getkey-routine will load the contents from that location into the A register, and overwrite the location with 0 again to enable fetching the next char from the buffer.</p><p>The SPI check code is the last bit in the IRQ-handler routine:</p><p>`@check_spi:<br>lda key<br>bne @exit<br>jsr fetchkey<br>bcc @exit<br>sta key</p><p>@exit:<br>restore<br>rti`</p><p>That&rsquo;s basically all that&rsquo;s needed. The former getkey-routine has been renamed to fetchkey, and the new getkey routine only handles the ZP buffer location while retaining the old behaviour including setting the carry flag when a byte has been received. This way, existing programs using the keyboard do not have to be modified.</p><p>Now, we finally have a chance of reacting to keystrokes during program execution without having to explicitly poll the keyboard. This enables us to handle Ctrl-C and such much more elegantly. Also, any REPL-like program (like the shell) does not have to constantly poll the SPI bus.</p></div></main></div><script type=text/javascript src=/main.js defer></script></body></html>