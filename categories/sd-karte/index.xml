<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sd-karte on Steckschwein</title><link>https://beta.steckschwein.de/categories/sd-karte/</link><description>Recent content in sd-karte on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 16 Oct 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://beta.steckschwein.de/categories/sd-karte/index.xml" rel="self" type="application/rss+xml"/><item><title>Weird bug in SD card code</title><link>https://beta.steckschwein.de/post/weird-bug-in-sd-card-code/</link><pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/weird-bug-in-sd-card-code/</guid><description>Frank van den Hoef, who is adapting the Steckschwein SPI &amp;amp; FAT32 code for his tiny65 machine made me aware of a classic mistake for a 6502 assembly coder to make. Namely in our sdcard driver, when waiting for the &amp;ldquo;proper&amp;rdquo; response from the card (which should have bit 7 cleared). The routine handling this looked like this:
1 sd_cmd_response_wait: 2 ldy #sd_cmd_response_retries 3 @l: dey 4 beq sd_block_cmd_timeout ; y already 0?</description><content>&lt;p>Frank van den Hoef, who is adapting the Steckschwein SPI &amp;amp; FAT32 code for his tiny65 machine made me aware of a classic mistake for a 6502 assembly coder to make. Namely in our sdcard driver, when waiting for the &amp;ldquo;proper&amp;rdquo; response from the card (which should have bit 7 cleared). The routine handling this looked like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>1 sd_cmd_response_wait:
2 ldy #sd_cmd_response_retries
3 @l: dey
4 beq sd_block_cmd_timeout ; y already 0? then invalid response or timeout
5 jsr spi_r_byte
6 bit #80 ; bit 7 clear
7 bne @l ; no, next byte
8 cmp #$00 ; got cmd response, check if $00 to set z flag accordingly
9 rts
10 sd_block_cmd_timeout:
11 debug &amp;#34;sd_block_cmd_timeout&amp;#34;
12 lda #$1f ; make up error code distinct from possible sd card responses to mark timeout
13 rts
&lt;/code>&lt;/pre>&lt;p>Classic. Obviously, line 6 should read:&lt;/p>
&lt;pre tabindex="0">&lt;code> bit #$80 ; bit 7 clear
&lt;/code>&lt;/pre>&lt;p>With that fixed, the sd card init routine now fails, which is odd since we fixed something that was obviously broken.&lt;/p>
&lt;p>&lt;img src="images/sd_fail-e1571229478149.jpg" alt="sd_fail.jpg">&lt;/p>
&lt;p>Ok, now what? Enabling Marko&amp;rsquo;s mighty debugging macros, it becomes apparent that the sd card init fails right after sending CMD0 to the card. This command is the first command of the init sequence and is supposed to put the card into &amp;ldquo;idle mode&amp;rdquo;. Which the card confirms with an answer of $01. Which is what the init code is expecting, and not getting. Instead, we get $3F, which does not make a lot of sense.&lt;/p>
&lt;p>But why did it work before the fix? Assuming that the card did not change it&amp;rsquo;s behaviour at the same time I fixed the code, let&amp;rsquo;s check what actually happened. Before the fix, we were ANDing $3F with 80:&lt;/p>
&lt;p>&lt;code> 00111111 $3f&lt;/code>&lt;br>
&lt;code>01010000 80 (no $, decimal)&lt;/code>&lt;/p>
&lt;p>In this case, the BNE after the BIT #80 would take the branch to @l, causing the next byte being read, until finally the card responds with $01:&lt;/p>
&lt;p>&lt;code> 00000001 $01&lt;/code>&lt;br>
&lt;code>01010000 80 (no $, decimal)&lt;/code>&lt;/p>
&lt;p>Now the BNE does not take the branch, and the routine exits.&lt;/p>
&lt;p>Now, with the fixed code,  ANDing $3F with **$**80, to check if bit 7 is clear, which it is:&lt;/p>
&lt;p>&lt;code> 00111111 $3F&lt;/code>&lt;br>
&lt;code>10000000 $80&lt;/code>&lt;/p>
&lt;p>Alright, exit the loop and return $3f as response of the card. Which isn&amp;rsquo;t $01, so init failed.&lt;/p>
&lt;p>At this point, I have no explanation for the card responding $3F. I assume that the card might be not ready to process commands at this point, so I added code to repeat sending CMD0 until we get $01 or we run out of retries.&lt;/p></content></item><item><title>Mal wieder neue Hardware</title><link>https://beta.steckschwein.de/post/mal-wieder-neue-hardware/</link><pubDate>Wed, 22 Nov 2017 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/mal-wieder-neue-hardware/</guid><description>Die Zeit ist reif für ein Hardware-Update, und zwar für die IO-Platine 2.0. Vorgesehen war ja schon länger, den UART dort zu integrieren. Ausserdem war das Joystick&amp;ndash;Interface noch unausgegoren, sodass auch hier etwas Neues entwickelt wurde.
Zum Schutz der VIA-Pins dienen nun keine Optokoppler, sondern simple Serienwiderstände sollen die Ports zumindest vor dem Fall schützen, dass man doch mal die Datenrichtung der Joystick-Pins auf Ausgang schaltet und dann die VIA grillt indem man den Joystick betätigt.</description><content>&lt;p>Die Zeit ist reif für ein Hardware-Update, und zwar für die IO-Platine 2.0. Vorgesehen war ja schon länger, den UART dort zu integrieren. Ausserdem war das Joystick&amp;ndash;Interface noch unausgegoren, sodass auch hier etwas Neues entwickelt wurde.&lt;/p>
&lt;p>Zum Schutz der VIA-Pins dienen nun keine Optokoppler, sondern simple Serienwiderstände sollen die Ports zumindest vor dem Fall schützen, dass man doch mal die Datenrichtung der Joystick-Pins auf Ausgang schaltet und dann die VIA grillt indem man den Joystick betätigt. Die Widerstände begrenzen den Strom auf 1mA. Das muss die VIA abkönnen. Zudem war im vorigen Design der Userport nicht wirklich nutzbar, weil immer noch die Joysticks daran hingen. Jetzt ist es so, dass jeder Joystick über Tri State Buffer an VIA Port A verbunden wird, und zwar grundsätzlich wahlweise. Ausserdem besteht die Möglichkeit, die Joyports komplett abzuschalten. Dies wird mit dem OUT1-Pin des UART bewerkstelligt. Somit läßt sich per Software konfigurieren, ob man Userport oder Joystick benutzen möchte.&lt;/p>
&lt;p>Der User-Port hat ein neues, von &lt;a href="http://neil.franklin.ch/">Neil Franklin&lt;/a> vorgeschlagenes Pinout, in dem nun auch die /RESET und /IRQ-Leitungen vorhanden sind. Auch am Tastaturcontroller hat sich eine Kleinigkeit geändert, die Datenpins für den PS/2 Port sind nach PD6 bzw. PD7 gewandert. Somit sind die RX/TX-Pins des AVR USART wieder frei und bereit für neue Schandtaten. Deswegen haben sie auch eine kleine Pinleiste spendiert bekommen.&lt;/p>
&lt;p>&lt;img src="images/io2_0.png" alt=""> 3D Rendering der neuen IO-Platine&lt;/p></content></item><item><title>Mehr Karten (UPDATE)</title><link>https://beta.steckschwein.de/post/mehr-karten-update/</link><pubDate>Fri, 24 Jul 2015 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/mehr-karten-update/</guid><description>Unser &amp;ldquo;Standard&amp;rdquo;-Massenspeicher SD-Karte funktioniert zwar an und für sehr gut, Sorgenkind war aber immer die Initialisierungs-Routine. Bisher ließen sich damit nur günstige Class4-Karten initialisieren, bei &amp;ldquo;höherwertigen&amp;rdquo; Karten schlug die Initialisierung immer fehl, sodass nur etwa 3 von 5 Karten nutzbar waren.
Das hat uns schon etwas gewurmt, denn irgendwie hatte dieser Stand ein Geschmäckle von &amp;ldquo;Funktioniert aus Versehen&amp;rdquo;. Also mussten wir da nochmal ran. Der Initialisierungs-Flow entspricht im Wesentlichen dem, was auf der bekannten Seite http://elm-chan.</description><content>&lt;p>Unser &amp;ldquo;Standard&amp;rdquo;-Massenspeicher SD-Karte funktioniert zwar an und für sehr gut, Sorgenkind war aber immer die Initialisierungs-Routine. Bisher ließen sich damit nur günstige Class4-Karten initialisieren, bei &amp;ldquo;höherwertigen&amp;rdquo; Karten schlug die Initialisierung immer fehl, sodass nur etwa 3 von 5 Karten nutzbar waren.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Das hat uns schon etwas gewurmt, denn irgendwie hatte dieser Stand ein Geschmäckle von &amp;ldquo;Funktioniert aus Versehen&amp;rdquo;. Also mussten wir da nochmal ran. Der Initialisierungs-Flow entspricht im Wesentlichen dem, was auf der bekannten Seite &lt;a href="http://elm-chan.org/docs/mmc/mmc_e.html">http://elm-chan.org/docs/mmc/mmc_e.html&lt;/a> dokumentiert ist. In den letzten Tagen haben wir diesen unter die Lupe genommen, und tatsächlich ist etwas aufgefallen. Vor dem Senden eines Kommandos muss sichergestellt werden, dass die Karte bereit ist. Hierzu sendet man solange $ff an die Karte, bis diese auch $ff zurücksendet. Dann ist die Karte bereit, ein Kommando zu empfangen. In unserer Initialisierungsroutine wurde dies zwischen CMD55 und ACMD41 (näheres bitte dem Link entnehmen) schlichtweg nicht gemacht. Plötzlich lassen sich fast alle vorhandenen Karten initialisieren. Dass dies mit den Class4-Karten trotzdem funktionierte, war also gewissermaßen tatsächlich aus Versehen.&lt;/p>
&lt;p>Das nächste Problem war dann, dass von den jetzt nutzbaren Karten über die Shell zwar im Filesystem navigiert und Verzeichnisse aufgelistet werden konnten, das eigentliche Laden von Dateien bzw. Starten von Programmen funktionierte nicht. Die Blockleseroutinen liefen korrekt durch, die geladenen Daten jedoch waren fehlerhaft. Dass die Dateisystemoperationen funktioniert haben, und nur das Einlesen von Dateien Probleme machte, war verdächtig. &lt;a href="http://wordpress.steckschwein.de/wordpress/index.php/2015/05/20/filesystem-und-shell/">Noch im Mai verkündeten wir&lt;/a> u.a. stolz, dass wir zum Dateien lesen schnelle SD-Multiblock-Transfers verwenden. Diese haben den Vorteil, dass man der Karte nur die Adresse des ersten zu lesenden Blocks übermittelt, und dann einfach liest bis der Arzt kommt oder man der Karte sagt, dass man fertig ist. Vorteil ist, dass man die Blockadresse des nächsten Blocks nicht immer selber ausrechnen muss (immerhin eine 32bit-Addition) und auch nicht immer wieder an die Karte schicken muss.&lt;/p>
&lt;p>Gut, also die fat_read-Routine zurückgebaut, und schon ist das Steckschwein mit so ziemlich jeder handelsüblichen SD-Karte kompatibel.&lt;/p>
&lt;p>&lt;strong>[UPDATE:]&lt;/strong> Mittlerweile funktionieren auch wieder Multiblock-Transfers. Der Trick war, beim Lesen von der Karte die MOSI-Leitung nicht auf L, sondern auf H zu setzen, also nicht mehr $00 zu senden, sondern $ff. Die Idee kam, nachdem sämtliche Beispiele, die sich im Web finden lassen, $ff senden. Die Stelle in der SD-Karten-Spezifikation, in der das so spezifiziert ist, ist bis dato nicht gefunden worden.&lt;/p></content></item><item><title>Bootschwein</title><link>https://beta.steckschwein.de/post/bootschwein/</link><pubDate>Mon, 05 Jan 2015 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/bootschwein/</guid><description>Die Aufgabe, die wir dem (Steck)BIOS zugedacht haben, beschränkt sich darauf, die vorhandene Hardware zu initialisieren, auf eine eingelegte SD-Karte zu prüfen, und dann von dort das eigentliche &amp;ldquo;Betriebssystem&amp;rdquo; zu laden. Fast ein bisschen PC-like.
Hier ist die Überlegung, im Stammverzeichnis eine bestimmte Datei zu finden und an eine bestimmte Adresse in den Speicher zu laden.
Sollte dies fehlschlagen, kann man immer noch in einen Monitor oder unsere bekannte rs232-Uploadroutine springen.</description><content>&lt;p>Die Aufgabe, die wir dem (Steck)BIOS zugedacht haben, beschränkt sich darauf, die vorhandene Hardware zu initialisieren, auf eine eingelegte SD-Karte zu prüfen, und dann von dort das eigentliche &amp;ldquo;Betriebssystem&amp;rdquo; zu laden. Fast ein bisschen PC-like.&lt;/p>
&lt;p>Hier ist die Überlegung, im Stammverzeichnis eine bestimmte Datei zu finden und an eine bestimmte Adresse in den Speicher zu laden.&lt;/p>
&lt;p>Sollte dies fehlschlagen, kann man immer noch in einen Monitor oder unsere bekannte rs232-Uploadroutine springen.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Um nun also eine Datei auf der SD-Karte zu finden, müssen wir erstmal rudimentäre Unterstützung für das FAT-Dateisystem bauen. FAT stammt aus den 70er Jahren und hat als Dateisystem für MS-DOS-basierte Betriebssysteme Verbreitung gefunden. Ursprünglich war es für Disketten gedacht (FAT12), und wurde immer wieder erweitert, um auch wesentlich größere Datenträgerkapazitäten wie z.B. von Festplatten zunächst bis 2GB (FAT16), dann aber auch über diese Begrenzung heraus (FAT32) zu unterstützen.&lt;/p>
&lt;p>Da so ziemlich jede SD-Karte, die man heute kaufen kann, mindestens 2GB Kapazität hat, lassen wir FAT12 und FAT16 außen vor, und konzentrieren uns nur auf FAT32. Hierzu ist sicherlich die &lt;a href="http://msdn.microsoft.com/en-us/windows/hardware/gg463080.aspx">offizielle Dokumentation von Microsoft&lt;/a> eine sinnvolle Lektüre, als wesentlich hilfreicher hat sich aber das auf FAT32 konzentrierte &lt;a href="https://www.pjrc.com/tech/8051/ide/fat32.html">Understanding FAT32 Filesystems von Paul Stoffregen&lt;/a> erwiesen, indem es einen gezielt durch die Strukturen führt, die man für FAT32 tatsächlich braucht.&lt;/p>
&lt;p>Unsere Implementation beschränkt sich darauf, das Stammverzeichnis der ersten Partition zu lesen, bis eine Datei gefunden wird, die das &amp;ldquo;System&amp;rdquo;-Attribut hat. Diese wird eingelesen.&lt;/p>
&lt;p>Hierbei ist das Verfolgen der Clusterketten, also das eigentliche Auswerten der FAT, nicht implementiert, sodass die max. Dateigröße der Größe eines Clusters entspricht. Zum finden und laden dessen, was später mal unser &amp;ldquo;Betriebsystem&amp;rdquo; werden soll, reicht es aber.&lt;/p>
&lt;p>Der rudimentäre Code findet sich in unserem &lt;a href="https://sourceforge.net/p/steckschwein/code/ci/default/tree/fat/">Repository auf Sourceforge&lt;/a>.&lt;/p></content></item><item><title>Tore zur Welt</title><link>https://beta.steckschwein.de/post/tore-zur-welt/</link><pubDate>Fri, 11 Jul 2014 00:00:00 +0000</pubDate><guid>https://beta.steckschwein.de/post/tore-zur-welt/</guid><description>Um dem Ziel eines &amp;ldquo;richtigen&amp;rdquo; Computers näher zu kommen, brauchen wir nicht nur einen Videochip, wir brauchen auch Eingabegeräte und Massenspeicher.
Zwar soll unser Rechner so retro sein, dass es ihn damals, zur Hochzeit der 8bit-Heimcomputer, durchaus hätte geben können, realistischerweise wollen wir ihn jedoch mit durchaus modernen Schnittstellen ausstatten. Die 8bit-Rechner aus &amp;ldquo;unserer Zeit&amp;rdquo; haben IO-Chips wie den 6526 oder 6522 benutzt, um Tastatur (Matrix), Joysticks und Massenspeicher anzusteuern. Das haben wir auch vor.</description><content>&lt;p>Um dem Ziel eines &amp;ldquo;richtigen&amp;rdquo; Computers näher zu kommen, brauchen wir nicht nur einen Videochip, wir brauchen auch Eingabegeräte und Massenspeicher.&lt;/p>
&lt;p>Zwar soll unser Rechner so retro sein, dass es ihn damals, zur Hochzeit der 8bit-Heimcomputer, durchaus hätte geben können, realistischerweise wollen wir ihn jedoch mit durchaus modernen Schnittstellen ausstatten. Die 8bit-Rechner aus &amp;ldquo;unserer Zeit&amp;rdquo; haben IO-Chips wie den 6526 oder 6522 benutzt, um Tastatur (Matrix), Joysticks und Massenspeicher anzusteuern. Das haben wir auch vor. Nur etwas anders. Wir verwenden eine 65c22 VIA, und machen sie zu einem &lt;a href="http://de.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI&lt;/a> &amp;ldquo;Master&amp;rdquo;. Damit wollen wir einen wesentlichen Teil der Peripherie anbinden.&lt;/p>
&lt;p>SD-Karten unterstützen SPI direkt, sodass unsere angepeilte Massenspeicherlösung quasi schon fertig ist. Damit ersparen wir es uns, einen irgendwie gearteten Laufwerkscontroller ansteuern zu müssen oder gar über einen Haufen TTL eine IDE-Schnittstelle für alte Platten oder CompactFlash-Karten bauen zu müssen. Der einzige Zusatzaufwand, den wir hardwaremäßig noch betreiben müssen, ist eine 3.3V-Spannungsversorgung und eine Anpassung der 5V-Pegel der VIA auf 3.3V für die SD-Karte, denn SD-Karten laufen mit 3.3V und ihre Eingänge sind nicht 5V-tolerant. Der Rest ist Software.&lt;/p>
&lt;p>In Sachen Tastatur setzen wir auch auf eine Standardschnittstelle, nämlich PS/2. Das ist immer noch retro genug, und PS/2-Tastaturen sind immer noch einfacher zu beschaffen als Matrixtastaturen. Als kleiner Stilbruch bietet sich als Tastaturcontroller ein kleiner AVR-Microcontroller an, der die Scancodes der Tastatur in ASCII-Codes wandelt. Bequemerweise gibt es zahlreiche fertige Lösungen, die z.B. am anderen Ende rs232 sprechen. Wir wollen aber nur wegen einer Tastatur keinen zweiten UART verbauen. Fehlt also nur eine kleine Anpassung auf SPI. Aber zunächst mal die SD-Karte.&lt;/p>
&lt;p>Mit SPI hätten wir darüberhinaus noch viel mehr Möglichkeiten, ohne allzu großen Aufwand weitere SPI-fähige Komponenten wie RTCs, EEPROMS oder vielleicht sogar USB-Hosts anzubinden.&lt;/p>
&lt;p>Der Schaltplan zeigt, wie wir aktuell die VIA nutzen, um eine SD-Karte anzusprechen. Port B stellt die Steuerleitungen, wobei die beiden &amp;ldquo;äußeren&amp;rdquo; Bits 0 und 7 für SPICLK und MOSI verwendet werd, weil sie sich durch Inkrementieren, Dekrementieren bzw. Bit-Shifting schnell ansprechen lassen. Die 6 Bit dazwischen dienen als Slave-Select-Leitungen. MISO geht direkt in CB2, dem Eingang des Schieberegisters der VIA, welcher von PB0 an CB1 extern über unsere SPI-Clock getaktet wird. Damit läuft das Schieberegister exakt in dem Modus, der durch den berühmt berüchtigten VIA-Bug betroffen ist. Wir leben gerne gefährlich. Die Alternative wäre gewesen, ein externes Schieberegister zu benutzen, welches dann Port A belegt hätte. So bleibt dieser frei.&lt;/p>
&lt;p>&lt;a href="https://steckschwein.files.wordpress.com/2014/07/fa076-spi.png">&lt;img src="images/fa076-spi.png" alt="">&lt;/a>&lt;/p></content></item></channel></rss>