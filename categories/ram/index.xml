<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ram on Steckschwein</title><link>https://www.steckschwein.de/categories/ram/</link><description>Recent content in ram on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 04 May 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://www.steckschwein.de/categories/ram/index.xml" rel="self" type="application/rss+xml"/><item><title>Logikanalyse II [UPDATE]</title><link>https://www.steckschwein.de/post/logikanalyse-ii/</link><pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/logikanalyse-ii/</guid><description>Inzwischen sind die 74F00 eingetroffen und der 74HCT00 durch einen ebensolchen ersetzt. Das Oszilloskopbild sieht gleich deutlich besser aus:
gelb: /WE, blau: A9
Der Schreibvorgang wird also jetzt zumindest abgeschlossen, bevor sich die Adresse auf dem Adressbus ändert. Das ist schonmal viel sauberer.
Nur leider hat es das Problem nicht gelöst, das Steckschwein läuft mit den &amp;ldquo;richtigen&amp;rdquo; RAMs immer noch instabil, was sich insbesondere bei BASIC-Programmen bemerkbar macht:
Wäre auch zu einfach gewesen.</description><content>&lt;p>Inzwischen sind die 74F00 eingetroffen und der 74HCT00 durch einen ebensolchen ersetzt. Das Oszilloskopbild sieht gleich deutlich besser aus:&lt;/p>
&lt;p>&lt;img src="images/tekway449_3.gif" alt=""> gelb: /WE, blau: A9&lt;/p>
&lt;p>Der Schreibvorgang wird also jetzt zumindest abgeschlossen, bevor sich die Adresse auf dem Adressbus ändert. Das ist schonmal viel sauberer.&lt;/p>
&lt;p>Nur leider hat es das Problem nicht gelöst, das Steckschwein läuft mit den &amp;ldquo;richtigen&amp;rdquo; RAMs immer noch instabil, was sich insbesondere bei BASIC-Programmen bemerkbar macht:&lt;/p>
&lt;p>&lt;img src="images/photo_2017-05-04_19-56-29.jpg" alt="photo_2017-05-04_19-56-29">&lt;/p>
&lt;p>Wäre auch zu einfach gewesen.&lt;/p>
&lt;p>&lt;strong>[UPDATE]&lt;/strong> Ein weiterer Test mit anderen 55ns-SRAMs, nämlich Bausteinen von BSI im TSOP28-Gehäuse auf DIP28-Adaptern, lief problemlos durch. Das BASIC-Programm, mit dem wir testen, lief 2 Tage problemlos durch. Dies ist insofern bemerkenswert, als dass das Steckschwein mit diesen Bausteinen vorher überhaupt nicht lief. Also doch ein Erfolg. Warum die 55ns-Chips von Alliance Memory Probleme machen, müssen wir noch untersuchen.&lt;/p>
&lt;p>&lt;img src="images/photo_2017-05-06_19-57-10.jpg" alt=""> TSOP28-SRAMs auf DIP28 Adapter&lt;/p></content></item><item><title>Logikanalyse</title><link>https://www.steckschwein.de/post/logikanalyse/</link><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/logikanalyse/</guid><description>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.
Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.
Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2.</description><content>&lt;p>Auf dem VCFe 18.0 gab es Dank Nick Müller die Möglichkeit, das Steckschwein mal mit einem Logic Analyzer &amp;ldquo;für große Jungs&amp;rdquo; zu untersuchen. Unsere USB-Logic-Analyzer sind zwar für vieles gut, aber um komplett Adress- und Datenbus sowie einschlägiger Steuerleitungen abzuhorchen, fehlen einfach Kanäle, und selbst dann wären sie nicht schnell genug.&lt;/p>
&lt;p>&lt;img src="images/logic_analyzer.jpg" alt=""> Das Steckschwein am Logic Analyzer. im Hintergrund Nicks Finger.&lt;/p>
&lt;p>Die Gelegenheit, ein solches Höllengerät (genauer: ein HP 1652B) und mit Nick auch noch jemanden greifbar zu haben, der selbiges beherrscht, gibt uns die Chance, ein merkwürdiges Problem zu untersuchen, welches schon länger Rätsel aufgibt: Die aktuell verwendeten Hyundai-SRAMs sind mit einer Zugriffszeit von 100ns eigentlich viel zu langsam für 8MHz, zumal der 6502 ja nur die 2. Takthälfte für Buszugriffe nutzt. Diese ist nur 62,5ns lang. Von dieser Zeit geht ausserdem noch die Durchlaufzeit der Adressdekodierung und weiterer Glue-Logik ab. Eigens angeschaffte neue SRAMs von Alliance Memory mit 55ns Zugriffszeit sollten also ganz knapp schnell genug sein. Trotzdem treten mit diesen immer wieder merkwürdig zufällige Abstürze auf, die 100ns-Chips laufen dagegen problemlos.&lt;/p>
&lt;p>Also ran an die Maschine. Hierbei zeigte sich auch schon schnell etwas Merkwürdiges:&lt;/p>
&lt;p>&lt;img src="images/we_addr.png" alt=""> Analyse von Adress- und Datenbus sowie Steuersignale&lt;/p>
&lt;p>Es fiel etwas unangenehm auf, dass die steigende Flanke von /WE (Ende des Schreibzugriffs) direkt mit der Änderung des Adressbus zusammenfällt. Idealerweise sollte der Schreibzugriff beendet sein, bevor am Adressbus eine andere Adresse anliegt. Das Datenblatt nennt die Zeitspanne zwischen der steigenden Flanke von /WE und einer Änderung auf dem Adressbus tWR (Write Recovery Time):&lt;/p>
&lt;p>&lt;img src="images/sram_timing.png" alt="sram_timing">&lt;/p>
&lt;p>Laut Diagramm soll also /WE high werden, &lt;strong>bevor&lt;/strong> sich der Adressbus ändert. Im Datenblatt selbst ist die Write Recovery Time mit 0ns angegeben, und zwar bei beiden SRAMs, die 100ns-Typen sowie bei den 55ns-Bausteinen. Das würde bedeutet, dass die steigende Flanke von /WE mit einer Änderung der Adresse zeitlich zusammenfallen darf. Der verwendete Logicanalyzer hat eine Auflösung von 10ns, sodass man eigentlich nur sagen kann, dass sich /WE und der Adressbus im selben Zeitraum von 10ns ändern. Also schauen wir uns /WE und eine zufällige Adressleitung nochmal unterm Oszilloskop an.&lt;/p>
&lt;p>&lt;img src="images/oszi.jpg" alt=""> /WE und A9 unterm Oszilloskop. Gelb: /WE, Blau: A9&lt;/p>
&lt;p>Offenbar ändert sich der Adressbus, &lt;strong>bevor&lt;/strong> mit der steigenden Flanke von /WE der Schreibzugriff endet! Einen ausreichend schnellen Chip vorausgesetzt, könnte der anliegende Schreibzugriff womöglich in die neue Adresse hereingeschleppt werden. Wie dem auch sei, auf jeden Fall etwas, das so nicht sein darf! Wir halten die 0ns Write Recovery Time nicht ein, indem wir sie um ca. 4ns unterschreiten.&lt;/p>
&lt;p>/OE und /WE für die RAMs wird bei uns durch 3 NAND-Gatter in einem 74HCT00 aus der r/W-Leitung und dem Systemtakt erzeugt. Ein 74HCT00 hat eine Durchlaufzeit von ca. 9ns. Als nächstes werden wir also stattdessen einen 74F00 verwenden, der uns mit 3.7ns Durchlaufzeit wieder in den Bereich tWR &amp;gt; 0ns bringen sollte. Sollte es das nicht bringen, werden wir uns etwas grundsätzlichere Gedanken machen müssen.&lt;/p></content></item><item><title>Chiptuning</title><link>https://www.steckschwein.de/post/chiptuning/</link><pubDate>Sat, 30 Jan 2016 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/chiptuning/</guid><description>An den Heimcomputern von &amp;ldquo;damals&amp;rdquo; gemessen ist das Steckschwein mit 4 MHz durchaus einer der schnelleren 6502-Rechner. Damals waren zumeist Taktraten von 1 MHz üblich. Einige wenige hatten deutlich mehr, wie z.B. der Apple IIgs (65816) mit 2.8 MHz. Einen 4 MHz-65(C)02-Heimcomputer hat es damals nach unserem Informationsstand nicht gegeben.
Nun ist es aber so, dass aktuell erhältliche 65c02-CPUs von WDC offiziell mit bis zu 14MHz getaktet werden können, inoffiziell wurden schon problemlos Taktraten von 20 MHz erreicht.</description><content>&lt;p>An den Heimcomputern von &amp;ldquo;damals&amp;rdquo; gemessen ist das Steckschwein mit 4 MHz durchaus einer der schnelleren 6502-Rechner. Damals waren zumeist Taktraten von 1 MHz üblich. Einige wenige hatten deutlich mehr, wie z.B. der Apple IIgs (65816) mit 2.8 MHz. Einen 4 MHz-65(C)02-Heimcomputer hat es damals nach unserem Informationsstand nicht gegeben.&lt;/p>
&lt;p>Nun ist es aber so, dass aktuell erhältliche 65c02-CPUs von WDC offiziell mit bis zu 14MHz getaktet werden können, inoffiziell wurden schon problemlos Taktraten von 20 MHz erreicht. Da ist also noch Raum für eine Prise Größenwahn. Den Takt des Steckschweins pauschal zu erhöhen funktioniert nicht. Zu viele Bausteine kommen dann nicht mehr mit. Das verwendete Atmel 28c256 EEPROM hat eine Zugriffszeit von 150ns. Im WDC-Datenblatt ist tACC des Prozessors bei 4MHz mit 145ns angegeben. Also ist das stand jetzt schon etwas eng. Schneller takten geht also schon allein deswegen auf keinen Fall. Für den Videochip TMS9929 und den Soundchip gilt ähnliches. Das SRAM hingegen läßt sich problemlos gegen Bausteine von Alliance Memory mit 55ns Zugriffzeit austauschen. Damit sollten Taktraten von um die 10 MHz möglich sein.&lt;/p>
&lt;p>Was wir also brauchen ist eine Möglichkeit, auf RAM und VIA (sofern auch WDC und damit gleich schnell)  mit voller Geschwindigkeit zuzugreifen, währen wir den Prozessor bei Zugriffen auf ROM, Video- und Soundchip für 1-2 Zyklen stoppen. Schließlich ist man geschätzt zu 99% im RAM unterwegs.&lt;/p>
&lt;p>Erste Überlegungen gingen in die Richtung, die Taktfrequenz umschaltbar zu machen, je nachdem, welcher Baustein auf dem Bus von der CPU angesprochen wird. Dieses Prinzip birgt zwei entscheidende Nachteile:&lt;/p>
&lt;ol>
&lt;li>Man darf den Takt nicht einfach so umschalten. Erwischt man einen ungünstigen Moment, kann dies die CPU zum Absturz bringen. Näheres kann in einem &lt;a href="http://www.6502.org/mini-projects/clock-switching/clock-switching.html">entsprechenden Artikel auf 6502.org&lt;/a> nachgelesen werden.&lt;/li>
&lt;li>Die VIA-Timer sind direkt abhängig von der Taktfrequenz. Software, die diese benutzt, könnte sich nicht mehr auf diese verlassen, wenn sich die Taktfrequenz ständig ändert.&lt;/li>
&lt;/ol>
&lt;p>Zum Glück bietet der 6502 auch hier genau das, was wir brauchen: Den RDY-Pin. Wird dieser auf LOW gezogen, &amp;ldquo;friert&amp;rdquo; der 6502 ein. Kehrt RDY wieder auf HIGH zurück, macht die CPU dort weiter, wo sie unterbrochen wurde. Durch geschicktes Ansteuern dieser Leitung können wir den Prozessor also veranlassen, auf langsamere Bausteine zu warten. Dieses Konzept nennt sich Wait States (eben Wartezyklen) und ist bei aktuellen Computern gang und gäbe.&lt;/p>
&lt;p>Im Grunde genommen brauchen wir also einen Zähler, der die Taktfrequenz des Systems herunterteilt, und eine Selektionslogik, über die sich wählen läßt, welcher Ausgang des Zählers die Grundlage für das RDY-Signal bilden soll, und damit die Anzahl der Wait States bestimmt. Dieses Signal bildet invertiert das RDY-Signal.&lt;/p>
&lt;p>&lt;img src="images/tekway331_2.gif" alt=""> Gelb: RDY, Blau: PHI2 (Systemtakt) - 2 Wait States für den Videochip&lt;/p>
&lt;p>Zur folgender Logik haben wir uns vom &lt;a href="http://sbc.rictor.org/parts/wsgen.html">Waitstate-Generator von Daryl Rictor&lt;/a>  stark inspirieren lassen. Im Wesentlichen haben wir die Adressdekoderlogik zugunsten der bereits ausdekodierten /CS_&amp;hellip; Leitungen entfernt, sowie die Syntax von CUPL nach GALasm überführt.&lt;/p>
&lt;p>&lt;img src="images/img_20160130_144611.jpg" alt=""> Waitstate-Generator-Prototyp auf dem Steckbrett&lt;/p>
&lt;p>Folgende Schaltung erzeugt entsprechend 1 oder 2 Waitstates, und versetzt den Ausgangspin in den Tri-State-Zustand, damit auch andere Bausteine Wait-States anfordern können. Sollten einmal mehr Waitstates nötig werden, lassen sich noch 1 oder 2 Zählerstufen hinzufügen, um 4 oder 8 Waitstates zu erzeugen.&lt;/p>
&lt;pre tabindex="0">&lt;code>GAL16V8
RDYGEN
Clock ROM VIA UART VDP SND NC NC Clear GND
/OE RDY W1 W2 NC NC NC Q1 Q0 VCC
W2 = ROM \* VIA \* UART \* SND \* /VDP
+ ROM \* VIA \* UART \* /SND \* VDP
W1 = W2
+ /ROM \* VIA \* UART \* VDP
Q0.R = W1 \* /Q0 \* /Q1 \* Clear
+ W2 \* /Q0 \* /Q1 \* Clear
Q1.R = W2 \* /Q1 \* Q0 \* Clear
RDY.T = /Q0 \* /Q1
RDY.E = W1
&lt;/code>&lt;/pre>&lt;p>DESCRIPTION:
Generation of /RDY line modeled after &lt;a href="http://sbc.rictor.org/parts/wsgen.html">http://sbc.rictor.org/parts/wsgen.html&lt;/a>
and adapted to galasm syntax&lt;/p>
&lt;p>Wir freuen uns jetzt über ein 8MHz-Steckschwein. Das Tolle ist, dass die VIA ebenfalls mit 8 MHz und ohne Waitstates betrieben werden kann, sodass sich die erhöhte Geschwindigkeit 1:1 auf den SPI-Bus auswirkt. Zugriffe auf die SD-Karte sind damit gleich doppelt so schnell.&lt;/p></content></item><item><title>ROM an, ROM aus</title><link>https://www.steckschwein.de/post/rom-an-rom-aus/</link><pubDate>Sun, 26 Oct 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/rom-an-rom-aus/</guid><description>Nachdem wir also mit dem Adressdecoder durchaus zufrieden sind, müssen wir uns noch einen Weg überlegen, die /ROMOFF-Leitung per Software steuerbar zu machen. Wenn es schon beim BIOS-Update Test äußerst nützlich ist einfach nur eine Brücke umzustecken und damit das ROM zu deaktivieren, wie praktisch muss es erst sein, dies einfach durch Beschreiben einer Speicherstelle zu tun.
Was wir also brauchen, ist ein IO-Pin, der die /ROMOFF-Leitung steuert. Zusätzlich muss dieser Pin beim Einschalten des Systems einen definierten Zustand haben, damit sichergestellt ist, daß zu diesem Zeitpunkt das ROM eingeblendet ist.</description><content>&lt;p>Nachdem wir also mit dem Adressdecoder durchaus zufrieden sind, müssen wir uns noch einen Weg überlegen, die /ROMOFF-Leitung per Software steuerbar zu machen. Wenn es schon beim BIOS-Update Test äußerst nützlich ist einfach nur eine Brücke umzustecken und damit das ROM zu deaktivieren, wie praktisch muss es erst sein, dies einfach durch Beschreiben einer Speicherstelle zu tun.&lt;/p>
&lt;p>Was wir also brauchen, ist ein IO-Pin, der die /ROMOFF-Leitung steuert. Zusätzlich muss dieser Pin beim Einschalten des Systems einen definierten Zustand haben, damit sichergestellt ist, daß zu diesem Zeitpunkt das ROM eingeblendet ist. Passende Pins finden wir an der VIA und am UART. Die Portpins der VIA beispielsweise sind initial als Eingänge geschaltet und per internem Pullup high. Auch die OUT1 und OUT2-Pins des UART sind initial high. Gegen den UART-Ansatz spricht, dass sich diese Pins  nur über ein Write-Only-Register setzen lassen und es keine Möglichkeit gibt, den Zustand dieser Pins über irgendein UART-Register abzufragen.&lt;/p>
&lt;p>Der VIA-Ansatz hat den Nachteil, dass die Pins zwar einen definierten Zustand haben, dies aber nur &amp;ldquo;zufällig&amp;rdquo;, weil die VIA-Pins initial immer als Eingang definiert sind und damit nach &amp;ldquo;außen&amp;rdquo; Hi werden. Außerdem sind die Ports der VIA alle verplant. Port B ist vollständig für SPI vorgesehen, Port A stellt die Joystickports. Sicher wäre es möglich, von Port B einen SPI_SS abzuknapsen, doch so richtig sauber wäre das nicht.&lt;/p>
&lt;p>Besser für eine richtig saubere Lösung wäre also eine dedizierte Schaltung, die folgendes erfüllen soll: - Einen Pin mit definiertem Ausgangszustand - Dieser soll durch Schreiben in eine Speicherstelle verändert werden können - Der Zustand soll durch Lesen der Speicherstelle ermittelt werden können - Es soll kein vorhandener Chip (VIA, UART, ..) missbraucht werden&lt;/p>
&lt;p>Kurz: Wir wollen einen dedizierten Ausgabeport in den Adressraum bzw. IO-Bereich einblenden. Der ideale Baustein hierfür wäre ein 8bit Tri-State Latch mit Reset. Einen Baustein, der all das kann, finden wir nicht. Die nächstbeste Möglichkeit wäre ein 74hct273, einem 8bit-Latch mit Reset, dem wir einen 74hct244-Buffer vorschalten, um ihn vom Bus zu nehmen, wenn er nicht selektiert ist. Leider befindet sich kein 74hct273 in der Bastelkiste, sodass erste Experimente mit einem Flipflop aus einem 74ls74 und einem Tri-State-Buffer im für das SD-Karten-Interface bereits verbauten 74hct125 stattfinden müssen. Sozusagen die kleine Variante mit nur einem Bit.&lt;/p>
&lt;p>&lt;strong>Update:&lt;/strong> Nach reiflicher Überlegung kann auf den Buffer auch verzichtet werden. Das Latch legt ja nur Eingänge auf den Bus, und tut nur etwas, wenn es per /CS eine CLK-Flanke bekommt. Also rationalisieren wir den Buffer weg und sparen einen Chip.&lt;/p>
&lt;p>&lt;img src="images/screen-2bshot-2b2014-10-26-2bat-2b16-33-081.png" alt="screen-2bshot-2b2014-10-26-2bat-2b16-33-081">&lt;/p>
&lt;p>/MEMCTL haben wir den IO-Select-Pin des GAL genannt. Mit dieser Verdrahtung ist es nun möglich, das Flipflop durch Beschreiben einer Speicherstelle zu kippen. Was noch fehlt, ist die Möglichkeit, den Zustand des Ports auslesen zu können.&lt;/p>
&lt;p>Ein Ansatz wäre, den Ausgang des Flipflop über einen weiteren Buffer wieder an den Datenbus zu koppeln und abhängig davon, ob gelesen oder geschrieben wird, den einen oder andere Buffer zu aktivieren. Dies würde aber zusätzliche Logik erfordern. Ein Ansatz mit geringerem Chipcount ist uns lieber. Wie wäre es, wenn wir für Schreibzugriffe an diesen Port nicht nur das Latch, sondern auch das darunterliegende RAM selektieren? Das geschriebene Byte würde somit im RAM gespiegelt. Dann müßte nur noch sichergestellt werden, dass das Latch nur noch bei Schreibzugriffen selektiert wird, sodass Lesezugriffe nur noch im RAM landen. Dies erfordert Anpassungen an der Dekoderlogik im GAL:&lt;/p>
&lt;p>/MEMCTL = /A15*/A14*/A13*/A12 * /A11*/A10*A9*/A8 * A7*A6*A5*A4 * /RW ; $02f0&lt;/p>
&lt;p>Wir legen unsere /MEMCTL-Leitung so weit wie möglich ans Ende des IO-Bereichs, und beziehen RW mit in den Term ein. Der Term für LORAM muss auch angepasst werden, damit $02f0 nicht mehr teil des reinen IO-Blocks ist. Hierzu nehmen wir A7 mit in den Term auf, was den IO-Bereich verkleinert (halbiert), sodass dieser an $027F endet. Mehr IO-Pins haben wir ohnehin nicht. Gleichzeitig haben wir noch Reserven im Adressraum, falls wir doch mal einen Block größer 16 Byte brauchen.&lt;/p>
&lt;p>Vorher CSLORAM = /A14 * /A13 * /A12 * /A11 * /A10 * A9 * /A8 + A15&lt;/p>
&lt;p>Nachher&lt;/p>
&lt;p>CSLORAM = /A14 * /A13 * /A12 * /A11 * /A10 * A9 * /A8 * /A7 + A15&lt;/p>
&lt;p>Hiermit hat sich die Speicherbelegung wie folgt verändert.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Bereich&lt;/th>
&lt;th>Was&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$0000 - $01ff&lt;/td>
&lt;td>RAM (Zeropage und Stack)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0200 - $027f&lt;/td>
&lt;td>IO-Bereich&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0280 - $02ef&lt;/td>
&lt;td>RAM (reserviert)*&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$02f0 - $02ff&lt;/td>
&lt;td>MEMCTL-Register&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0300 - $dfff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$e000 - $ffff&lt;/td>
&lt;td>ROM (ausblendbar)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>* Das RAM an dieser Stelle ist im Grunde nutzbar, da wir aber Stand heute noch nicht wissen, ob dort später nicht doch noch IO-Adressen gemappt werden, deklarieren wir diesen Bereich als &amp;ldquo;reserviert&amp;rdquo;.&lt;/p>
&lt;p>Jetzt fehlen nur noch die &amp;ldquo;richtigen&amp;rdquo; Chips, um das Ganze 8bit breit umzusetzen.&lt;/p>
&lt;p>Von den jetzt noch freien 7 Bit des so entstandenen &amp;ldquo;Memctl-Register&amp;rdquo; (nennen wir es ruhig so) verbinden wir Bit 1 und Bit 2 mit den Adressleitungen A13 und A14 des ROM, die vorher hart auf Masse lagen. Damit haben wir die Möglichkeit, die kompletten 32K des ROM zu nutzen, auch wenn wir aktuell noch nicht genau wissen, wofür :-). Aber so ist dann schonmal nichts verbaut.&lt;/p>
&lt;p>Der kleine Schönheitsfehler dieser Lösung soll nicht verschwiegen werden: Der Inhalt des RAM ist beim Einschalten bekanntlich nicht definiert. Direkt nach dem Einschalten und bevor das erste Mal ins Register geschrieben wurde, lesen wir aus dem Register also alles, nur nicht den Zustand des Latch. Hier werden wir uns etwas Schlaues per Software überlegen müssen.&lt;/p></content></item><item><title>Dekoder, die Dritte</title><link>https://www.steckschwein.de/post/dekoder-die-dritte/</link><pubDate>Thu, 23 Oct 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/dekoder-die-dritte/</guid><description>Bekanntlich dekodiert unser GAL die oberen 8bit des Adressbus, um den Bereich $8000-$ffff unter RAM, IO-Bereich und ROM einzuteilen. Die unteren 32k werden am Decoder vorbei direkt von der Adressleitung A15 selektiert. Das Memory-Mapping, das sich daraus ergibt, ist - zur Wiederholung - wie folgt:
Bereich Was $0000 - $7fff RAM $8000 - $cfff RAM $d000 - $dfff IO-Bereich $e000 - $ffff ROM Die letzte Änderung am Decoder war, das ROM bei Bedarf ausblendbar zu machen.</description><content>&lt;p>Bekanntlich dekodiert unser GAL die oberen 8bit des Adressbus, um den Bereich $8000-$ffff unter RAM, IO-Bereich und ROM einzuteilen. Die unteren 32k werden am Decoder vorbei direkt von der Adressleitung A15 selektiert. Das Memory-Mapping, das sich daraus ergibt, ist - zur Wiederholung - wie folgt:&lt;/p>
&lt;p> &lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Bereich&lt;/th>
&lt;th>Was&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$0000 - $7fff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$8000 - $cfff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$d000 - $dfff&lt;/td>
&lt;td>IO-Bereich&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$e000 - $ffff&lt;/td>
&lt;td>ROM&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;a href="http://wordpress.steckschwein.de/wordpress/index.php/2014/07/01/noch-schlauerer-decoder/">Die letzte Änderung&lt;/a> am Decoder war, das ROM bei Bedarf ausblendbar zu machen. Dieser Mechanismus hat sich beim Test von BIOS-Updates als pures Gold erwiesen, da man ums neu Brennen des EEPROM herumkommt. Das spart Zeit und schont Material.&lt;/p>
&lt;p>Trotzdem sehen wir noch viel Raum für Verbesserungen. Insbesondere im IO-Bereich hätten wir gerne mehr Granularität. Aktuell verschenken wir ganze 4K, jedes IO-Device bekommt eine ganze 256 byte-Page zugeschustert. Die meisten Chips  in dem Bereich haben gerade mal eine Handvoll Register.&lt;/p>
&lt;p>Würden wir nicht nur die oberen 8, sondern 12 bit des Adressbus dekodieren, hätten wir 16byte-Blöcke für IO-Devices. Wir würden mit einer 256byte-Page mehr als locker auskommen. Der Chip mit den meisten Registern ist unsere 65c22 VIA mit genau 16 Stück. Alle anderen haben weit weniger. Passt also.&lt;/p>
&lt;p>Bei der Gelegenheit bereinigen wir das Pinout des GAL, indem wir die Glue-Logic für das LCD rauswerfen. Dadurch brauchen wir im Decoder auch kein PHI2 mehr, was uns einen freien Eingang zurückgibt, und die /CS-Pins sind alle gleichförmig active low. Die Sonderlocke E_LCD muss jetzt aus /CSIO in einem 7400 extern generiert werden.&lt;/p>
&lt;p>&amp;mdash;&amp;mdash;-___/&amp;mdash;&amp;mdash;-&lt;/p>
&lt;p>A15 |  1           24 | VCC&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A14 |  2           23 | CSIO&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A13 |  3           22 | CSSND&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A12 |  4           21 | CSVDP&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A11 |  5           20 | CSVIA&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A10 |  6           19 | CSUART&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A9 |  7           18 | CSHIRAM&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A8 |  8           17 | CSLORAM&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A7 |  9           16 | CSROM&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A6 | 10           15 | ROMOFF&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>A5 | 11           14 | RW&lt;/p>
&lt;p>|                 |&lt;/p>
&lt;p>GND | 12           13 | A4&lt;/p>
&lt;hr>
&lt;p>Wer genau hinschaut, erkennt, dass /CSHIRAM ein Pendant bekommen hat: /CSLORAM.&lt;/p>
&lt;p>Hintergrund ist, dass wir uns entschieden haben, den IO-Bereich &amp;ldquo;nach unten&amp;rdquo; zu verschieben, und zwar nach $0200, direkt über den Stack. Damit ist das RAM von $0300 bis $dfff komplett nutzbar. Blendet man das ROM aus, lassen sich die kompletten 64k minus 768 bytes für Zeropage, Stack und IO vollständig nutzen. Ein IO-Bereich mittendrin bei $d000 würde da stören.&lt;/p>
&lt;p>Wie eingangs erwähnt wurde der RAM-Baustein für $0000-$7fff direkt über die A15 selektiert. Würde der GAL so den IO-Bereich nach $0200 blenden, wären dort dann der selektierte IO-Baustein und das RAM selektiert, was zumindest bei Lesezugriffen nicht funktionieren kann. Folglich muss der GAL auch das CS für das untere RAM kontrollieren.&lt;/p>
&lt;p>Die Gleichung sieht folgendermaßen aus:&lt;/p>
&lt;p>CSLORAM = /A14 * /A13 * /A12 * /A11 * /A10 * A9 * /A8 + A15&lt;/p>
&lt;p>Als äußerst hilfreich hat sich übrigens die App &lt;a href="https://play.google.com/store/apps/details?id=com.flx.flxkarnaugh&amp;amp;hl=de">FLXKarnaugh&lt;/a> erwiesen. Die neue Memory-Map sieht also so aus:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Bereich&lt;/th>
&lt;th>Was&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$0000 - $01ff&lt;/td>
&lt;td>RAM (Zeropage und Stack)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0200 - $02ff&lt;/td>
&lt;td>IO-Bereich&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0300 - $dfff&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$e000 - $ffff&lt;/td>
&lt;td>ROM (ausblendbar)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Für uns fühlt sich das Design jetzt deutlich &amp;ldquo;sauberer&amp;rdquo; an. Der GAL hat die alleinige Kontrolle über den Adressraum, macht dafür aber auch nichts anderes als Adressdekodierung und wird nicht auch noch für Glue-Logic-Aufgaben missbraucht. A propos Glue Logic - die Ausgänge des GAL reichen nur bis Adresse $0240, also demultiplexen wir /CSIO, indem wir es als Enable für ein 74ls139 verwenden, und A4 und A5 dort dekodieren. Damit erhalten wir 3 weitere CS-Pins für IO-Komponenten und haben immer noch Platz im IO-Bereich.&lt;/p>
&lt;p>Als nächstes wollen wir uns einen Weg überlegen, die /ROMOFF-Leitung per Software zu steuern.&lt;/p></content></item><item><title>Noch schlauerer Decoder</title><link>https://www.steckschwein.de/post/noch-schlauerer-decoder/</link><pubDate>Tue, 01 Jul 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/noch-schlauerer-decoder/</guid><description>Wir sind jetzt also fast in der Lage, das RAM unter dem ROM zu nutzen. Hineinschreiben geht, lesen noch nicht. Da ist das ROM noch im Weg. Wir müssen also einen Weg finden, die GAL-Logik von außen zu beeinflussen. Unser GAL hat noch genügend Eingänge, sodass wir einen Pin zum ROM-Ein-/Ausschalter machen wollen. Lesezugriffe nach $e000-$ffff sollen also nur noch dann im ROM landen, wenn es &amp;ldquo;eingeschaltet&amp;rdquo; ist. Sonst wollen wir ins RAM.</description><content>&lt;p>Wir sind jetzt also fast in der Lage, das RAM unter dem ROM zu nutzen. Hineinschreiben geht, lesen noch nicht. Da ist das ROM noch im Weg. Wir müssen also einen Weg finden, die GAL-Logik von außen zu beeinflussen. Unser GAL hat noch genügend Eingänge, sodass wir einen Pin zum ROM-Ein-/Ausschalter machen wollen. Lesezugriffe nach $e000-$ffff sollen also nur noch dann im ROM landen, wenn es &amp;ldquo;eingeschaltet&amp;rdquo; ist. Sonst wollen wir ins RAM. Die wiederum erweiterte Logik im GAL sieht jetzt so aus:&lt;/p>
&lt;p>/CSHIRAM = G1*/A2                                 + G1*/A1*/A0          + /RW*G1*A2*A1 ; Writes to $e000-$ffff go to the RAM          + /ROMOFF*RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the RAM, IF ROMOFF is Low /CSROM   = ROMOFF*RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the ROM, IF ROMOFF is High ROMOFF haben wir Pin 13 des GAL zugeordnet. Und tatsächlich startet unser Steckschwein nur noch, wenn dieser PIN mittels eines PullUp-Widerstands nach High gezogen wird.  Lassen wir unser Testprogramm aus dem letzten Post nochmal laufen:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Das gewohnte Bild, Lesezugriff geht ins ROM, Schreibzugriff ins RAM. Jetzt ziehen wir ROMOFF auf Masse und schalten damit das ROM aus:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Volltreffer, das ROM wird nicht mehr selektiert, wir landen immer im RAM. ROMOFF müssen wir jetzt nur noch per Software steuerbar machen, und unser nutzbares RAM hat sich um 8k erweitert, sofern wir in Kauf nehmen, dass wir keine ROM-Routinen verwenden können, solange wir dort lesen. Aber das ist beim C64 ja auch nicht anders. Ein konkreter Verwendungszweck der neuen Dekoderlogik drängt sich bereits auch ohne Softwaresteuerung der ROMOFF-Leitung auf: Das Testen neuer Versionen des ROM-Code(BIOS) ohne jedesmal das EEPROM brennen zu müssen. Schon richtig modern. Als abschließendes Experiment verbinden wir ROMOFF mit dem Bit0 von Port A der VIA. Die VIA hat die angenehme Eigenschaft, dass ihre Ports im Urzustand immer als Eingänge geschaltet sind und die Pins durch interne Pullups auf H gezogen werden. Um jetzt aus dem RAM ab $e000 zu lesen, brauchen wir nur Bit 0 von Port A der VIA zu löschen. Folgendes Programm testet, ob das auch so klappt: lda #000001         sta via1porta ; Pin 0 von Port A auf 1 setzen -&amp;gt; ROM ein         sta via1ddra  ; Pin 0 von Port A als Ausgang setzen lda #$00         ldx #$42         stx $e000     ; $42 landet im RAM dec via1porta ; Pin 0 von Port A ist jetzt 0 -&amp;gt; ROM  aus         lda $e000     ; $42 aus dem RAM lesen         inc via1porta ; -&amp;gt; ROM ein jsr lcdhex&lt;/p>
&lt;p>&amp;hellip; und auf dem LCD erscheint die $42. Freude.&lt;/p></content></item><item><title>Schlauer(er) Decoder</title><link>https://www.steckschwein.de/post/schlauerer-decoder/</link><pubDate>Tue, 01 Jul 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/schlauerer-decoder/</guid><description>Im Rahmen unserer Reihe &amp;ldquo;Kleine Verbesserungen an der Architektur&amp;rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:</description><content>&lt;p>Im Rahmen unserer Reihe &amp;ldquo;Kleine Verbesserungen an der Architektur&amp;rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:&lt;/p>
&lt;p>/CSHIRAM = G1*/A2                          + G1*/A1*/A0 /CSROM   = G1*A2                  Wir machen also die CS-Signale statisch von der anliegen Adresse abhängig. Aber es sollte doch möglich sein, grundsätzlich auch zwischen Reads und Writes auf die entsprechenden Adressen zu unterscheiden, oder? Die /RW-Leitung des Prozessors liegt ohnehin am GAL an. Was spricht dagegen, Lesezugriffe nach $e000-$ffff aus dem ROM zu holen, Schreibzugriffe aber immer ins RAM zu leiten? Der C64 kann das schließlich auch. Schreiben wir ein kleines Testprogramm:&lt;/p>
&lt;p>main ldx #$00 loop lda $e000,x sta $e000,x inx cpx #$ff bne loop jmp main&lt;/p>
&lt;p>Wir lesen also aus dem ROM-Bereich und schreiben gleich wieder zurück. Das Oszilloskop zeigt uns /CSHIRAM (gelb) und /CSROM (blau):&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Die Schreibzugriffe landen erwartungsgemäß nicht im RAM, dieses wird zu keiner Zeit selektiert.&lt;/p>
&lt;p>Jetzt passen wir die Gleichungen für /CSHIRAM und /CSROM an, indem wir die Abhängigkeit von /RW berücksichtigen:&lt;/p>
&lt;p>/CSHIRAM = G1*/A2&lt;/p>
&lt;ul>
&lt;li>
&lt;p>G1*/A1*/A0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/RW*G1*A2*A1 ; Writes to $e000-$ffff go to the RAM&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>/CSROM   = RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the ROM&lt;/p>
&lt;p>Und jetzt lassen wir unser Programm nochmal laufen:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Wir erkennen einen Lesezugriff (/CSROM, LDA $e000,x) und direkt darauf einen Schreibzugriff ins RAM (/CSHIRAM, STA $e000,x).&lt;/p>
&lt;p>Hurra, schreiben wir jetzt &amp;ldquo;ins ROM&amp;rdquo;, landen unsere Schreibzugriffe automatisch im darunterliegenden RAM. Allerdings nützt uns das noch nichts, denn noch können wir aus dem RAM nicht lesen.&lt;/p>
&lt;p>Im nächsten Teil erweitern wir also die GAL-Logik um einen Steuerpin, mit dem wir das ROM vollständig ausblenden und das RAM entsprechend freilegen können.&lt;/p></content></item><item><title>... kein Spaß - Murphy schlägt zu</title><link>https://www.steckschwein.de/post/kein-spass-murphy-schlaegt-zu/</link><pubDate>Mon, 31 Mar 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/kein-spass-murphy-schlaegt-zu/</guid><description>Neben all den ermutigenden Experimenten gibt es natürlich auch immer mal wieder Rückschläge. Mittlerweile haben wir schon ein durchaus komplexes Gebilde auf dem Steckbrett, welches ja per se nicht die ideale Plattform ist, um so etwas zu bauen.
So wie aktuell gerade mein &amp;ldquo;Steckschwein&amp;rdquo; ein sehr merkwürdiges Verhalten an den Tag legt, ohne dass an der Schaltung etwas geändert worden wäre (Marko ist Zeuge).
Vorab nochmal der Ablauf unserer Upload-Routine, mit der wir das Steckschwein via RS232 mit Code befüttern:</description><content>&lt;p>Neben all den ermutigenden Experimenten gibt es natürlich auch immer mal wieder Rückschläge. Mittlerweile haben wir schon ein durchaus komplexes Gebilde auf dem Steckbrett, welches ja per se nicht die ideale Plattform ist, um so etwas zu bauen.&lt;/p>
&lt;p>So wie aktuell gerade mein &amp;ldquo;Steckschwein&amp;rdquo; ein sehr merkwürdiges Verhalten an den Tag legt, ohne dass an der Schaltung etwas geändert worden wäre (Marko ist Zeuge).&lt;/p>
&lt;p>Vorab nochmal der Ablauf unserer Upload-Routine, mit der wir das Steckschwein via RS232 mit Code befüttern:&lt;/p>
&lt;ol>
&lt;li>Transferprogramm sendet die Ladeaddresse (2 bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;li>Anzeige der Ladeaddresse im LCD&lt;/li>
&lt;li>Transferprogramm übermittelt die Länge der zu sendenden Daten (2 bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;li>Anzeige der Länge in Bytes im LCD&lt;/li>
&lt;li>Upload-Routine addiert Startaddresse + Länge in Bytes und errechnet so die Endadresse&lt;/li>
&lt;li>Anzeige der Endaddresse im LCD&lt;/li>
&lt;li>Transferprogramm sendet den Code (n bytes)&lt;/li>
&lt;li>Upload-Routine quittiert mit &amp;ldquo;OK&amp;rdquo;&lt;/li>
&lt;/ol>
&lt;p>Völlig unprovoziert wird auf einmal das &amp;ldquo;O&amp;rdquo; unterschlagen, sodass wir nur noch ein &amp;ldquo;K&amp;rdquo; erhalten. Dies läßt sich gut mit einem Terminalprogramm nachvollziehen. Um weiter debuggen zu können, passen wir das Transferprogramm an, dass es sich auch mit &amp;ldquo;K&amp;rdquo; zufriedengibt und laden eine echo-Routine, die die empfangenen Zeichen wieder über RS232 zurückschreibt und außerdem auf dem Display ausgibt.&lt;/p>
&lt;p>Wir beobachten, wie einige Zeichen wieder ge-echo-t werden, andere nicht, während sie nebst einigem Müll sowie der Ziffer 0 auf dem Display ausgegeben werden.&lt;/p>
&lt;p>Ein ähnliches Phänomen haben wir schon beim Einbau/Programmierung des UART beobachtet. Damals war der Fehler, dass die FIFO aktiviert war. Da wir den UART aktuell nur mittels Polling betreiben, gab es Probleme, die sich mit der Deaktivierung der FIFO beheben ließen. Das ist hier anders. Und zu allem Überfluss scheint das Phänomen zeitweilig auch wieder zu verschwinden. Will heissen: Ohne unser Zutun kam auch wieder ein &amp;ldquo;OK&amp;rdquo;. Dann wieder nicht mehr. Die zugegeben bis dato etwas windige Verdrahtung der Speicherchips wurde bei der Gelegenheit durch &amp;ldquo;richtige&amp;rdquo; Steckstrippen ersetzt. Die dabei entstandenen Fehler wurden schließlich auch gefunden, sodass wir mit einem Tag Verzug wieder so weit waren, das eigentliche Problem zu erforschen.&lt;/p>
&lt;p>Unsere Mem-Test-Routine läßt sich hochladen, zeigt aber immer denselben Fehler. Da wir nicht sicher sein können, ob die Routine tatsächlich korrekt hochgeladen wurde, macht weiteres Testen nur Sinn, wenn die dazu notwendigen Routinen bereits im ROM liegen.&lt;/p></content></item><item><title>Das Design wird erweitert</title><link>https://www.steckschwein.de/post/das-design-wird-erweitert/</link><pubDate>Sun, 16 Mar 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/das-design-wird-erweitert/</guid><description>Sinn der Sache ist ja nicht, etwas 1:1 nachzubauen, sondern ein möglichst eigenes Design. Nachdem wir mit Chris&amp;rsquo; Design - bzw. dessen, was wir davon übernommen haben (Adressdekodierung, ACIA, VIA) - genug herumgespielt hatten, galt es, &amp;ldquo;unser&amp;rdquo; Ding draus zu machen. Der erste Schritt war ein Sprung ins kalte Wasser in die uns bislang noch unbekannte Welt der Programmierbaren Logik. Dazu haben wir zunächst die Adressdekodierung bestehend aus 74ls138/74ls154 sowie etwas glue Logic in VHDL implementiert und auf ein GAL22V10D gebrannt.</description><content>&lt;p>Sinn der Sache ist ja nicht, etwas 1:1 nachzubauen, sondern ein möglichst eigenes Design. Nachdem wir mit Chris&amp;rsquo; Design - bzw. dessen, was wir davon übernommen haben (Adressdekodierung, ACIA, VIA) - genug herumgespielt hatten, galt es, &amp;ldquo;unser&amp;rdquo; Ding draus zu machen. Der erste Schritt war ein Sprung ins kalte Wasser in die uns bislang noch unbekannte Welt der Programmierbaren Logik. Dazu haben wir zunächst die Adressdekodierung bestehend aus 74ls138/74ls154 sowie etwas glue Logic in VHDL implementiert und auf ein GAL22V10D gebrannt. Somit haben wir 3 TTL-ICs durch einen GAL ersetzt und wieder Platz auf dem Steckbrett geschaffen. Und das Beste: Änderungen an der Dekodierungslogik laufen ab sofort minimalinvasiv.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Die erste Erweiterung ist ein /CS-Signal für den 2. 62256-Chip, der sich seinen Adressbereich mit 4k IO-Bereich und 8K ROM teilen darf und uns immerhin noch 20k nutzbares RAM beschert. Anfängliche Pläne, das unter dem ROM und IO liegende RAM nach Vorbild des C64 nutzbar zu machen stellen wir erstmal zurück. Zu viel Aufwand für lumpige 12k.&lt;/p>
&lt;p>Inzwischen gibt es auch eine rs232-Schnittstelle auf Basis einer 65x51 ACIA. Der vorliegende Chip kann mit max. 2MHz getaktet werden, daher ist der diskret aufgebaute 3MHz-Oszillator wieder arbeitslos. An seiner Stelle betaktet ein 2MHz-TTL-Oszillator unseren Rechner.&lt;/p>
&lt;p>Diese Begrenzung auf 2MHz gefällt uns nicht, eigentlich wollten wir den Rechner später so hoch wie möglich takten, auf jeden Fall mit 4MHz. Modernere CPUs sowie VIAs von WDC, die bis zu 14MHz Taktfrequenz vertragen, sind so gut wie geordert. Einzig die ACIA soll komplett durch einen moderneren Chip ersetzt werden, da sie uns nicht nur auf 2MHz, sondern auch auf 19200 baud begrenzt. Ein bisschen zu vintage, darum soll als nächtes die ACIA einem zeitgemäßeren Chip weichen.&lt;/p></content></item><item><title>Ein richtiger Computer soll es sein</title><link>https://www.steckschwein.de/post/ein-richtiger-computer-soll-es-sein/</link><pubDate>Sat, 15 Mar 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/ein-richtiger-computer-soll-es-sein/</guid><description>Nachdem die vorangegangenen Spielereien sehr ermutigend verliefen, war der nächste Schritt klar. Wenn wir so weit kommen, kommen wir auch noch weiter. Das Ziel ist jetzt definitiv ein funktionierender 8bit-Rechner mit 64k RAM.
Da der 6502 keinen DRAM-Refresh liefert und wir uns den Aufwand eines diskreten Refresh-Generators ersparen wollen, soll es ein SRAM-basiertes Design werden. Bei ein wenig Recherche beim Elektronik-Versenders unseres Vertrauens stellen wir fest, dass 2x32k*8 in Form von zwei 2 62256 eine komfortable Lösung sein würden.</description><content>&lt;p>Nachdem die vorangegangenen Spielereien sehr ermutigend verliefen, war der nächste Schritt klar. Wenn wir so weit kommen, kommen wir auch noch weiter. Das Ziel ist jetzt definitiv ein funktionierender 8bit-Rechner mit 64k RAM.&lt;/p>
&lt;p>Da der 6502 keinen DRAM-Refresh liefert und wir uns den Aufwand eines diskreten Refresh-Generators ersparen wollen, soll es ein SRAM-basiertes Design werden. Bei ein wenig Recherche beim Elektronik-Versenders unseres Vertrauens stellen wir fest, dass 2x32k*8 in Form von zwei 2 62256 eine komfortable Lösung sein würden. A15 würde den Chip mit den unteren 62256 selektieren, um alles oberhalb würde sich ein kleines TTL-Grab kümmern, denn irgendwo muss ja noch ein Bereich für verschiedene IO-Bausteine hin.&lt;/p>
&lt;p>Etwas mehr Recherche bei 6502.org bringt uns zum Projekt von Chris Ward (&lt;a href="http://www.chrisward.org.uk/6502/spec.shtml">http://www.chrisward.org.uk/6502/spec.shtml&lt;/a>), der eine simple und effektive Adressdekodierung hat, und die selben Ansätze bereits weiter gedacht hat. Zusätzlich zeigt er, wie simpel es ist, ein LCD-Display nach hd44780-Standard an den Datenbus zu klemmen. Also stellen wir uns auf die Schultern dieses Giganten, und beschließen, auf Basis dieses Designs weiterzumachen. Der 500Hz-Taktgeber weicht einem Quarzoszillator mit 3MHz, mehr verkraftet die verwendete VIA nicht. Die CPU könnte auch 4MHz.&lt;/p>
&lt;!-- raw HTML omitted --></content></item><item><title>Euphorie: Jetzt auch RAM!</title><link>https://www.steckschwein.de/post/euphorie-jetzt-auch-ram/</link><pubDate>Wed, 12 Feb 2014 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/euphorie-jetzt-auch-ram/</guid><description>Die Euphorie ob des Ausgangs des letzten Versuchs nutzend wird jetzt weitergebaut. Immerhin sind wir so nah an einem richtigen Computer. Was fehlt, ist RAM. Leider nichts im Haus.
Eine temporäre Organspende aus einem C64-Easyflash-Cartridge (Cooles Teil: http://skoe.de/easyflash/doku.php?id=start) verschafft uns ein 6264 SRAM. Dieses verdrahten wir analog zum EPROM, allerdings brauche es hier noch einen Hauch von Gatterlogik, um das EEPROM ans obere Ende des Adressraums zu mappen, während das SRAM in den unteren 8k lebt.</description><content>&lt;p>Die Euphorie ob des Ausgangs des letzten Versuchs nutzend wird jetzt weitergebaut. Immerhin sind wir so nah an einem richtigen Computer. Was fehlt, ist RAM. Leider nichts im Haus.&lt;/p>
&lt;p>Eine temporäre Organspende aus einem C64-Easyflash-Cartridge (Cooles Teil: &lt;a href="http://skoe.de/easyflash/doku.php?id=start">http://skoe.de/easyflash/doku.php?id=start&lt;/a>) verschafft uns ein 6264 SRAM. Dieses verdrahten wir analog zum EPROM, allerdings brauche es hier noch einen Hauch von Gatterlogik, um das EEPROM ans obere Ende des Adressraums zu mappen, während das SRAM in den unteren 8k lebt.&lt;/p>
&lt;p>Der Testcode wird um einige JSR und RTS erweitert (Stack!). Eine grüne LED an der RW-Leitung zeigt uns Schreibzugriffe an.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/zjhkhsHbYMg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></content></item></channel></rss>