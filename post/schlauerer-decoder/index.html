<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.ico><title>Schlauer(er) Decoder - Steckschwein</title><meta name=description content="Im Rahmen unserer Reihe &ldquo;Kleine Verbesserungen an der Architektur&rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:"><meta name=generator content="Hugo 0.101.0"><link rel=stylesheet href=https://steckschwein.github.io/css/main.css><meta property="og:title" content="Schlauer(er) Decoder"><meta property="og:description" content="Im Rahmen unserer Reihe &ldquo;Kleine Verbesserungen an der Architektur&rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:"><meta property="og:type" content="article"><meta property="og:url" content="https://steckschwein.github.io/post/schlauerer-decoder/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-07-01T00:00:00+00:00"><meta property="article:modified_time" content="2014-07-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Schlauer(er) Decoder"><meta name=twitter:description content="Im Rahmen unserer Reihe &ldquo;Kleine Verbesserungen an der Architektur&rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:"><meta itemprop=name content="Schlauer(er) Decoder"><meta itemprop=description content="Im Rahmen unserer Reihe &ldquo;Kleine Verbesserungen an der Architektur&rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:"><meta itemprop=datePublished content="2014-07-01T00:00:00+00:00"><meta itemprop=dateModified content="2014-07-01T00:00:00+00:00"><meta itemprop=wordCount content="313"><meta itemprop=keywords content><meta itemprop=name content="Schlauer(er) Decoder"><meta itemprop=description content="Im Rahmen unserer Reihe &ldquo;Kleine Verbesserungen an der Architektur&rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:"><meta itemprop=datePublished content="2014-07-01T00:00:00+00:00"><meta itemprop=dateModified content="2014-07-01T00:00:00+00:00"><meta itemprop=wordCount content="313"><meta itemprop=keywords content></head><body class="flex relative h-full min-h-screen"><aside class="will-change-transform transform transition-transform -translate-x-full absolute top-0 left-0 md:relative md:translate-x-0 w-3/4 md:w-60 h-full min-h-screen p-3 bg-slate-50 dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 flex flex-col gap-2.5 z-20 sidebar"><p class="font-bold mb-5 flex items-center gap-2"><button aria-label="Close sidebar" class="md:hidden menu-trigger-close p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-6 w-6" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
<a href=https://steckschwein.github.io class=px-2><span>Steckschwein</span></a>
<button aria-label="Toggle dark mode" class="dark-mode-toggle p-2 rounded border dark:border-slate-700 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-4 w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="4"/><path d="M3 12h1m8-9v1m8 8h1m-9 8v1M5.6 5.6l.7.7m12.1-.7-.7.7m0 11.4.7.7M6.3 17.7l-.7.7"/></svg></button></p><ul class="list-none flex flex-col gap-1"><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/home/><span>The Project</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/hardware/><span>Hardware</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/software/><span>Software</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/impressum/><span>Impressum</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/articles/><span>Articles</span></a></li><li><a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between hover:bg-slate-200 dark:hover:bg-slate-700" href=/post/><span>Posts</span></a></li></ul><div class=flex-1></div><ul class="list-none flex flex-wrap justify-center gap-1 pt-2 border-t border-slate-200 dark:border-slate-600"></ul></aside><div class="fixed bg-slate-700 bg-opacity-5 transition duration-200 ease-in-out inset-0 z-10 pointer-events-auto md:hidden left-0 top-0 w-full h-full hidden menu-overlay"></div><button aria-label="Toggle Sidebar" class="md:hidden absolute top-3 left-3 z-10 menu-trigger p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-100"><svg class="h-6 w-6" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="18" x2="16" y2="18"/></svg></button><div class=flex-1><main class="h-screen overflow-y-auto"><div class="px-6 py-20 w-full lg:w-[580px] mx-auto prose dark:prose-invert h-fit prose-img:mx-auto"><h1>Schlauer(er) Decoder</h1><p class="text-sm text-slate-500 !mb-8">July 1, 2014</p><p>Im Rahmen unserer Reihe &ldquo;Kleine Verbesserungen an der Architektur&rdquo; ist heute der Adressdekoder dran. Dieser entscheidet bekanntlich anhand der am Adressbus anliegenden Adresse (oder genauergesagt deren höheren 8bit), welcher Baustein an der entsprechenden Adresse eingeblendet werden soll. Durch den Umstand, dass die oberen 8k dem ROM gehören, lassen sich die darunterliegenden 8k RAM nicht ohne weiteres nutzen. Die für die Selektierung des ROMs und der oberen 32k RAM sehen folgendermaßen aus:</p><p>/CSHIRAM = G1*/A2                          + G1*/A1*/A0 /CSROM   = G1*A2                  Wir machen also die CS-Signale statisch von der anliegen Adresse abhängig. Aber es sollte doch möglich sein, grundsätzlich auch zwischen Reads und Writes auf die entsprechenden Adressen zu unterscheiden, oder? Die /RW-Leitung des Prozessors liegt ohnehin am GAL an. Was spricht dagegen, Lesezugriffe nach $e000-$ffff aus dem ROM zu holen, Schreibzugriffe aber immer ins RAM zu leiten? Der C64 kann das schließlich auch. Schreiben wir ein kleines Testprogramm:</p><p>main ldx #$00 loop lda $e000,x sta $e000,x inx cpx #$ff bne loop jmp main</p><p>Wir lesen also aus dem ROM-Bereich und schreiben gleich wieder zurück. Das Oszilloskop zeigt uns /CSHIRAM (gelb) und /CSROM (blau):</p><p>Die Schreibzugriffe landen erwartungsgemäß nicht im RAM, dieses wird zu keiner Zeit selektiert.</p><p>Jetzt passen wir die Gleichungen für /CSHIRAM und /CSROM an, indem wir die Abhängigkeit von /RW berücksichtigen:</p><p>/CSHIRAM = G1*/A2</p><ul><li><p>G1*/A1*/A0</p></li><li><p>/RW*G1*A2*A1 ; Writes to $e000-$ffff go to the RAM</p></li></ul><p>/CSROM   = RW*G1*A2*A1 ; Reads  to $e000-$ffff go to the ROM</p><p>Und jetzt lassen wir unser Programm nochmal laufen:</p><p>Wir erkennen einen Lesezugriff (/CSROM, LDA $e000,x) und direkt darauf einen Schreibzugriff ins RAM (/CSHIRAM, STA $e000,x).</p><p>Hurra, schreiben wir jetzt &ldquo;ins ROM&rdquo;, landen unsere Schreibzugriffe automatisch im darunterliegenden RAM. Allerdings nützt uns das noch nichts, denn noch können wir aus dem RAM nicht lesen.</p><p>Im nächsten Teil erweitern wir also die GAL-Logik um einen Steuerpin, mit dem wir das ROM vollständig ausblenden und das RAM entsprechend freilegen können.</p></div></main></div><script type=text/javascript src=/main.js defer></script></body></html>