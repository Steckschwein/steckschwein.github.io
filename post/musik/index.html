<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Musik - Steckschwein</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Musik"><meta property="og:description" content="Das Programmieren von Soundchips ist nicht trivial. Das habe ich damals auf dem C64 schon nicht kapiert. Mit dem Yamaha YM3812 oder auch OPL2 hat das Steckschwein einen weit komplexeren Chip als den SID, denn OPL2 kennt gleich ganze 9 Stimmen statt drei, und jede ist über eine Unzahl Parameter konfigurierbar.
Wie funktioniert der YM3812? Wie kriegt man also einen Ton aus diesem Monstrum? Die beste Quelle zum Thema OPL2 ist wohl &ldquo;Programming the AdLib/Sound Blaster FM Music Chips&rdquo; von Jeffrey S."><meta property="og:type" content="article"><meta property="og:url" content="https://www.steckschwein.de/post/musik/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-07-13T00:00:00+00:00"><meta property="article:modified_time" content="2017-07-13T00:00:00+00:00"><meta itemprop=name content="Musik"><meta itemprop=description content="Das Programmieren von Soundchips ist nicht trivial. Das habe ich damals auf dem C64 schon nicht kapiert. Mit dem Yamaha YM3812 oder auch OPL2 hat das Steckschwein einen weit komplexeren Chip als den SID, denn OPL2 kennt gleich ganze 9 Stimmen statt drei, und jede ist über eine Unzahl Parameter konfigurierbar.
Wie funktioniert der YM3812? Wie kriegt man also einen Ton aus diesem Monstrum? Die beste Quelle zum Thema OPL2 ist wohl &ldquo;Programming the AdLib/Sound Blaster FM Music Chips&rdquo; von Jeffrey S."><meta itemprop=datePublished content="2017-07-13T00:00:00+00:00"><meta itemprop=dateModified content="2017-07-13T00:00:00+00:00"><meta itemprop=wordCount content="821"><meta itemprop=keywords content="opl2,audio,ym3812,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Musik"><meta name=twitter:description content="Das Programmieren von Soundchips ist nicht trivial. Das habe ich damals auf dem C64 schon nicht kapiert. Mit dem Yamaha YM3812 oder auch OPL2 hat das Steckschwein einen weit komplexeren Chip als den SID, denn OPL2 kennt gleich ganze 9 Stimmen statt drei, und jede ist über eine Unzahl Parameter konfigurierbar.
Wie funktioniert der YM3812? Wie kriegt man also einen Ton aus diesem Monstrum? Die beste Quelle zum Thema OPL2 ist wohl &ldquo;Programming the AdLib/Sound Blaster FM Music Chips&rdquo; von Jeffrey S."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=Steckschwein rel=home><div class="logo__item logo__text"><div class=logo__title>Steckschwein</div><div class=logo__tagline>An 8bit computer for the 21st century</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li><li class=menu__item><a class=menu__link href=/><span class=menu__text>Blog</span></a></li><li class=menu__item><a class=menu__link href=/hardware/><span class=menu__text>Hardware</span></a></li><li class=menu__item><a class=menu__link href=/software/><span class=menu__text>Software</span></a></li><li class=menu__item><a class=menu__link href=/resources/><span class=menu__text>Resources</span></a></li><li class=menu__item><a class=menu__link href=/impressum/><span class=menu__text>Impressum</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Musik</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-07-13T00:00:00Z>July 13, 2017</time></div></div></header><div class="content post__content clearfix"><p>Das Programmieren von Soundchips ist nicht trivial. Das habe ich damals auf dem C64 schon nicht kapiert. Mit dem Yamaha YM3812 oder auch OPL2 hat das Steckschwein einen weit komplexeren Chip als den SID, denn OPL2 kennt gleich ganze 9 Stimmen statt drei, und jede ist über eine Unzahl Parameter konfigurierbar.</p><h2 id=wie-funktioniert-der-ym3812>Wie funktioniert der YM3812?</h2><p>Wie kriegt man also einen Ton aus diesem Monstrum? Die beste Quelle zum Thema OPL2 ist wohl &ldquo;<a href=http://www.shipbrook.net/jeff/sb.html>Programming the AdLib/Sound Blaster FM Music Chips</a>&rdquo; von Jeffrey S. Lee. Zumindest wird einem hier schnell klar, was auf einen zukommt, will man auch nur einen einfachen Ton ausgeben. So hat der OPL2-Chip insgesamt 244 Register, die neben den Stimmen auch die integrierten Timer konfigurieren, und belegt 2 Portadressen. Konkret bedeutet das, dass man in Adresse 1 die Nummer des gewünschen Registers schreibt. Nach 3.3µs liegt an Adresse 2 das gewählte Register zum Beschreiben an. Lesen läßt sich nur das Statusregister. Hat man also das gewählte Register beschrieben, ist der Chip dann 23µs nicht ansprechbar.</p><p>Zunächst müssen wir also dafür sorgen, dass der Soundchip seine Daten mit dem richtigen Timing bekommt. Der Einfachheit halber machen wir das nicht über Timer, sondern mit NOPs. Die Länge der Nopslides zu berechnen, überlassen wir dem Assembler. Um Platz zu sparen, nutzen wir eine Nopslide mit zwei Einsprüngen.</p><p>opl2_data_delay_time = 25000
opl2_reg_delay_time = 5000</p><p>opl2_data_delay = ((opl2_data_delay_time - opl2_reg_delay_time) / (1000/clockspeed)) / 2 -12
opl2_reg_delay = (opl2_reg_delay_time / (1000/clockspeed)) / 2 -12</p><p>Und die entsprechenden Subroutinen. Die je 6 Zyklen für JSR und RTS sind ja oben schon abgezogen:</p><p>opl2_delay_data: ; 23000ns / 0
.repeat opl2_data_delay
nop
.endrepeat</p><p>opl2_delay_register: ; 3300 ns
.repeat opl2_reg_delay
nop
.endrepeat
rts</p><p>Das wäre also geklärt.</p><h2 id=futter-für-den-soundchip>Futter für den Soundchip</h2><p>Nachdem also schonmal klar ist, auf welch umständliche Weise der Chip mit Daten betankt werden will, bleibt nur noch die Frage: Betanken womit? FM-Synthese ist ein zu weites Feld, als dass wir dort jetzt tief einsteigen wollen. Viel naheliegender wäre ein Player für eingängige Musikfiles. Erste <a href=http://steckschwein.de/2015/01/04/das-schwein-kann-singen/>Experimente von Marko mit den von DosBox erzeugten DRO Files</a> waren schon recht vielversprechend. Leider ist es etwas umständlich, mit DosBox neue Musikstücke zu konvertieren, und auch die Trefferquote für lauffähige Stücke ist nicht besonders hoch. Zudem ist der von uns verwendete Player ein ziemlicher Hack mit per NOP grob hingefummelten Timings. Dieser war ursprünglich mal für ein OPL2-Modul für den C64 geschrieben worden. Was es nicht alles gibt. MIDI-Files wollen wir uns auch noch nicht antun, weil wir hier eine Umsetzung der verwendeten MIDI-Instrumente in OPL2-Parameter hätten bauen müssen. Ideal wäre ein Dateiformat, das die OPL2-Registerwerte bereits enthält.</p><p>Zum Glück hat sich damals id-Software zu Zeiten der Commander Keen-Spiele etwas entsprechendes ausgedacht: Das <a href=http://www.shikadi.net/moddingwiki/IMF_Format>IMF-Format</a>. Dieses Format wurde für eine Reihe früher id-Software-Spiele und deren Ableger verwendet, von Commander Keen 4-6 über Duke Nukem II bis hin zu Wolfenstein 3D. Dementsprechend groß ist die Anzahl der verfügbaren Musikstücke.</p><p>IMF-Dateien sind äußerst simpel aufgebaut, jede Datei ist im Prinzip eine Abfolge von 4byte-Paketen, die Registernummer, Registerwert und die Dauer der Pause bis zum nächsten Wert enthalten:</p><p>Register (8bit) | Wert (8bit) | Pause (16bit)</p><p>Die &ldquo;Pause&rdquo; ist in &ldquo;Ticks&rdquo; angegeben, welche sich auf die Abspielfrequenz des jeweiligen Stückes bezieht. Diese ist meist entweder 560Hz oder 700Hz. Hier kommt dann ein Timer-Interrupt zum Einsatz, der 560 oder 700mal in der Sekunde ausgeführt wird. Hierzu verwenden wir Timer 1 des 6522 VIA. Der OPL2 Chip hat zwar auch Timer, aber diese basieren auf festen Intervallen von 80µs bzw 320µs, was in unserem Fall nicht so richtig aufgeht.</p><p>Der Plan ist folgender: Das IMF-File wird komplett in den Speicher geladen. Dann positionieren wir einen Zeiger auf den Anfang der im Speicher befindlichen Daten.</p><p>In der Zeropage benutzen wir 2 Bytes als unseren Delay-Zähler. Diesen setzen wir inital auf 0. In der Interrupt-Routine prüfen wir als erstes, ob der Delay-Zähler 0 ist. Wenn nicht, dekrementieren wir ihn und verlassen die Routine wieder. Ist der Zähler 0, setzen wir das Datenbyte aus unseren IMF-Daten in das vorgesehene Register. Dann rücken wir den Datenzeiger um 4 Bytes weiter, setzen den Delay-Zähler neu, und verlassen den Interrupt.</p><pre tabindex=0><code>player_isr:
 pha
 phy

bit via1ifr ; Interrupt from VIA?
 bpl @isr_end

bit via1t1cl ; Acknowledge timer interrupt by reading channel low

; delay counter zero? 
 lda delayh
 clc
 adc delayl
 beq @l1

; if no, 16bit decrement and exit routine
 dec16 delayh

bra @isr_end
@l1:

ldy #$00
 lda (imf_ptr),y
 sta opl_stat

iny
 lda (imf_ptr),y

jsr opl2_delay_register

sta opl_data

iny
 lda (imf_ptr),y
 sta delayh

iny
 lda (imf_ptr),y
 sta delayl

; song data end reached? then set state to 80 so loop will terminate
 lda imf_ptr_h
 cmp imf_end+1
 bne @l3
 lda imf_ptr
 cmp imf_end+0
 bne @l3

lda #$80
 sta state

bra @isr_end
@l3:

;advance pointer by 4 bytes
 clc
 lda #$04
 adc imf_ptr
 sta imf_ptr
 bcc @isr_end
 inc imf_ptr_h
@isr_end:
 ; jump to kernel isr
 ply
 pla
 jmp (old_isr)
</code></pre><p><a href=https://github.com/Steckschwein/code/tree/master/progs/imfplayer>Der vollständige Player</a> ist in unserem <a href=https://github.com/Steckschwein/code>Github-Repository</a> zu finden. Wir gehen jetzt den Wolfenstein 3D-Soundtrack hören.</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/opl2/ rel=tag>opl2</a></li><li class=tags__item><a class="tags__link btn" href=/tags/audio/ rel=tag>audio</a></li><li class=tags__item><a class="tags__link btn" href=/tags/ym3812/ rel=tag>ym3812</a></li></ul></div></footer></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2024 Steckschwein.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>