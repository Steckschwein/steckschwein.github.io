<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Software - Steckschwein</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Software"><meta property="og:description" content="BIOS At initial boot time, the ROM bank containing the BIOS is banked in at top memory. The BIOS provides the RESET vector, and initializes the hardware, such as the UART and the video chip. Then, it checks for an SD card, tries to mount it and open the OS loader executable (usually LOADER.PRG). If this is successful, the OS loader is executed and loads the actual operating system &ldquo;steckOS&rdquo;. On failure, the BIOS expects a binary uploaded via XMODEM."><meta property="og:type" content="article"><meta property="og:url" content="https://www.steckschwein.de/software/"><meta property="article:section" content><meta itemprop=name content="Software"><meta itemprop=description content="BIOS At initial boot time, the ROM bank containing the BIOS is banked in at top memory. The BIOS provides the RESET vector, and initializes the hardware, such as the UART and the video chip. Then, it checks for an SD card, tries to mount it and open the OS loader executable (usually LOADER.PRG). If this is successful, the OS loader is executed and loads the actual operating system &ldquo;steckOS&rdquo;. On failure, the BIOS expects a binary uploaded via XMODEM."><meta itemprop=wordCount content="773"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Software"><meta name=twitter:description content="BIOS At initial boot time, the ROM bank containing the BIOS is banked in at top memory. The BIOS provides the RESET vector, and initializes the hardware, such as the UART and the video chip. Then, it checks for an SD card, tries to mount it and open the OS loader executable (usually LOADER.PRG). If this is successful, the OS loader is executed and loads the actual operating system &ldquo;steckOS&rdquo;. On failure, the BIOS expects a binary uploaded via XMODEM."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=Steckschwein rel=home><div class="logo__item logo__text"><div class=logo__title>Steckschwein</div><div class=logo__tagline>An 8bit computer for the 21st century</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li><li class=menu__item><a class=menu__link href=/><span class=menu__text>Blog</span></a></li><li class=menu__item><a class=menu__link href=/hardware/><span class=menu__text>Hardware</span></a></li><li class=menu__item><a class=menu__link href=/software/><span class=menu__text>Software</span></a></li><li class=menu__item><a class=menu__link href=/resources/><span class=menu__text>Resources</span></a></li><li class=menu__item><a class=menu__link href=/impressum/><span class=menu__text>Impressum</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Software</h1><div class="post__meta meta"><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/software/ rel=category>software</a></span></div></div></header><div class="content post__content clearfix"><h1 id=bios>BIOS</h1><p><img src=images/bios.png alt="bios startup message"></p><p>At initial boot time, the ROM bank containing the BIOS is banked in at top memory. The BIOS provides the RESET vector, and initializes the hardware, such as the UART and the video chip.
Then, it checks for an SD card, tries to mount it and open the OS loader executable (usually LOADER.PRG). If this is successful, the OS loader is executed and loads the actual operating system &ldquo;steckOS&rdquo;.
On failure, the BIOS expects a binary uploaded via XMODEM.</p><h1 id=steckos>steckOS</h1><p><img src=images/steckOS.png alt="steckOS right after boot"></p><p>The operating system loader (LOADER.PRG) contains the actual steckOS kernel, and the startup code that loads the OS and starts up the kernel. The OS loader as well as any executable in steckOS are in PRG format with the load address in the first two bytes as known from Commodore computers.</p><h2 id=kernel>kernel</h2><p>After having been loaded by the OS loader, the kernel initializes the hardware (again), mounts the SD card and tries to find the shell executable, which it then executes.
The steckOS kernel provides basic interrupt handling, text display routines for the VDP and a jumptable with kernel calls.</p><h2 id=library>library</h2><p>Hardware interfacing code and utility routines both used by BIOS and steckOS are located in the library. Examples are utility routines to convert binary to ASCII decimal or hexadecimal, but also the SD card driver and FAT32 file system implementation.</p><h2 id=shell>shell</h2><p>The steckShell is a simple REPL interface roughly modeled after the Unix sh shell. The shell only has one builtin command, &ldquo;cd&rdquo;. Every other command is searched for in the &ldquo;PATH&rdquo; and executed. Commands and tools are mostly named after their Unix / DOS counterparts.</p><h3 id=commands-and-tools>commands and tools</h3><p>So what can you do with steckOS? The short answer is - not much. steckOS&rsquo;s primary goal was to be able to navigate the file system and start programs.
To be able to do this, we had to write (or port) a couple of commands and a few tools, a few of which we want to introduce:</p><h4 id=help>help</h4><p><img src=images/help.png alt="steckOS right after boot"></p><p>The &ldquo;help&rdquo;-command lists the most important commands.</p><h4 id=ll>ll</h4><p><img src=images/ll.png alt="steckOS ll command output"></p><p>Like it&rsquo;s Unix/Linux counterpart, ll shows the content of the current directory or the directory specified as command line argument. The output resembles that of DOS&rsquo;s dir command.</p><h4 id=ls>ls</h4><p><img src=images/ls.png alt="steckOS ls command output"></p><p>Displays directory contents in short form, just like the ls command in Unix/Linux.</p><h4 id=stat>stat</h4><p><img src=images/stat.png alt="steckOS stat command output"></p><p>Much like the Unix/Linux stat command, stat shows meta information about a file or directory, including file attributes. There is also an attrib command to set/unset attributes.</p><h4 id=attrib>attrib</h4><p><img src=images/attrib.png alt="steckOS attrib command example"></p><p>Much like it&rsquo;s DOS counterpart, attrib is used to set/unset certain FAT attributes such as the hidden bit.</p><h4 id=fsinfo>fsinfo</h4><p><img src=images/fsinfo.png alt="steckOS fsinfo command output"></p><p>fsinfo lists some information about the currently mounted FAT32 file system.</p><h4 id=nvram>nvram</h4><p><img src=images/nvram.png alt="steckOS nvram command output"></p><p>nvram shows and/or modifies the contents of the RTCs NVRAM. The NVRAM is used to store the OS loader filename, UART settings like baud rate and line parameters, and the keyboard delay and repeat rate. nvram is written in C.</p><h4 id=date-and-setdate>date and setdate</h4><p><img src=images/date_setdate.png alt="steckOS nvram command output"></p><p>date and setdate are used to display or set the RTC time. date and setdate are written in C.</p><h4 id=banner>banner</h4><p><img src=images/banner.png alt="steckOS banner command output"></p><p>A version of the Unix SYS V banner command taken from <a href=https://github.com/uffejakobsen/sysvbanner/blob/master/banner.c>here</a>. One of the few tools written in C. The source compiled with cc65 without modifications. We changed some int variables to unisigned char anyway to fit our 8bit CPU.</p><h4 id=wozmon>wozmon</h4><p><img src=images/wozmon.png alt="steckOS wozmon showing the memory mapping registers"></p><p>Steve Wozniak&rsquo;s legendary memory monitor fitting in one page (256 bytes). The effort of adapting it to steckOS is documented in <a href=/post/wozmon-a-memory-monitor-in-256-bytes/>this blog post</a></p><h2 id=programming-languages>Programming languages</h2><p>An 8bit computer is nothing without period correct interpreter languages like BASIC and Forth.</p><h3 id=ehbasic>EhBasic</h3><p><img src=images/ehbasic.png alt=ehbasic></p><p>EhBasic is a quite common BASIC interpreter among homebrew enthusiasts because of it&rsquo;s easy portability. Our version is based on the <a href="http://forum.6502.org/viewtopic.php?f=5&amp;t=5760">65c02 version by forum.6502.org user floobydust</a>. We extended it with a few graphics commands that interface with the V9958&rsquo;s command engine and implemented a <a href=/post/ascii_ehbasic/>LOAD routine that accepts ASCII source files</a>.</p><h3 id=taliforth2>TaliForth2</h3><p><img src=images/taliforth.png alt="tali forth"></p><p><a href=https://github.com/scotws/TaliForth2>TaliForth 2</a> is a subroutine threaded code (STC) implementation of an ANS-based Forth for the 65c02 written by Scot W. Stevenson.</p><h2 id=games>Games</h2><p>A computer is nothing without games, so we had to write/port a few.</p><h3 id=dinosaur>dinosaur</h3><p><img src=images/dinosaur.png alt=dinosaur></p><p>An endless runner, just like the one built-in into the Chrome browser.</p><h3 id=pong>pong</h3><p><img src=images/pong.png alt=pong></p><p>Our pong clone uses the TMS9918&rsquo;s multicolor mode with 64x48 pixels. Yes, those squares are single pixels.</p><h3 id=microchess>MicroChess</h3><p><img src=images/microchess.png alt=microchess></p><p>MicroChess is a chess game, written in 1976 for the MOS/Commodore KIM-1 by Peter Jennings, making the KIM-1 the first affordable chess computer. Our version is based on the <a href=http://6502.org/source/games/uchess/uchess.htm>serial line version by Daryl Rictor</a> which includes display of a chess board.</p><h2 id=other-neat-stuff>Other neat stuff</h2><h3 id=unrclock>unrclock</h3><p><img src=images/unrclock.png alt=unrclock></p><p>An unary clock, nice to look at, useful as screen saver, and like pong another showcase for the 64x48 pixel multicolor mode.</p></div></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 Steckschwein.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>