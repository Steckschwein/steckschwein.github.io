<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>vdp on Steckschwein</title><link>https://www.steckschwein.de/tags/vdp/</link><description>Recent content in vdp on Steckschwein</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 24 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.steckschwein.de/tags/vdp/index.xml" rel="self" type="application/rss+xml"/><item><title>Generating QR Codes</title><link>https://www.steckschwein.de/post/2024/04/generating-qrcodes/</link><pubDate>Wed, 24 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/2024/04/generating-qrcodes/</guid><description>In order to generate our own QR codes natively on the Steckschwein, we drew a lot of inspiration from this article https://8bitworkshop.com/docs/posts/2022/8bit-qr-code.html
It even points to an adapted version of the qrtiny library, that has been made to compile with cc65, including a demo for the Apple ][, using cc65&amp;rsquo;s own Tiny Graphics Interface (TGI). Which is very nice, because all the hard work has already been done.
We have not implemented TGI (yet?</description></item><item><title>Sorting Demo</title><link>https://www.steckschwein.de/post/2024/04/sorting/</link><pubDate>Wed, 17 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/2024/04/sorting/</guid><description>To share my fascination for the numerous sorting algorithm videos on youtube, I took some sorting algorithm examples in C from https://www.geeksforgeeks.org/sorting and visualized them using our BGI compatible C graphics library (more about that later).
The algorithms shown are:
Bubble Sort Cocktail shaker Sort Gnome Sort Insertion Sort Comb Sort Heap Sort Shell Sort Selection Sort Quick Sort Merge Sort Radix Sort The code examples from https://www.geeksforgeeks.org/sorting are only slightly adapted and could be compiled with cc65 almost instantly.</description></item><item><title>V9958 YJK (YUV) mode</title><link>https://www.steckschwein.de/post/2024/03/v9958_yjk_mode/</link><pubDate>Wed, 20 Mar 2024 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/2024/03/v9958_yjk_mode/</guid><description>Some time ago we introduced a tiny tool called ppmview.prg in our collection of tools and progs for our Steckschwein. The ppmview.prg, as the name already tells, is able to load an image in ppm (Portable BitMap) format with a maximum size of 256x212px and displays it on the screen.
The first version of ppmview was released in 2018 and since then we just use the SCREEN 8 (MSX) also known as graphic mode 7 (RGB).</description></item><item><title>V9958 - "The WAIT" - investigation of the CPU/VDP /WAIT interface</title><link>https://www.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</link><pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.steckschwein.de/post/v9958-the-wait-investigation-of-the-cpu-vdp-wait-interface/</guid><description>&amp;hellip; on the way back to munich, we had some time to do a little code review of our gfx library. thinking about the cpu to video chip timings and again read the well known datasheets of the V9938/V9958. suddenly i got an enlightenment and we came to the following conclusion.
as described in the datasheet (V9958-Technical-manual_v1.0.pdf) of the V9958 there are different timings given for different kind of writes. so as far as we understand there are the following timings</description></item></channel></rss>